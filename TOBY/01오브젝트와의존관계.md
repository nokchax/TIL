# 오브젝트와 의존관계

## 스프링과 객체지향
스프링에서 가장 중요하게 생각하는 것은 객체지향 프로그래밍이다. 객체지향 기술의 진정한 가치를 회복시키고, 그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이 스프링의 철학이다.

그래서 스프링에서 가장 관심을 많이 두는 대상은 오브젝트이다.

### 초난감 DAO(Data Access Object)
사용자 정보를 DB에 저장하고 조회할 수 있는 DAO를 만들어 보자
~~~Java
@Data
public class User {
  String id;
  String name;
  String password;
}
~~~
위와 같은 사용자 정보를 저장할 클래스를 만들고,
~~~Java
public class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "id", "pw");

    PreparedStatement ps = c.preparedStatement(
    "insert into users(id, name, password) values(?, ?, ?)";
    );
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    ps.excuteUpdate();

    ps.close();
    c.close();
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "id", "pw");

    PreparedStatement ps = c.preparedStatement(
    "select * from users where id = ?"
    );
    ps.setString(1, id);

    ResultSet rs = ps.excuteQuery();
    rs.next();

    User user = new User();
    user.setId(rs.getString("id"));
    user.setName(rs.getString("name"));
    user.setPassword(rs.getString("password"));

    rs.close();
    ps.close();
    c.close();

    return user;
  }
}
~~~
DAO도 만들었다, 이제 제대로 동작하는지 확인하기 위해 테스트를 해야하는데 어떻게 할까?

### main()을 이용한 DAO 테스트 코드
만들어진 코드를 검증하고자 할때 가장 간단한 방법은 오브젝트 스스로 자신을 검증하도록 만들어주는 것이다. 모든 클래스에는 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스태틱 메소드 main()이 있다.
UserDao 오브젝트를 생성해서 add()와 get()메소드를 검증해보자

~~~Java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
  UserDato dao = new UserDao();

  User user = new User();
  user.setId("retrokarr");
  user.setName("김광현");
  user.setPassword("retro");

  dao.add(user);

  System.out.println(user.getId() + " 등록 성공");

  User user2 = dao.get(user.getId());
  System.out.println(user2.getName());
  System.out.println(user2.getPassword());

  System.out.println(user2.getId() + " 조회 성공");
}

#retrokarr 등록 성공
#김광현
#retro
#retrokarr 조회 성공
~~~
main() 메소드를 실행하면 마지막 네줄의 성공 메세지를 얻을 수 있다.

이렇게 사용자 정보의 동록과 조회가 되는 DAO와 테스트용 메소드까지 완성했다. 그런데 이 코드에는 문제점이 많다. 그 문제점은 무엇일까 생각해보자.

- 왜 코드에 문제가 많다고 하는 것일까?
- DAO 코드를 개선했을때의 장점은 무엇일까?
- 그러한 장점들이 당장, 미래에 주는 이익은 무엇일까?

스프링을 공부한다는 건 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.

## DAO의 분리
### 관심사의 분리
프로그래밍 세계에서는 모든 것이 변한다. 단순히 변수나 오브젝트 필드의 값이 변한다는게 아니라, 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다. 요구사항, 코드, 운영 환경 뿐만 아니라 기술 또한 시간이 지남에 따라 바뀐다.

그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 미래의 변화를 어떻게 대비할 것인가이다. 그래야만 미래에 닥칠지 모르는 거대한 작업으로 인한 부담과 변경에 따른 스트레스, 갈등을 최소화할 수 있다.

미래를 준비하는 데 있어 가장 중요한 과제는 **변화에 어떻게 대비할 것인가** 이며, 가장 좋은 대책은 **변화의 폭을 최소한으로 줄여주는 것** 이다.

###### 객체지향의 의미
> 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경,발전, 확장시킬 수 있다는 데 더 의미가 있다.

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? 그것은 *분리와 확장* 을 고려한 설계를 했을때 가능하다.

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다, 문제는 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 할 곳에 집중되지 않는 경우가 많다는 점이다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다. 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

###### 관심사의 분리
> 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.

### 커넥션 만들기의 추출

#### UserDao의 관심사항
UserDao의 관심사항에 대해 살펴보자
-  DB와 연결을 위한 커넥션을 어떻게 가져올까라는 관심. 어떤 DB를 사용하고, 어떤 드라이버를 사용하고 등 상세하게 구분할 수 있지만 간단하게 DB 연결에 대한 관심사라고 하자.
- 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것.
- 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아서 리소스를 반환하는 것.

현재는 DB 커넥션을 가져오는 코드는 다른 괌심사와 섞여서 같은 add() 메소드에 담겨 있다. 더 큰 문제는 add() 메소드에 있는 DB 커넥션을 가져오는 코드와 동일한 코드가 get() 메소드에도 중복되어 있다는 점이다. DAO에 메소드가 많아지면 많아질 수록 중복코드가 나타날 것이고, 이렇게 하나의 관심사가 방만하게 중복되고, 여기저기 흩어져서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 고통을 일으키는 원인이 된다.

#### 중복 코드의 메소드 추출
가장 먼저 할 일은 커넥션을 가져오는 중복된 코드를 분리하는 것이다. 중복된 DB 연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만들어 두자.

~~~Java
public void add(User user) throws ClassNotFoundException, SQLException {
  Connection c = getConnection();
  ...
}

public User get(String id) throws ClassNotFoundException, SQLException {
  Connection c = getConnection();
  ...
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
  Class.forName("com.mysql.jdbc.Driver");
  Connection c = DriverManager.getConnection(
    "jdbc:mysql://localhost/springbook", "spring", "book"
  );

  return c;
}
~~~

메소드가 많아졌다고 상상해보자, DB 연결과 관련된 부분에 변경이 일어났을 경우 앞으로는 getConnection()이라는 한 메소드의 코드만 수정하면 된다. 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다.

#### 변경사항에 대한 검증 : 리팩토링과 테스트를
방금 한 작업은 UserDao의 기능에는 변화를 주지 않았다. 다만 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리해낸 것이다. 기능에는 영향을 주지 않으면서 코드의 구조만 변경했다. 이처럼 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 **리팩토링** 이라고 하며, 메소드로 중복된 코드를 뽑아내는 것을 **메소드 추출** 기법이라고 부른다.

###### 리팩토링의 이점
>리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다.

### DB 커넥션 만들기의 독립

초보적인 관심사의 분리 작업이지만, 메소드 추출만으로도 변화에 좀 더 유연하게 대처할 수 있는 코드를 만들었다. 이번에는 좀 더 나아가서 변화에 대응하는 수준이 아니라, 변화를 반기는 DAO를 만들어 보자.

UserDao가 발전하고, 널리 알려지면서 여러 회사에서 구매하여 사용하겠다고 하는 상황을 상상해보자, 문제는 사용을 원하는 회사에서는 다른 DB를 사용하고 있으며, DB커넥션을 가져오는 데 있어 독자적인 방법을 만들어 적용하고 싶어한다는 점이다. 더 큰 문제는 DB 커넥션을 가져오는 방법이 종종 변경될 가능성이 있다는 점이다.

이런경우 UserDao의 소스코드를 제공하고 직접 getConnection() 메소드를 수정해서 사용하라고 할수도 있지만, UserDao의 소스를 공개하고 싶지 않는 경우에는 어떻게 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?

#### 상속을 통한 확장

UserDao 코드를 한 단계 더 분리하면 위의 문제를 해결 할 수 있다. UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만드는 것이다. 이렇게 하면 추상 메소드라서 메소드 코드는 없지만 메소드 자체는 존재한다. 따라서 add(), get() 메소드에서 getConnection()을 호출하는 코드는 그대로 유지할 수 있다.

UserDao의 구입사들은 UserDao 클래스를 상속해서 각각 NUserDao와 DUserDao라는 서브 클래스를 만들고 getConnection() 메소드를 원하는 방식대로 구현할 수 있다. 이렇게 하면 소스코드를 제공해서 수정해 쓰도록 하지 않아도 getConnection() 메소드를 원하는 방식으로 확장한 후에 UserDao의 기능과 함께 사용할 수 있다.

~~~text
          +----------------+
          |UserDao         |
          +----------------+
          |add()           |
          |get()           |
          |getConnection() |
          +--------+-------+
                   △
                   |
         +---------+----------+
         |                    |
+--------+-------+   +--------+-------+
|NUserDao        |   |DUserDao        |
+----------------+   +----------------+
|getConnection() |   |getConnection() |
+----------------+   +----------------+
~~~

~~~Java
public abstract class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c= getConnection();
    ...
  }

  public abstrac Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // N사의 DB connection 생성 코드
  }
}

public class DUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // D 사 DB connection 생성 코드
  }
}
~~~

DAO의 핵심 핵심 기능인 데이터를 등록하고 가져오는 것에 관한 관심을 담당하는 UserDao와 DB 연결 방법을 어떻게 할것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.

클래스 계층구조를 통해 두 개의 괌심이 독립적으로 분리되면서 변경 작업이 용이해졌다. UserDao의 코드 한 줄도 수정할 필요 없이 DB연결 기능을 새롭게 정의한 클래스를 만들 수 있다.

###### 템플릿 메소드 패턴
이렇게 슈퍼 클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 템플릿 메소드 패턴이라고 한다. 스프링에서 애용되는 패턴이다.

UserDao의 getConnection() 메소드는 Connection 타입 오브젝트를 생성하는 기능을 정의해 놓은 추상 메소드다. 그리고 UserDao의 서브클래스의 getConnection() 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고 할 수 있다.

###### 팩토리 메소드 패턴
서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 한다.

디자인 패턴용어에 당황해 하지 말자, 중요한 건 상속구조를 통해 성격이 다름 관심사항을 분리한 코드를 만들어 냈고, 서로 영향을 덜 주도록 했다는 것을 이해하는 것이다.

###### 디자인 패턴
디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다. 디자인 패턴은 주로 객체지향 솔계에 관한 것이고, 대부분 객체지향 설계 원칙을 이용해 문제를 해결한다. 패턴의 설계 구조를 보면 대부분 비슷한데, 그 이유는 객체지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지로 정리되기 때문이다. 하나는 클래스 상속이고 다른 하나는 오브젝트 합성이다. 따라서 패턴의 결과로 나온 코드나 설계 구조만 보면 대부분 비슷해 보인다. 패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도다. 패턴을 적용할 상황, 해결해야 할 문제, 술루션의 고조와 각 요소의 역할과 함께 핵심 의도가 무엇인지를 잘 기억해둬야 한다.

###### 템플릿 메소드 패턴
상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다. 슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 저의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다. 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 한다. 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다.
~~~Java
public abstract class Super {
  public void templateMethod() {
    // 기본 알고리즘 코드
    hookMethod();
    abstractMethod();
  }
  protected void hookMethod() {}//선택적으로 오버라이드 가능한 훅 메소드
  public abstract void abstractMethod(); // 서브클래스에서 반드시 구현해야할 추상 메소드
}

public class Sub1 extends Super {
  protected void hookMethod() {
    ...
  }
  public void abstractMethod() {
    ...
  }
}
~~~

###### 팩토리 메소드 패턴
템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴이다. 슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는 알지 못한다. 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다. 이렇게 서브클래스에서 오브젝트 생성 밥벅과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.

위에서 템플릿 메소드 패턴 또는 팩토리 메소드 패턴으로 관심사항이 다른 코드를 분리해냈고, 서로 독립적으로 변경 또는 확장이 가능하도록 했지만, 이 방법은 상속을 사용했다는 단점이 있다. 상속 자체는 간단하고 사용하기도 편리하게 느껴지지만 많은 한게점이 있다.

첫번째 문제는 UserDao가 다른 목적을 위해 상속을 사용하고 있는 경우이다. 자바는 클래스의 다중상속을 허용하지 않기때문에, 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.

두번째 문제는 상속을 통한 상하위 클래스의 관계는 생각보가 밀접하다는 점이다. 상속을 통해 관심이 다른 기능을 분리했고, 필요에 따라 다양한 구현이 가능하도록 확장성도 줬지만 여전히 상속관계는 두 가지 다른 괌심사에 대해 긴밀한 결합을 허용한다. 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있기 때문에, 슈퍼클래스 내부으 ㅣ변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.

세번째, 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다. UserDao 외의 DAO 클래스가 계속 만들어진다면 그때마다 상속을 통해 만들어진 getConnection()의 구현 코드가 중복돼서 나타나는 문제가 생긴다.

## DAO의 확장
모든 오브젝트는 변한다. 하지만 오브젝트가 다 동일한 방식으로 변하는 건 아니다. 관심사에 따라 분리한 오브젝트들은 제각기 독특한 변화의 특징이 있다. 지금까지는 데이터 액세스 로직을 어떻게 만들것인가와 DB 연결을 어떤 방법으로 할 것인가라는 두 개의 관심을 상하위 클래스로 분리시켰다. 이 두 개의 관심은 변화의 성격이 다르다.

변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다. UserDao는 어떤 SQL을 만들 것인가, 어떤 오브젝트를 통해 DB에 저장할 정보를 전달받고, DB에서 꺼내온 정보를 저장해서 넘겨줄 것인가와 같은 관심을 가진 코드를 모아둔 것이다. 따라서 이런 관심사가 바뀔때 변경이 일어난다.
하지만 이때도 DB 연결방법이 그대로라면 DB 연결 확장 기능을 담은 NUserDao나 DUserDao는 변화가 없다.

추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. 하지만 단점이 많은 상속이라는 방법을 사용했다.

### 클래스의 분리
처음에는 독립된 메소드를 만들어서 분리하고, 다음에는 상하위 클래스로 분리했다. 이번에는 완전히 독립적인 클래스로 만들어 보자.

DB 커넥션과 관련된 부분을 서브클래스가 아닌 별도의 클래스에 담아보자. 그리고 이 클래스를 UserDao가 이용하게 하면 된다.

~~~
//두 개의 독립된 클래스로 분리
+---------------------+
|UserDao              |       +---------------------+
+---------------------+       |SimpleConnectionMaker|
|simpleConnectionMaker|------>+---------------------+
+---------------------+       |makeNewConnection()  |
|add()                |       +---------------------+
|get()                |
+---------------------+
~~~

위 처럼 SimpleConnectionMaker라는 새로운 클래스를 만들고 DB 생성 기능을 그 안에 넣는다. UserDao는 new 키워드를 사용해서 SimpleConnectionMaker 클래스의 오브젝트를 만들어고, add(), get() 메소드에서 사용하면 된다.

~~~Java
public class UserDao {
  private SimpleConnectionMaker simpleConnectionMaker;

  public UserDao() {
    simpleConnectionMaker = new SimpleConnectionMaker();
  }

  public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = simpleConnectionMaker.makeNewConnection();
    ...
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c = simpleConnectionMaker.makeNewConnection();
    ...
  }
}

public class SimpleConnectionMaker {
  public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");

    Connection c = DriverManager.getConnection(
      "jdbc:mysql://localhost/springbook", "spring", "book"
    )

    return c;
  }
}
~~~

코드를 많이 수정했지만 기능에는 변화가 없다. 내부 설계를 변경해서 좀 더 나은 코드로 개선했을 뿐이다. 성격이 다른 코드를 분리하기는 잘한 것 같은데, 다른 문제가 발생했다. N 사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능을 확장해서 사용하게 했던 것이 다시 불가능해졌다. 왜냐하면 UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했을 때 처럼 UserDao 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.
