# 오브젝트와 의존관계

## 스프링과 객체지향
**스프링에서 가장 중요하게 생각하는 것은 객체지향 프로그래밍이다.** 객체지향 기술의 진정한 가치를 회복시키고, 그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이 스프링의 철학이다.

그래서 **스프링에서 가장 관심을 많이 두는 대상은 오브젝트** 이다.

### 초난감 DAO(Data Access Object)
사용자 정보를 DB에 저장하고 조회할 수 있는 DAO를 만들어 보자

~~~Java
@Data
public class User {
  String id;
  String name;
  String password;
}
~~~

위와 같은 사용자 정보를 저장할 클래스를 만들고,

~~~Java
public class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "id", "pw");

    PreparedStatement ps = c.preparedStatement(
    "insert into users(id, name, password) values(?, ?, ?)";
    );
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    ps.excuteUpdate();

    ps.close();
    c.close();
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "id", "pw");

    PreparedStatement ps = c.preparedStatement(
    "select * from users where id = ?"
    );
    ps.setString(1, id);

    ResultSet rs = ps.excuteQuery();
    rs.next();

    User user = new User();
    user.setId(rs.getString("id"));
    user.setName(rs.getString("name"));
    user.setPassword(rs.getString("password"));

    rs.close();
    ps.close();
    c.close();

    return user;
  }
}
~~~

DAO도 만들었다, 이제 제대로 동작하는지 확인하기 위해 테스트를 해야하는데 어떻게 할까?

### main()을 이용한 DAO 테스트 코드
만들어진 코드를 검증하고자 할때 가장 간단한 방법은 오브젝트 스스로 자신을 검증하도록 만들어주는 것이다. 모든 클래스에는 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스태틱 메소드 main()이 있다.
UserDao 오브젝트를 생성해서 add()와 get()메소드를 검증해보자

~~~Java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
  UserDato dao = new UserDao();

  User user = new User();
  user.setId("retrokarr");
  user.setName("김광현");
  user.setPassword("retro");

  dao.add(user);

  System.out.println(user.getId() + " 등록 성공");

  User user2 = dao.get(user.getId());
  System.out.println(user2.getName());
  System.out.println(user2.getPassword());

  System.out.println(user2.getId() + " 조회 성공");
}

~~~

~~~text
#결과
retrokarr 등록 성공
김광현
retro
retrokarr 조회 성공
~~~

main() 메소드를 실행하면 마지막 네줄의 성공 메세지를 얻을 수 있다.

이렇게 사용자 정보의 동록과 조회가 되는 DAO와 테스트용 메소드까지 완성했다. 그런데 이 코드에는 문제점이 많다. 그 문제점은 무엇일까 생각해보자.

- 왜 코드에 문제가 많다고 하는 것일까?
- DAO 코드를 개선했을때의 장점은 무엇일까?
- 그러한 장점들이 당장, 미래에 주는 이익은 무엇일까?

스프링을 공부한다는 건 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.

## DAO의 분리
### 관심사의 분리
**프로그래밍 세계에서는 모든 것이 변한다.** 단순히 변수나 오브젝트 필드의 값이 변한다는게 아니라, 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다. 요구사항, 코드, 운영 환경 뿐만 아니라 기술 또한 시간이 지남에 따라 바뀐다.

그래서 개발자가 **객체를 설계할 때 가장 염두에 둬야 할 사항은 미래의 변화를 어떻게 대비할 것인가이다.** 그래야만 미래에 닥칠지 모르는 거대한 작업으로 인한 부담과 변경에 따른 스트레스, 갈등을 최소화할 수 있다.

미래를 준비하는 데 있어 가장 중요한 과제는 **변화에 어떻게 대비할 것인가** 이며, 가장 좋은 대책은 **변화의 폭을 최소한으로 줄여주는 것** 이다.

###### 객체지향의 의미
> 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경, 발전, 확장시킬 수 있다는 데 더 의미가 있다.

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? 그것은 *분리와 확장* 을 고려한 설계를 했을때 가능하다.

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다, 문제는 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다는 점이다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다. 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

###### 관심사의 분리
> 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.

### 커넥션 만들기의 추출

#### UserDao의 관심사항
UserDao의 관심사항에 대해 살펴보자
- DB 연결에 대한 관심.
- 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것.
- 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아서 리소스를 반환하는 것.

현재는 DB 커넥션을 가져오는 코드는 다른 관심사와 섞여서 같은 add() 메소드에 담겨 있다. 더 큰 문제는 add() 메소드에 있는 DB 커넥션을 가져오는 코드와 동일한 코드가 get() 메소드에도 중복되어 있다는 점이다. DAO에 메소드가 많아지면 많아질 수록 중복코드가 나타날 것이고, 이렇게 하나의 관심사가 방만하게 중복되고, 여기저기 흩어져서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 고통을 일으키는 원인이 된다.

#### 중복 코드의 메소드 추출
가장 먼저 할 일은 커넥션을 가져오는 중복된 코드를 분리하는 것이다. 중복된 DB 연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만들어 두자.

~~~Java
public void add(User user) throws ClassNotFoundException, SQLException {
  Connection c = getConnection();
  ...
}

public User get(String id) throws ClassNotFoundException, SQLException {
  Connection c = getConnection();
  ...
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
  Class.forName("com.mysql.jdbc.Driver");
  Connection c = DriverManager.getConnection(
    "jdbc:mysql://localhost/springbook", "spring", "book"
  );

  return c;
}
~~~

메소드가 많아졌다고 상상해보자, DB 연결과 관련된 부분에 변경이 일어났을 경우 앞으로는 getConnection()이라는 한 메소드의 코드만 수정하면 된다. 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다.

#### 변경사항에 대한 검증 : 리팩토링과 테스트를
방금 한 작업은 UserDao의 기능에는 변화를 주지 않았다. 다만 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리해낸 것이다. 기능에는 영향을 주지 않으면서 코드의 구조만 변경했다. 이처럼 **기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 리팩토링** 이라고 하며, **메소드로 중복된 코드를 뽑아내는 것을 메소드 추출** 기법이라고 부른다.

###### 리팩토링의 이점
>리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다.

### DB 커넥션 만들기의 독립
초보적인 관심사의 분리 작업이지만, 메소드 추출만으로도 변화에 좀 더 유연하게 대처할 수 있는 코드를 만들었다. 이번에는 좀 더 나아가서 변화에 대응하는 수준이 아니라, 변화를 반기는 DAO를 만들어 보자.

UserDao가 발전하고, 널리 알려지면서 여러 회사에서 구매하여 사용하겠다고 하는 상황을 상상해보자, 문제는 사용을 원하는 회사에서는 다른 DB를 사용하고 있으며, DB커넥션을 가져오는 데 있어 독자적인 방법을 만들어 적용하고 싶어한다는 점이다. 더 큰 문제는 DB 커넥션을 가져오는 방법이 종종 변경될 가능성이 있다는 점이다.

이런경우 UserDao의 소스코드를 제공하고 직접 getConnection() 메소드를 수정해서 사용하라고 할수도 있지만, UserDao의 소스를 공개하고 싶지 않는 경우에는 어떻게 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?

#### 상속을 통한 확장
UserDao 코드를 한 단계 더 분리하면 위의 문제를 해결 할 수 있다. UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만드는 것이다. 이렇게 하면 추상 메소드라서 메소드 코드는 없지만 메소드 자체는 존재한다. 따라서 add(), get() 메소드에서 getConnection()을 호출하는 코드는 그대로 유지할 수 있다.

UserDao의 구입사들은 UserDao 클래스를 상속해서 각각 NUserDao와 DUserDao라는 서브 클래스를 만들고 getConnection() 메소드를 원하는 방식대로 구현할 수 있다. 이렇게 하면 소스코드를 제공해서 수정해 쓰도록 하지 않아도 getConnection() 메소드를 원하는 방식으로 확장한 후에 UserDao의 기능과 함께 사용할 수 있다.

~~~text
          +----------------+
          |UserDao         |
          +----------------+
          |add()           |
          |get()           |
          |getConnection() |
          +--------+-------+
                   △
                   |
         +---------+----------+
         |                    |
+--------+-------+   +--------+-------+
|NUserDao        |   |DUserDao        |
+----------------+   +----------------+
|getConnection() |   |getConnection() |
+----------------+   +----------------+
~~~

~~~Java
public abstract class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c= getConnection();
    ...
  }

  public abstract Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // N사의 DB connection 생성 코드
  }
}

public class DUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // D 사 DB connection 생성 코드
  }
}
~~~

DAO의 핵심 핵심 기능인 데이터를 등록하고 가져오는 것에 관한 관심을 담당하는 UserDao와 DB 연결 방법을 어떻게 할것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.

클래스 계층구조를 통해 두 개의 괌심이 독립적으로 분리되면서 변경 작업이 용이해졌다. UserDao의 코드 한 줄도 수정할 필요 없이 DB연결 기능을 새롭게 정의한 클래스를 만들 수 있다.

###### 템플릿 메소드 패턴
> 이렇게 슈퍼 클래스에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 템플릿 메소드 패턴이라고 한다. 스프링에서 애용되는 패턴이다.

UserDao의 getConnection() 메소드는 Connection 타입 오브젝트를 생성하는 기능을 정의해 놓은 추상 메소드다. 그리고 UserDao의 서브클래스의 getConnection() 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고 할 수 있다.

###### 팩토리 메소드 패턴
> 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 팩토리 메소드 패턴이라고 한다.

디자인 패턴 용어에 당황해 하지 말자, 중요한 건 상속구조를 통해 성격이 다름 관심사항을 분리한 코드를 만들어 냈고, 서로 영향을 덜 주도록 했다는 것을 이해하는 것이다.

###### 디자인 패턴
> 디자인 패턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제를 해결하기 위해 사용할 수 있는 재사용 가능한 솔루션을 말한다. 디자인 패턴은 주로 객체지향 설계에 관한 것이고, 대부분 객체지향 설계 원칙을 이용해 문제를 해결한다. 패턴의 설계 구조를 보면 대부분 비슷한데, 그 이유는 객체지향적인 설계로부터 문제를 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부분 두 가지로 정리되기 때문이다. 하나는 ***클래스 상속*** 이고 다른 하나는 ***오브젝트 합성*** 이다. 따라서 패턴의 결과로 나온 코드나 설계 구조만 보면 대부분 비슷해 보인다. 패턴에서 가장 중요한 것은 각 패턴의 핵심이 담긴 목적 또는 의도다. 패턴을 적용할 상황, 해결해야 할 문제, 술루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지를 잘 기억해둬야 한다.

###### 템플릿 메소드 패턴
> 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확장할 기능은 서브클래스에서 만들도록 한다. 슈퍼클래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드를 정의해두고 이를 활용해 코드의 기본 알고리즘을 담고 있는 템플릿 메소드를 만든다. 슈퍼클래스에서 디폴트 기능을 정의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 메소드를 훅(hook) 메소드라고 한다. 서브클래스에서는 추상 메소드를 구현하거나, 훅 메소드를 오버라이드하는 방법을 이용해 기능의 일부를 확장한다.

~~~Java
public abstract class Super {
  public void templateMethod() {
    //기본 알고리즘 코드
    hookMethod();
    abstractMethod();
  }
  protected void hookMethod() {} //선택적으로 오버라이드 가능한 훅 메소드
  public abstract void abstractMethod(); //서브클래스에서 반드시 구현해야할 추상 메소드
}

public class Sub1 extends Super {
  protected void hookMethod() {
    ...
  }
  public void abstractMethod() {
    ...
  }
}
~~~

###### 팩토리 메소드 패턴
> 템플릿 메소드 패턴과 마찬가지로 상속을 통해 기능을 확장하게 하는 패턴이다. 슈퍼클래스 코드에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다. 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는 알지 못한다. 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메소드를 재정의할 수 있다. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 팩토리 메소드라고 하고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 슈퍼클래스의 기본 코드에서 독립시키는 방법을 팩토리 메소드 패턴이라고 한다.

위에서 템플릿 메소드 패턴 또는 팩토리 메소드 패턴으로 관심사항이 다른 코드를 분리해냈고, 서로 독립적으로 변경 또는 확장이 가능하도록 했지만, 이 방법은 상속을 사용했다는 단점이 있다. 상속 자체는 간단하고 사용하기도 편리하게 느껴지지만 많은 한계점이 있다.

첫번째 문제는 UserDao가 다른 목적을 위해 상속을 사용하고 있는 경우이다. 자바는 클래스의 다중상속을 허용하지 않기때문에, 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리면, 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.

두번째 문제는 상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다는 점이다. 상속을 통해 관심이 다른 기능을 분리했고, 필요에 따라 다양한 구현이 가능하도록 확장성도 줬지만 여전히 상속관계는 두 가지 다른 괌심사에 대해 긴밀한 결합을 허용한다. 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있기 때문에, 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있다.

세번째, 확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다는 것도 큰 단점이다. UserDao 외의 DAO 클래스가 계속 만들어진다면 그때마다 상속을 통해 만들어진 getConnection()의 구현 코드가 중복돼서 나타나는 문제가 생긴다.

## DAO의 확장
모든 오브젝트는 변한다. 하지만 오브젝트가 다 동일한 방식으로 변하는 건 아니다. 관심사에 따라 분리한 오브젝트들은 제각기 독특한 변화의 특징이 있다. 지금까지는 데이터 액세스 로직을 어떻게 만들것인가와 DB 연결을 어떤 방법으로 할 것인가라는 두 개의 관심을 상하위 클래스로 분리시켰다. 이 두 개의 관심은 변화의 성격이 다르다.

변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다. UserDao는 어떤 SQL을 만들 것인가, 어떤 오브젝트를 통해 DB에 저장할 정보를 전달받고, DB에서 꺼내온 정보를 저장해서 넘겨줄 것인가와 같은 관심을 가진 코드를 모아둔 것이다. 따라서 이런 관심사가 바뀔때 변경이 일어난다.
하지만 이때도 DB 연결방법이 그대로라면 DB 연결 확장 기능을 담은 NUserDao나 DUserDao는 변화가 없다.

추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸 수 있게 만든 이유는 바로 이렇게 변화의 성격이 다른 것을 분리해서, 서로 영향을 주지 않은 채로 각각 필요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. 하지만 단점이 많은 상속이라는 방법을 사용했다.

### 클래스의 분리
처음에는 독립된 메소드를 만들어서 분리하고, 다음에는 상하위 클래스로 분리했다. 이번에는 완전히 독립적인 클래스로 만들어 보자.

DB 커넥션과 관련된 부분을 서브클래스가 아닌 별도의 클래스에 담아보자. 그리고 이 클래스를 UserDao가 이용하게 하면 된다.

~~~
//두 개의 독립된 클래스로 분리
+---------------------+
|UserDao              |       +---------------------+
+---------------------+       |SimpleConnectionMaker|
|simpleConnectionMaker|------>+---------------------+
+---------------------+       |makeNewConnection()  |
|add()                |       +---------------------+
|get()                |
+---------------------+
~~~

위 처럼 SimpleConnectionMaker라는 새로운 클래스를 만들고 DB 생성 기능을 그 안에 넣는다. UserDao는 new 키워드를 사용해서 SimpleConnectionMaker 클래스의 오브젝트를 만들어고, add(), get() 메소드에서 사용하면 된다.

~~~Java
public class UserDao {
  private SimpleConnectionMaker simpleConnectionMaker;

  public UserDao() {
    simpleConnectionMaker = new SimpleConnectionMaker();
  }

  public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = simpleConnectionMaker.makeNewConnection();
    ...
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c = simpleConnectionMaker.makeNewConnection();
    ...
  }
}

public class SimpleConnectionMaker {
  public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");

    Connection c = DriverManager.getConnection(
      "jdbc:mysql://localhost/springbook", "spring", "book"
    )

    return c;
  }
}
~~~

코드를 많이 수정했지만 기능에는 변화가 없다. 내부 설계를 변경해서 좀 더 나은 코드로 개선했을 뿐이다. 성격이 다른 코드를 분리하기는 잘한 것 같은데, 다른 문제가 발생했다. N 사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기능을 확장해서 사용하게 했던 것이 다시 불가능해졌다. 왜냐하면 UserDao의 코드가 SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했을 때 처럼 UserDao 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.

~~~Java
simpleConnectionMaker = new SimpleConnectionMaker();
~~~

클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 자유롭게 확장이 가능하게 하려면 두 가지 문제를 해결해야 한다.

첫째는 SimpleConnectionMaker의 메소드가 문제다.
위에서는 makeNewConnection()을 사용해서 DB 커넥션을 가져오게 했는데, 만약 D나 N사에서 만든 DB 커넥션 제공 클래스가 openConnection()이라는 메소드 명을 사용했다면 UserDao 내의 add(), get() 메소드에서 커넥션을 가져오는 코드를 다음과 같이 변경해야한다. 메소드가 여러개일 경우 작업량은 그만큼 커진다.

~~~Java
Connection c = simpleConnectionMaker.openConnection();
~~~

두번째 문제는 DB 커넥션을 제공하는 클래스가 어떤 것인지 UserDao가 구체적으로 알고 있어야 한다는 점이다. UserDao에 SimpleConnectionMaker라는 클래스 타입의 인스턴스 변수까지 정의했기 때문에, N사나 D사에서 다른 클래스를 구현하면 어쩔 수 없이 UserDao를 수정해야한다.

이와 같은 문제의 근본적인 원인은 UserDao가 바뀔 수 있는 정보, DB 커넥션을 가져오는 클래스에 대해 너무 많이 알고 있기 때문이다. 어떤 클래스가 쓰이고, 그 클래스에서 어떤 메소드를 사용해야 할지까지 알아야하기 때문에 UserDao는 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버린다.

### 인터페이스의 도입
이 문제의 가장 좋은 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다.

###### 추상화
> 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이다.

자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스다. 인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보를 모두 감춰준다. 오브젝트를 만들려면 구체적인 클래스 하나를 선택해야겠지만 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다. 인터페이스를 통해 접근하게 하면 실제 구현 클래스를 바꿔도 신경 쓸 필요가 없다.

~~~
+---------------+    +----------------+
|UserDao        |    |ConnectionMaker |
+---------------+    +----------------+
|connectionMaker|--->|makeConnection()|
+---------------+    +----------------+
|add()          |             △
|get()          |    +--------+--------+
+---------------+    |                 |
            +----------------+ +----------------+
            |NConnectionMaker| |DConnectionMaker|
            +----------------+ +----------------+
            |makeConnection()| |makeConnection()|
            +----------------+ +----------------+
~~~

인터페이스는 어떤 일을 하겠다는 기능만 정의해둔 것이다. 따라서 어떻게 하겠다는 구현 방법은 나타나 있지 않다.

~~~Java
public interface ConnectionMaker {
  public Connection makeConnection() throws ClassNotFoundException, SQLException;
}

public class DConnectionMaker implements ConnectionMaker {
  public Connection makeConnection() throws ClassNotFoundException, SQLException {
    // D사의 독자적인 Connection 생성 코드
  }
}

public class UserDao {
  private ConnectionMaker connectionMaker;

  public UserDao() {
    connectionMaker = new DConnectionMaker();
  }

  public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = connectionMaker.makeConnection();
    ...
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c = connectionMaker.makeConnection();
    ...
  }
}
~~~

이제는 N사나 D사가 DB 접속용 클래스를 다시 만들어도 UserDao의 코드를 뜯어 고칠 일은 없을 것 같다. 그런데 UserDao코드를 잘 살펴보면 DConnection이라는 클래스 이름이 보인다. 여전히 DConnection 클래스의 생성자를 호출해서 오브젝트를 생성하는 코드가 남아있다.
~~~
connectionMaker = new DConnectionMaker();
~~~

인터페이스를 통해 DB 커넥션을 제공하는 클래스에 대한 구체적인 정보를 모두 제거할 수 있었지만, 초기에 단 한 번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 여전히 제거되지 않았다.
또 다시 원점이다. 여전히 UserDao 소스코드를 함께 제공해서, 필요할 때마다 UserDao의 생성자 메소드를 직접 수정하라고 하지 않고는 고객사의 자유로운 DB 커넥션 확장 기능을 가진 UserDao를 제공할 수 없다.

### 관계설정 책임의 분리
왜 이런 문제가 발생하는 것 일까? 그 이유는 UserDao 안에 분리되지 않은, 또 다른 관심사항이 존재하고 있기 때문이다.

UserDao에는 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 new DConnectionMaker()라는 코드가 있다. 이 코드는 기존 UserDao의 관심사인 JDBC API와 User 오브젝트를 이용해 DB에 정보를 넣고 빼는 것도 아니고, ConnectionMaker 인터페이스로 대표되는 DB 커넥션을 어떻게 가져올 것인가라는 관심사도 아니다. new DConnectionMaker()라는 코드는 매우 짧고 간단하지만 그 자체로 충분히 독립적인 관심사를 담고 있다. 바로 UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트를 이용하게 할지를 결정하는 것이다.
간단히 말하자면 UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심이다.

이 관심사를 담은 코드를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확장 가능한 클래스가 될 수 없다.

UserDao를 사용하는 클라이언트가 적어도 하나는 존재할 것이다. 브라우저나 PC 같은 클라이언트 장비를 말하는 것이 아니다. 두 개의 오브젝트가 있고 한 오브젝트가 다른 오브젝트의 기능을 사용한다면, 사용되는 쪽이 사용하는 쪽에게 서비스를 제공하는 셈이다. 따라서 사용되는 오브젝트를 서비스, 사용하는 오브젝트를 클라이언트라고 할 수 있다. 바로 이 UserDao의 클라이언트 오브젝트가  제 3의 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳이기 때문이다.

UserDao의 클라이언트에서 UserDao를 사용하기 전에, 먼저 UserDao가 어떤 ConnectionMaker의 구현 클래스를 사용할지를 결정하도록 만들어보자. UserDao 오브젝트와 특정 클래스로부터 만들어진 ConnectionMaker 오브젝트 사이에 관계를 설정해주는 것이다.

오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다. 예를 들어 다음 코드는 DConnectionMaker의 오브젝트의 레퍼런스를 UserDao의 connectionMaker 변수에 넣어서 사용하게 함으로써, 두 오브젝트가 *사용* 이라는 관계를 맺게 해준다.

~~~Java
connectionMaker = new DConnectionMaker();
~~~

오브젝트 사이의 관계가 만들어지려면 위처럼 직접 생성자를 호출해서 직접 오브젝트를 만드는 방법도 있지만, 외부에서 만들어준 것을 가져오는 방법도 있다.
외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 이용하면 된다. 이때 파라미터의 타입을 전달받을 오브젝트의 인터페이스로 선언해뒀다고 해보자. 이런경우 파라미터로 전달되는 오브젝트의 클래스는 해당 인터페이스를 구현하기만 했다면 어떤 것이든지 상관없다.

UserDao에 new DConnectionMaker()라는 코드가 나오기 때문에 다음처럼 UserDao와 DConnectionMaker 클래스 사이에 직접적인 관계가 있다.

~~~
+-------+      +---------------+
|UserDao|----->|ConnectionMaker|
+-------+      +---------------+
       |               △
       |      +--------+--------+
       v      |                 |
     +--------+-------+ +-------+--------+
     |DConnectionMaker| |NConnectionMaker|
     +----------------+ +----------------+
~~~

UserDao와 DConnectionMaker사이의 선은 UserDao가 DConnectionMaker를 알고 있기 때문에 생긴 불필요한 의존관계이다.

***클래스 사이에 관계가 만들어진 것은 아니고, 단지 오브젝트 사이에 다이나믹한 관계가 만들어지는 것이다.*** 클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 만들어지는 것이다. 하지만 오브젝트 사이의 관계는 그렇지 않다. 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있으며, 이는 다형성이라는 특징 덕분이다.

UserDao 오브젝트가 DConnectionMaker 오브젝트를 사용하게 하려면 두 클래스의 오브젝트 사이에 런타임 사용관계 도는 링크, 또는 의존관계라고 불리는 관계를 맺어주면 된다.

~~~
+---------+        +------------------+
|:UserDao |―――――――>|:DConnectionMaker |
|￣￣￣￣￣|        |￣￣￣￣￣￣￣￣￣￣|
+---------+        +------------------+
~~~

위와 같은 런타임 오브젝트 관계를 갖는 구조로 만들어주는게 바로 클라이언트의 책임이다. 클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에 UserDao의 세부 전략이라고도 볼 수 있는 ConnectionMaker의 구현 클래스를 선택하고, 선택한 클래스의 오브젝트를 생성해서 UserDao와 연결해줄 수 있다. 기존의 UserDao에서는 생성자에게 이 책임이 있었다. 자신이 사용할 오브젝트를 직접 만들어서, 자신과 관게를 만들어버리는 것이 기존 UserDao 생성자가 한 일이다. 하지만 이것은 UserDao의 관심도 아니고 책임도 아니다. 다른 관심사가 함께 있으니 확장성을 떨어뜨리는 문제를 일으키는 것이다.

이제 이 다른 관심을 분리해서 클라이언트에게 떠넘겨보자. 현재는 UserDao 클래스의 main() 메소드가 UserDao 클라이언트라고 볼 수 있다. 좀 더 깔끔하게 구분하기 위해, UserDaoTest라는 이름의 클래스를 하나 만들고 main() 메소드를 UserDaoTest로 옮겨보자. UserDao의 생성자를 수정해서 클라이언트가 미리 만들어둔 ConnectionMaker의 오브젝트를 전달 받을 수 있도록 파라미터를 추가해 보자.

~~~Java
public UserDao(ConnectionMaker connectionMaker) {
  this.connectionMaker = connectionMaker;
}
~~~

그런데, 이렇게 하고 나니 UserDao에는 ConnectionMaker의 구체적인 구현 클래스 이름이 DConnectionMaer가 사라졌다.

DConnectionMaker는 왜 사라졌을까? DConnectionMaker를 생성하는 코드는 UserDao와 특정 ConnectionMaker 구현 클래스의 오브젝트 간 관계를 맺는 책임을 담당하는 코드였는데, 그것을 UserDao의 클라이언트로 넘겨버렸기 때문이다.

~~~Java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    //UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.
    ConnectionMaker connectionMaker = new DConnectionMaker();
    //UserDao 생성, 사용할 ConnectionMaker 타입의 오브젝트 제공
    //결국 두 오브젝트 사이의 의존관계 설정 효과
    UserDao dao = new UserDao(connectionMaker);
    ...
  }
}
~~~

UserDaoTest는 UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존관계를 설정하는 책임을 담당해야 한다. UserDaoTest가 수고해준 덕분에 이제는 UserDao의 변경 없이도 자유롭게 N 사와 D 사는 DB 접속 클래스를 만들어서 UserDao가 사용하게 할 수 있다.

이렇게 인터페이스를 도입하고 클라이언트의 도움을 얻는 방법은 상속을 사용해 비슷한 시도를 했을 경우에 비해서 훨씬 유연하다. ConnectionMaker 인터페이스를 사용하기만 하면 다른 DAO 클래스에도 ConnectionMaker의 구현 클래스들을 그대로 사용할 수 있기 때문이다. 그렇기 때문에 DAO가 많아지더라도 DB 접속 방법에 관한 관심은 한군데에 집중되게 할 수 있고, DB 접속 방법이 변경되더라도 한 곳의 코드만 수정하면 된다.

~~~
+-----------+ create/supply +-------+      +---------------+
|UserDaoTest|-------------->|UserDao|----->|ConnectionMaker|
+-----------+      use      +-------+      +---------------+
      |                                            △
      |                                            |
      |                                            |
      |                                    +----------------+
      +----------------------------------->|DConnectionMaker|
                     create                +----------------+
~~~

### 원칙과 패턴
#### 개방 패쇄 원칙 (Open-Closed Principle)
**클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀있어야 한다.** UserDao는 DB연결 방법이라는 기능 확장에는 열려있다. UserDao에 전혀 영향을 주지 않고도 얼마든지 기능을 확장할 수 있다. 동시에 UserDao 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고 유지할 수 있으므로 변경에는 닫혀 있다.

위는 개방 폐쇄 원칙을 가장 잘 보여주는 그림이다. 인터페이스를 통해 제공되는 확장 포인트는 확장을 위해 활짝 개방되어 있다. 반면 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다.

###### 객체지향 설계 원칙 (SOLID)
> - SRP(The Single Responsibility Principle) : 단일 책임 원칙
> - OCP(The Open Closed Principle) : 개방 폐쇄 원칙
> - LSP(The Liskov Substitution Principle) : 리스코프 치환 원칙
> - ISP(The Interface Segregation Principle) : 인터페이스 분리 원칙
> - DIP(The Dependency Inversion Principle) : 의존관계 역전 원칙

#### 높은 응집도와 낮은 결합도
개방 폐쇄 원칙은 높은 응집도와 낮은 결합도(High Coherence And Low Coupling)라는 소프트웨어 개발의 고전적인 원리로 설명이 가능하다. 응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다. 불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며, 하나의 공통 관심사는 한 클래스에 모여있다. 높은 응집도는 클래스 레벨뿐 아니라, 패키지, 컴포넌트, 모듈에 이르기까지 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.

##### 높은 응집도
응집도가 높다는 것은 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다는 것으로 설명할 수 있다. 즉 변경이 일어날 때 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다고 말할 수 있다.
처음에 만든 초난감 DAO에서 DB커넥션을 만드는 기능을, DriverManager를 이용한 방법에서 다른 DB 커넥션 풀 라이브러리를 사용하는 방법으로 변경한다고 해보자. 초난감 DAO처럼 여러 관심사와 책임이 얽혀 있는 복잡한 코드에서는 변경이 필요한 부분을 찾아내는 것도 번거로울뿐 더러, 그렇게 변경한 것이 DAO의 다른 기능에 영향을 줘서 오류를 발생시키지 않는지도 확인해야한다.

반면 ConnectionMaker 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우라면, 그저 DB 커넥션 풀을 활용하는 ConnectionMaker 구현 클래스를 새로 만들기만 하면 된다. 기존에 구현한 DConnectionMaker를 일부 수정하더라도 마찬가지다. 또한 DB 연결 방식에 변경이 일어난 경우에 이를 검증하려고 한다면, 변경한 ConnectionMaker 구현 클래스를 직접 테스트해보는 것만으로도 충분하기 떄문이다.

##### 낮은 결합도
책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하다. 느슨한 연결은 관계를 유지하는 데 꼭 필요한 최소한의 방법만 간접적인 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다. 결합도가 낮아지면 변화에 대응하는 속도가 높아지고, 구성이 깔끔해진다. 확장하기에도 매우 편리하다.

결합도란 **하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도** 라고 정의할 수 있다. 낮은 결합도란 결국, 하나의 변경이 발생할 때 여타 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태를 말한다. ConnectionMaker 인터페이스의 도입으로 DB 연결 기능을 구현한 클래스가 바뀌더라도 DAO의 코드는 변경될 필요가 없게 됐다. ConnectionMaker와 UserDao의 결합도가 낮아진 것이다. 결합도가 높아지면 변경에 따르는 작업량이 많아지고, 변경으로 인해 버그가 발생할 가능성이 높아진다.

##### 전략 패턴(Strategy Pattern)
개선한 UserDaoTest-UserDao-ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다. 젼략 패턴은 디자인 패턴의 꽃이라고 불릴 만큼 다양하게 자주 사용된다. 이는 자신의 기능 맥락(Context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다. 여기에서 알고리즘이란 독립적인 책임으로 분리가 가능한 기능을 뜻한다.

UserDao는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.

전략패턴은 UserDaoTest와 같은 클라이언트의 필요성에 대해서도 잘 설명하고 있다. 전략 패턴의 적용 방법을 보면 클라이언트의 역할이 잘 설명되어 있다. 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략(ConnectionMaker를 구현한 클래스, 예로 DConnectionMaker)을 컨텍스트의 생성자 등을 통해 제공해주는 게 일반적이다.

스프링이란 바로 지금까지 설명한 객체지향적 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크다.


## 제어의 역전(**IoC** Inversion of Control)
### 오브젝트 팩토리
지금까지 문제가 많은 DAO를 리팩토링하는 작업을 수행했는데, 그 과정에서 얼렁뚱땅 넘긴게 하나 있다. 바로 UserDaoTest이다.

UserDaoTest는 UserDao가 직접 담당하던 기능, 즉 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 기능을 엉겹결에 떠맡았다. 그런데 원래 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것이다. 따라서 이것도 분리해보자. UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것과, 이 두 개의 오브젝트가 연결돼서 사용될 수 있도록 관계를 맺어주는 기능을 말이다.

#### 팩토리
분리시킬 기능을 담당할 클래스를 만들어보자, 이 클래스는 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데, 이런 일을 하는 오브젝트를 흔히 **팩토리(Factory)** 라고 부른다. 그리고 이 클래스는 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 분리하려는 목적으로 사용하는 것이다.

UserDaoTest에 담겨 있던 UserDao, ConnectionMaker 관련 생성 작업을 DaoFactory로 옮기고, UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 userDao 오브젝트를 가져와 사용하게 만든다.

~~~Java
public class DaoFactory {
  public UserDao userDao() {
    ConnectionMaker connectionMaker = new DConnectionMaker();
    UserDao userDao = new UserDao(connectionMaker);

    return userDao;
  }
}
~~~
DaoFactory의 userDao 메소드를 호출하면 DConnectionMaker를 사용해 DB 커넥션을 가져오도록 이미 설정된 UserDao 오브젝트를 돌려준다. UserDaoTest는 이제 UserDao가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경 쓰지 않고 팩토리로 부터 UserDao 오브젝트를 받아다가, 자신의 관심사인 테스트를 위해 활용하기만 하면 된다.

~~~Java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    UserDao dao = new DaoFactory().userDao();
  }
}
~~~

##### 설계도로서의 팩토리
오브젝트들의 역할과 관계를 분석해보자. UserDao와 ConnectionMaker는 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고, DaoFactory는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고 있음을 알 수 있다. 전자가 실질적인 로직을 담당하는 컴포넌트라면, 후자는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 한다고 볼 수 있다.

이제 N사와 D사에 UserDao를 공급할 때 UserDao, ConnectionMaker와 함께 DaoFactory도 제공하고, UserDao와 달리 DaoFactory는 소스를 제공한다. 새로운 ConnectionMaker 구현 클래스로 변경이 필요하면 DaoFactory를 수정해서 변경된 클래스를 생성해 설정해주도록 코드를 수정해주면 된다.

DaoFactory를 분리했을 때 얻을 수 있는 장점중 하나는 애플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는 데 가장 의미가 있다.

#### 오브젝트 팩토리의 활용
DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능을 넣으면 어떻게 될까? AccountDao, MessageDao 등을 만들었다고 해보자, 이경우 ConnectionMaker 구현 클래스의 오브젝트를 생성하는 코드가 메소드마다 반복되는 문제가 발생한다. 따라서 다음과 같이 메소드로 뽑아내자.

~~~Java
public class DaoFactory {
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  public AccountDao accountDao() {
    return new AccountDao(connectionMaker());
  }

  public MessageDao messageDao() {
    return new MessageDao(connectionMaker());
  }

  public ConnectionMaker connectionMaker() {
    return new DConnectionMaker();
  }
}
~~~

#### 제어권의 이전을 통한 제어관계 역전
제어의 역전이란 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다.

일반적인 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생성하고, 만들어진 오브젝트에 있는 메소드를 호출하고, 그 오브젝트 메소드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업의 반복이다. 이런 구조에서는 각 오브젝트가 프로그램 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한다. 초기 UserDao를 보면 테스트용 main() 메소드는 UserDao 클래스의 오브젝트를 직접 생성하고, 만들어진 오브젝트의 메소드를 사용한다. UserDao 또한 자신이 사용할 ConnectionMaker의 구현 클래스를 자신이 결정하고, 그 오브젝트를 필요한 시점에서 생성해두고, 각 메소드에서 이를 사용한다. 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조다.

반면 제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다. 프로그램의 시작을 담당하는 main()과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다.

프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다. 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.

우리가 만든 UserDao와 DaoFactory에도 제어의 역전이 적용되어 있다. 원래 ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게 있었다. 그러나 지금은 DaoFactory에게 있다. 자신이 어떤 ConnectionMaker 구현 클래스를 만들고 사용할지를 결정할 권한을 DaoFactory에 넘겼으니 UserDao는 이제 능동적이 아니라 수동적인 존재가 됐다. UserDaoTest는 DaoFactory가 만들고 초기화해서 자신에게 사용하도록 공급해주는 ConnectionMaker를 사용할 수 밖에 없다. 더욱이 UserDao와 ConnectionMaker의 구현체를 생성하는 책임도 DaoFactory가 맡고 있다. 이것이 제어의 역전이 일어난 상황이다. 자연스럽게 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만들기 위해 DaoFactory를 도입했던 과정이 바로 IoC를 적용하는 작업이라고 볼 수 있다.

이런 작업을 하다보니 대표적인 IoC 프레임워크라고 불리는 스프링 없이도 IoC 개념을 이미 적용한 셈이다. Ioc는 기본적으로 프레임워크만의 기술도 아니고 프레임워크가 꼭 필요한 개념도 아니다. 단순하게 생각하면 디자인 패턴에서도 발견할 수 있는 것처럼 상당히 폭넓게 사용되는 프로그래밍 모델이다. IoC를 적용함으로써 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아지기 때문에 필요할 때면 IoC 스타일의 설계와 코드를 만들어 사용하면 된다.

제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관계설정, 사용, 생명주기 관리 등을 관장하는 존재가 필요하다. DaoFactory는 오브젝트 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있지만, IoC를 애플리케이션 전반에 걸쳐 본격적으로 적용하려면 스프링과 같은 IoC 프레임워크의 도움을 받는 것이 훨씬 유리하다. 이제부터는 스프링이 제공하는 IoC에 대해 살펴보자.



## 스프링의 IoC
스프링의 핵심을 담당하는 건, 빈 팩토리 또는 애플리케이션 컨텍스트라고 불리는 것이다. 이 두 가지는 DaoFactory가 하는 일을 좀 더 일반화한 것이다.

### 오브젝트 팩토리를 이용한 스프링 IoC
#### 애플리케이션 오브젝트와 설정 정보
DaoFactory를 스프링에서 사용이 가능하도록 변경해보자. 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라고 한다.
스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(bean factory)라고 부른다. 스프링에서는 빈 팩토리보다는 이를 좀 더 확장한 애플리케이션 컨텍스트를 주로 사용한다.

빈 팩토리라고 말할 때는 빈을 생성하고 관계를 설정하는 IoC의 기본 기능에 초점을 맞춘 것이고, 애플리케이션 컨텍스트라고 말할 때는 애플리케이션 전반에 걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC엔진이라는 의미가 좀 더 부각된다.

애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다. 빈 팩토리 또는 애플리케이션 컨텍스트가 사용하는 설정정보를 만드는 방법은 여러가지가 있지만, 앞에서 만든 오브젝트 팩토리인 DaoFactory도 조금만 손을 보면 설정정보로 사용할 수 있다.

앞쪽에서 애플리케이션의 로직을 담고 있는 컴포넌트와 설계도 역할을 하는 팩토리로 구분을 했었는데, 이 설계도라는 것이 애플리케이션 컨텍스트와 그 설정정보를 말한다.

건물이 설계도면을 따라서 만들어지듯이, 애플리케이션도 애플리케이션 컨텍스트와 그 설정정보를 따라서 만들어지고 구성된다고 생각할수 있다.

#### DaoFactory를 사용하는 애플리케이션 컨텍스트
DaoFactory를 설정정보로 만들어보자, 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할수 있도록 @Configuration이라는 애노테이션을 추가한다. 그리고 오브젝트를 만들어주는 메소드에는 @Bean이라는 애노테이션을 붙여준다.

이 두 가지 애노테이션만으로 스프링 프레임워크의 빈 팩토리 또는 애플리케이션 컨텍스트가 IoC 방식의 기능을 제공할때 사용할 설정정보가 된다.

~~~Java
@Configuration
public class DaoFactory {
  @Bean
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  @Bean
  public ConnectionMaker connectionMaker() {
    return new DconnectionMaker();
  }
}
~~~
이제 DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트를 만들어보자. 애플리케이션 컨텍스트는 ApplicationContext 타입의 오브젝트이며, ApplicationContext를 구현한 클래스는 여러가지가 있지만 @Configuration이 붙은 자바코드를 설정정보로 사용하려면 AnnotationConfigApplicationContext를 이용하면 된다.

애플리케이션 컨텍스트를 만들 때 생성자 파라미터로 DaoFactory 클래스를 넣어주면 ApplicationContext의 getBean() 메소드를 이용해 UserDao의 오브젝트를 가져올 수 있다.

~~~Java
public class UserDaoTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao", UserDao.Class);
    ...
  }
}
~~~

getBean()의 파라미터인 "userDao"는 ApplicationContext에 등록된 빈의 이름이며, @Bean이라는 애노테이션을 userDao라는 이름의 메소드에 붙였는데, 이 메소드 이름이 빈의 이름이 된다.

userDao라는 이름의 빈은 가져온다는 것은 DaoFactory의 userDao() 메소드를 호출해서 그 결과를 가져온다고 생각하면 된다.

getBean() 메소드는 기본적으로 Object 타입으로 리턴하기 떄문에 캐스팅을 해줘야 하는 불편함이 있는데 제네릭 메소드 방식을 사용해 getBean()의 두 번째 파라미터에 리턴 타입을 주면, 지저분한 캐스팅을 사용하지 않아도 된다.

### 애플리케이션 컨텍스트의 동작방식
오브젝트 팩토리 방식과 스프링의 애플리케이션 컨텍스트를 비교해보자, 오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트다. 스프링에서는 애플리케이션 컨텍스트를 IoC 컨테이너라 하기도 하고, 스프링 컨테이너라 부르기도한다. 또는 빈 팩토리라고도 부른다.

DaoFactory가 UserDao를 비롯한 DAO 오브젝트를 생성하고 DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 하는 데 반해, 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 대신 애플리케이션 컨텍스트에는 DaoFactory와 달리 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고, 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻는다.

@Configuration이 붙은 DaoFactory는 이 애플리케이션 컨텍스트가 활용하는 IoC설정정보다. 애플리케이션 컨텍스트는 DaoFactory 클래스 설정정보를 등록해두고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어둔다. 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾아보고, 있다면 빈을 생성하는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

DaoFactory를 오브젝트 팩토리로 직접 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용 했을때 얻을 수 있는 장점은 다음과 같다.

##### 1.클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
애플리케이션이 발전하면서 DaoFactory 처럼 IoC를 적용한 오브젝트도 계속 추가될 것이다. 클라이언트가 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 사용해야할지 알아야하고, 필요할 때마다 팩토리 오브젝트를 생성하는 번거로움이 있지만 애플리케이션 컨텍스트를 사용하면 그럴 필요가 없어진다.

##### 2.애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
애플리케이션 컨텍스트의 역할은 단진 오브젝트 생성과 다른 오브젝트와의 관계설정이 전부가 아니다. 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 다양한 기능을 제공한다.

##### 3.애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
애플리케이션 컨텍스트의 getBean() 메소드는 빈의 이름을 이용해 빈을 찾아주기도 하며, 타입만으로 빈을 검색하거나 특별한 애노테이션 설정이 되어 있는 빈을 찾을 수도 있다.

### 스프링 IoC의 용어정리
#### 빈(bean)
스프링이 IoC 방식으로 관리하는 오브젝트, 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 한다.

#### 빈 팩토리(bean factory)
스프링의 IoC를 담당하는 핵심 컨테이너. 빈을 등록, 생성, 조회, 반환 등 빈을 관리하는 기능을 담당한다. 보통은 이를 확장한 애플리케이션 컨텍스트를 이용한다.

#### 애플리케이션 컨텍스트(application context)
빈 팩토리를 확장한 IoC 컨테이너다. 기본적인 기능은 빈 팩토리와 동일하다. 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기 할때 애플리케이션 컨텍스트라고 표현한다.

#### 설정정보 / 설정 메타정보(configuration metadata)
애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. 구성정보 내지 형상정보라는 의미의 configuration이라고 표현한다. 스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만, 그보다는 IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.

#### 컨테이너 또는 IoC 컨테이너
IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고 한다. 후자는 빈 팩토리의 관점에서 이야기하는 것이고, 그냥 컨테이너 또는 스프링 컨테이너라고 할 때는 애플리케이션 컨텍스트를 가리키는 것이라고 보면 된다.

#### 스프링 프레임워크
IoC 컨테이너, 애플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할 때 주로 사용한다.


## 싱글톤 레지스트리와 오브젝트 스코프
DaoFactory를 사용하는 것과 @Configuration 애노테이션을 추가해서 애플리케이션 컨텍스트를 통해 사용하는 것에는 중요한 차이점이 있다.

##### 오브젝트의 동일성과 동등성
> 자바에서는 두 개의 오브젝트가 완전히 같은 동일한(identical) 오브젝트라고 말하는 것과, 동일한(equivalent) 정보를 담고 있는 오브젝트라고 말하는 것에 차이가 있다. 전자는 동일성(identity) 비교라 하고 후자는 동등성(equality) 비교하고 한다. 동일성은 == 연산자로, 동등성은 equals() 메소드를 이용해 비교한다.
> 두 개의 오브젝트가 동일하다면 하나의 오브젝트만 존재하는 것이고 두 개의 오브젝트 레퍼런스 변수를 갖고 있을 뿐이다.

~~~Java
DaoFactory factory = new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System.out.println(dao1);
System.out.println(dao2);

// UserDao@118f375
// UserDao@117a8bd
~~~

두 개는 각기 다른 값을 가진 동일하지 않은 오브젝트다. 이번에는 애플리케이션 컨텍스트의 getBean() 메소드를 이용해 userDao라는 이름으로 등록된 오브젝트를 가져와 보자

~~~Java
ApplicationContext context = new ApplicationConfigApplicationContext(DaoFactory.class);

UserDao dao3 = context.getBean("userDao", UserDao.class);
UserDao dao4 = context.getBean("userDao", UserDao.class);

System.out.println(dao3);
System.out.println(dao4);
System.out.println(dao3 == dao4);
// UserDao@ee22f7
// UserDao@ee22f7
// true
~~~

getBean()을 두 번 호출해서 가져온 오브젝트가 동일하다는 사실을 알 수 있다. 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다.

### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
애플리케이션 컨텍스트는 IoC 컨테이너면서, 동시에 싱글톤을 저장하고 관리하는 싱글톤 레지스트리(singleton registry)이기도 하다. **스프링은 기본적으로 빈 오브젝트를 모두 싱글톤으로 만든다.**

#### 서버 애플리케이션과 싱글톤
스프링이 싱글톤으로 빈을 만드는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다. 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 생각해보자. 요청 한 번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어온다고 하면 한시간이면 9백만 개의 새로운 오브젝트가 만들어진다. 자바의 오브젝트 생성과 가비지 컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.

서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

#### 싱글톤 패턴의 한계
자바에서 싱글톤을 구현하는 방법은 보통 아래와 같다
1. 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private로 만든다.
2. 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
3. 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 미리 만들어둘 수도 있다.
4. 한번 오브젝트가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.

~~~Java
public class UserDao {
  private static UserDao INSTANCE;

  private UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }

  public static synchronized UserDao getInstance() {
    if(INSTANCE == null) INSTANCE = new UserDao(???);
    return INSTANCE;
  }
}
~~~

 깔끔하게 정리했던 UserDao에 싱글톤을 위한 코드가 추가되고 나니 코드가 지저분해졌다. 게다가 private으로 바뀐 생성자는 외부에서 호출할 수가 없기 때문에 DaoFactory에서 UserDao를 생성하며 ConnectionMaker 오브젝트를 넣어주는 게 이제는 불가능해졌다.

 ##### private 생성자를 갖고 있기 때문에 상속할 수 없다.
 싱글톤 패턴은 생성자를 private으로 제한한다. 따라서 상속이 불가능 하며, 객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다.

 ##### 싱글톤은 테스트하기가 힘들다.
 싱글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다.

 ##### 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다.

 ##### 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
 싱글톤의 스태틱 메소드를 이용해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용할 수 있으며 자연스럽게 전역 상태로 사용되기 쉽다. 전역 상태를 갖는 것은 객체지향 프로그래밍에서는 권장되지 않는 프로그래밍 모델이다.


 #### 싱글톤 레지스트리
 스프링은 싱글톤을 지지하지만, 이러한 문제들 때문에 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 **싱글톤 레지스트리** 이다. 스프링 컨테이너는 싱글톤을 생성하고 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다.

 싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다. public 생성자를 가질 수 있게 되면서, 테스트 환경에서 자유롭게 오브젝트를 만들 수 있고, 테스트를 위한 목 오브젝트로 대체하는 것도 간단하다.

 가장 중요한 것은 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴등을 적용하는 데 아무런 제약이 없다는 점이다.

### 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 그렇기 때문에 상태 관리에 주의를 기울여야 한다. 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야한다.

스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험하다. 저장할 공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때문이다. 물론 읽기전용의 값이라면 초기화 시점에서 인스턴스 변수에 저장해두고 공유하는 것은 아무 문제가 없다.

상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나, DB나 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야 할까? 파라미터와 로컬 변수, 리턴 값 등을 이용하면 된다. 메소드 파라미터나, 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.

~~~Java
public class UserDao {
  private ConnectionMaker connectionMaker; //읽기전용 인스턴스 변수
  private Connection c; //매번 새로운 값으로 바뀌는 정보를 담은 인스턴스 변수
  private User user; //심각한 문제가 발생한다.

  public User get(String id) throws ClassNotFoundException, SQLException {
    this.c = connectionMaker.makeConnection();
    ...
    this.user = new User();
    this.user.setId(rs.getString("id"));
    ...
    return this.user;
  }
}
~~~

기존의 UserDao에서도 인스턴스 변수로 정의해서 사용하던 것이 있는데, 바로 ConnectionMaker 인터페이스 타입의 connectionMaker다. 이것은 인스턴스 변수를 사용해도 상관이 없는데, 그 이유는 connectionMaker는 읽기전용의 정보이기 때문이다.

### 스프링 빈의 스코프
빈이 생성되고, 존재하고, 적용되는 범위에 대해서 알아보자. 스프링에서는 이것을 빈의 스코프(scope)라고 한다. **싱글톤** 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. **프로토타입** 은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다. **요청** 스코프는 웹을 통해 새로운 HTTP 요청이 생길때마다 생성되며, **세션** 스코프는 웹의 세션과 유사하다.

## 의존관계 주입(DI)
이번에는 IoC에 대해 깊이 알아보자.

### 제어의 역전(IoC)과 의존관계 주입
IoC라는 용어는 매우 느슨하게 정의돼서 폭넓게 사용되는 용어이기 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.

그래서 새로운 용어를 만드는데, 의존관계 주입(dependency injection)이다. 스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다.

##### 의존관계 주입
> DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이기 때문에 의존관계 주입이라는 번역이 제일 적절하다.

### 런타임 의존관계 설정
#### 의존관계
의존관계란 무엇일까? 두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 즉 누가 누구에게 의존하는 관계에 있다는 식이어야 한다. UML 모델에서는 두 클래스의 의존관계를 다음과 같이 점선으로 된 화살표로 표현한다.

~~~
+-----+     +-----+
|  A  |     |  B  |
+-----+---->+-----+
|     |     |     |
+-----+     +-----+
~~~

의존하고 있다는 건 무슨 의미일까? 의존한다는 건 의존대상, 여기서는 B가 변하면 그것이 A에 영향을 미친다는 뜻이다. B의 기능이 추가되거나 변경되거나, 형식이 바뀌거나 하면 그 영향이 A로 전달된다는 것이다. 예를 들어 A에서 B에 정의된 메소드를 호출해서 사용하는 경우다. 이럴 땐 '사용에 대한 의존관계'가 있다고 말할 수 있다. 만약 B에 새로운 메소드가 추가되거나 기존 메소드의 형식이 바뀌면 A도 그에 따라 수정되거나 추가돼야 할 것이다. 또는 B의 형식은 그대로지만 기능이 내부적으로 변경되면, 결과적으로 A의 기능이 수행되는 데도 영향을 미칠 수 있다. 이렇게 사용의 관계에 있는 경우에 A와 B는 의존관계가 있다고 말할 수 있다.

#### UserDao의 의존관계
지금까지 작업해왔던 UserDao의 예를 보자. 아래와 같이 UserDao가 ConnectionMaker에 의존하고 있는 형태다.
~~~
+-------+     +------------------+
|UserDao| use |(I)ConnectionMaker|
+-------+---->+------------------+
|       |     |                  |
+-------+     +------------------+
                        Δ
                        |implement
               +----------------+
               |DConnectionMaker|
               +----------------+
               |                |
               +----------------+
~~~
ConnectionMaker 인터페이스만 의존하고 있기 때문에 ConnectionMaker 인터페이스가 변한다면 그 영향을 userDao가 직접적으로 받게 된다. 하지만 ConnectionMaker 입터페이스를 구현한 DConnectionMaker 클래스가 다른 것으로 바뀌거나 그 내부에서 사용하는 메소드에 변화가 생겨도 UserDao에 영향을 주지 않는다.

이렇게 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다. 결합도가 낮다고 설명할 수 있다.

의존관계란 한쪽의 변화가 다른 쪽에 영향을 주는 것이라고 했으니, 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워지는 셈이다.

UserDao 클래스는 ConnectionMaker 인터페이스에게만 직접 의존한다. UserDao는 DConnectionMaker라는 클래스의 존재도 알지 못한다. 모델의 관점에서 보자면 UserDao는 DConnectionMaker 클래스에는 의존하지 않기 때문이다.

UML에서 말하는 의존관계란 이렇게 설계 모델의 관점에서 이야기하는 것이다. 그런데 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계말고, 런타임 시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 런타임 의존관계 또는 오브젝트 의존관계인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 다르다.

프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상. 실제 사용대상인 오브젝트를 의존 오브젝트(dependent object)라고 말한다. 의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다.

정리하면 의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업을 말한다.
- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서 인터페이스에만 의존해야한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 래퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

의존관계 주입의 핵심은 **설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것** 이다.

#### UserDao의 의존관계 주입
UserDao에 적용된 의존관계 주입 기술을 살펴보자. 인터페이스를 사이에 두고 UserDao와 ConnectionMaker 구현 클래스 간에 의존관계를 느슨하게 만들긴 했지만, 마지막으로 남은 문제가 있었는데 그것은 UserDao가 사용할 구체적인 클래스를 알고 있어야 한다는 점이었다. 관계설정의 책임을 분리하기 전에 UserDao 클래스의 생성자는 아래와 같다.

~~~Java
public UserDao() {
  connectionMaker = new DConnectionMaker();
}
~~~

위 코드에 따르면 UserDao는 이미 설계 시점에서 DConnectionMaker라는 구체적인 클래스의 존재를 알고있다. 따라서 모델링 때의 의존관계, 즉 ConnectionMaker 인터페이스의 관계뿐 아니라 런타임 의존관계, 즉 DConnectionMaker 오브젝트를 사용해야겠다는 것까지 UserDao가 결정하고 관리하고 있는 셈이다.

이 코드의 문제는 이미 런타임 시의 의존관계가 코드 속에 다 미리 결정되어 있다는 점이다. 그래서 IoC 방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제3의 존재에 런탕미 의존관계 결정 권한을 위임한다. 그래서 만들어진 것이 DaoFactory다.

DaoFactory는 여기서 두 오브젝트 사이의 런타임 의존관계를 설정해주는 의존관계 주입 작업을 주도하는 존재이며, 동시에 IoC방식으로 오브젝트의 생성과 초기화, 제공 등의 작업을 수행하는 컨테이너다. 그래서 의존관계 주입을 담당하는 컨테이너라고 볼 수 있고, 줄여서 DI 컨테이너라고 불러도 된다.

DI 컨테이너는 UserDao를 만드는 시점에서 생성자의 파라미터로 이미 만들어진 DConnectionMaker의 오브젝트를 전달한다. 정확히는 DConnectionMaker 오브젝트의 레퍼런스가 전달되는 것이다.

DI컨테이너는 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이 생성자의 파라미터로 오브젝트의 레퍼런스를 전달해준다.

~~~Java
public class UserDao {
  private ConnectionMaker connectionMaker;

  public UserDao(ConnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }
  ...
}
~~~

이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계가 만들어졌다. 이렇게 DI 컨테이너에 의해 렁타임 시에 의존 오브젝트를 사용할 수 있도록 그 레퍼런스를 전달받는 과정이 마치 메소드(생성자)를 통해 DI 컨테이너가 UserDao에게 주입해 주는 것과 같다고 해서 이를 **의존관계 주입** 이라고 부른다.

DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다. 스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있어서 스프링을 DI 컨테이너라고도 부른다.


### 의존관계 검색과 주입
스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다. 의존 관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하기 때문에 **의존관계 검색(dependency lookup)** 이라고 불리는 것도 있다.

의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지 결정하지는 않는다. 그러면 IoC 라고 할 수는 없을 것이다. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 IoC로 맡기지만, 이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.

~~~Java
public UserDao() {
  DaoFactory daoFactory = new DaoFactory();
  this.connectionMaker = daoFactory.connectionMaker();
}
~~~

이렇게 해도 UserDao는 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할지 미리 알지 못한다. 여전히 코드의 의존대상은 ConnectionMaker 인터페이스뿐이다. 런타임 시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다. 따라서 IoC 개념을 잘 따르고 있으며, 그 혜택을 받고 있는 코드다. 하지만 적용 방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는 것이다.
DaoFactory의 경우라면 미리 준비된 메소드를 호출하면 되니까 단순히 요청으로 보이겠지만, 이런 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 따라서 이를 일종의 검색이라고 볼 수 있다. 또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.

스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean()이라는 메소드를 제공한다. 바로 이 메소드가 의존관계 검색에 사용되는 것이다. UserDao는 아래와 같이 애플리케이션 컨텍스트를 사용해서 의존관계 검색 방식으로 ConnectinoMaker 오브젝트를 가져오게 만들 수도 있다.

~~~Java
public UserDao() {
  AnnotationConfigApplicationContext context =
    new AnnotationConfigApplicationContext(DaoFactory.class);

    this.connectionMaker = context.getBean("connectionMaker", ConnectionMaker.class);
}
~~~

의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 가지고 있다. IoC 원칙에도 장 들어맞는다.

그렇다면 의존관계 검색과 의존관계 주입 방법 중 어떤 것이 더 나을까? 코드를 봐도 느낄 수 있지만 의존관계 주입 쪽이 훨씬 단순하고 깔끔하다. 그런데 의존관계 검색 방식을 사용해야 할 때가 있다. UserDaoTest를 보자. 테스트 코드에서는 이미 의존관계 검색 방식인 getBean()을 사용했다.

이처럼 스프링의 IoC와 DI 컨테이너를 적용했다고 하더라도 애플리케이션의 기동시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. 스태틱 메소드인 main()에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다.

서버에서도 마찬가지다 main()과 같은 기동 메소드는 없지만, 사용자의 요청을 받을 때마다 main() 메소드와 비슷한 역할을 하는 서블릿에서 스프링 컨테이너에 담긴 오브젝트를 사용하려면 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야한다. 물론 이런 서블릿은 스프링이 미리 만들어서 제공하기 때문에 직접 구현할 필요는 없다.

또한 의존관계 검색과 의존관계 주입을 적용할 때 차이점이 있는데, 의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다는 점이다. UserDao에 스프링의 getBean()을 사용한 의존관계 검색 방법을 적용했다고 해보자. 이 경우 UserDao는 굳이 스프링이 만들고 관리하는 빈일 필요가 없다. 어딘가에서 직접 new UserDao() 해서 만들어서 사용해도 된다.

반변에 의존관계 주입에서는 UserDao와 ConnectionMaker 사이에 DI가 적용되려면 UserDao도 반드시 컨테이너가 만드는 빈 오브젝트여야 한다. 컨테이너가 UserDao에 ConnectionMaker 오브젝트를 주입해주려면 UserDao에 대한 생성과 초기화 권한을 갖고 있어야 하고, 그러려면 UserDao는 IoC 방식으로 컨테이너에서 생성되는 오브젝트, 즉 빈이어야 하기 때문이다.

DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다.

### 의존관계 주입의 응용
런타임 시에 사용 의존관계를 맺을 오브젝트를 주입해준다는 DI 기술의 장점은 무엇일까?

코드에는 런타임 클래스에 대한 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만들므로, 다른 책임을 가진 사용 의존관계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며, 변경을 통한 다양한 확장방법에는 자유롭다.

UserDao가 ConnectionMaker라는 인터페이스에만 의존하고 있다는 건, ConnectionMaker를 구현하기만 하고 있다면 어떤 오브젝트든지 사용할 수 있다는 것이다. 응용 사례를 보자.

#### 기능 구현의 교환
데이터베이스는 매우 중요한 자원이다. 평상시에도 항상 부하를 많이 받고 있어서 개발 중에는 절대 사용하지 말아야 한다. 대신 개발 중에는 개발자 PC에 설치한 로커 DB나 개발용 DB를 사용해야한다. 그리고 개발이 진행되다가 어느 시점이 되면 지금까지 개발한 것을 그대로 운영서버로 배치해서 사용할 것이다. 그런데 만약 DI방식을 적용하지 않았다고 해보자. 개발 중에는 로컬 DB를 사용하도록 해야하니 로컬 DB에 대한 연결 기능이 있는 LocalDBConnectionMaker라는 클래스를 만들고, 모든 DAO에서 이 클래스의 오브젝트를 매번 생성해서 사용하게 했을 것이다.

이를 서버에 배치하는 시점에 운영서버에서 DB에서 연결할 때 필요한 ProductionDBConnectionMaker라는 클래스로 변경해줘야 한다. DAO가 100개라면 최소한 100군데의 코드를 수정해야 한다. 하나라도 빠지거나 잘못 고치면 서버에서 오류가 발생할 것이다. 그러다 다시 개발을 진행하려면 다시 DAO코드를 LocalDBConnectionMaker를 사용하도록 수정해야 한다.

반면에 DI 방식을 적용해서 만들었다고 해보자. 모든 DAO는 생성 시점에 ConnectionMaker 타입의 오브젝트를 컨테이너로부터 제공받는다. 구체적인 사용 클래스 이름은 컨테이너가 사용할 설정정보에 들어 있다. @Configuration이 붙은 DaoFactory를 사용한다고 하면 개발자 PC에서는 DaoFactory의 코드를 아래와 같이 만들어서 사용하면 된다.

~~~Java
@Bean
public ConnectionMaker connectionMaker() {
  return new LocalDBConnectionMaker();
}
~~~

이를 서버에 배포할 때는 어떤 DAO클래스와 코드도 수정할 필요가 없다. 단지 서버에서 사용할 DaoFactory를 아래와 같이 수정해주기만 하면된다. DAO가 얼마나 많던 딱 한줄이면 된다.

~~~Java
@Bean
public ConnectionMaker connectionMaker() {
  return new ProductionDBConnectionMaker();
}
~~~

개발환경과 운영환경에서 DI의 설정정보에 해당하는 DaoFactory만 다르게 만들어 두면 나머지 코드에는 전혀 손대지 않고 개발 시와 운영 시에 각각 다른 런타임 오브젝트에 의존관계를 갖게 해줘서 문제를 해결할 수 있다.

#### 부가기능 추가
DAO가 ㅁDB를 얼마나 많이 연결해서 사용하는지 파악하고 싶다고 해보자. DB 연결횟수를 카운팅하기 위해 무식한 방법으로, 모든 DAO의 makeConnection() 메소드를 호출하는 부분에 새로 추가한 카운터를 증하시키는 코드를 넣어야 할까? 그리고 분석 작업이 끝나면 모두 제거하고? 이런 방법은 엄청난 낭비이고 노가다다. 게다가 DAO코드를 수정한다는 건 지금까지 그렇게 피하려고 했던 일이 아닌가? DB 연결횟수를 세는 일은 DAO의 관심사항이 아니다. 분리해야한다.

DI컨테이너에서라면 아주 간단한 방법으로 간으하다. DAO와 DB 커넥션을 만드는 오브젝트 사이에 연결횟수를 카운팅하는 오브젝트를 하나 더 추가하는 것이다. 새로운 기능을 호출 과정에 추가하려고 한다면 분명 그 앞뒤의 코드를 같이 수정해야 하는 것이 아닐까? 꼭 그럴 필요는 없다. DI의 개념을 응용하는 것으로 충분하다. DI를 이용한다고 했으니 기존 코드는 수정하지 않아도 된다. 그리고 컨테이너가 사용하는 설정정만 수정해서 런타임 의존관계만 새롭게 정의해주면 된다.

~~~Java
public class CountingConnectionMaker implements ConnectionMaker {
  int counter = 0;
  private ConnectionMaker realConnectionMaker;

  public CountingConnectionMaker(ConnectionMaker realConnectionMaker) {
    this.realConnectionMaker = realConnectionMaker;
  }

  public Connection makeConnection() throws ClassNotFoundException, SQLException {
    this.counter++;
    return realConnectionMaker.makeConnection();
  }

  public int getCounter() {
    return this.counter;
  }
}
~~~

CountingConnectionMaker 클래스는 ConnectionMaker 인터페이스를 구현했지만 내부에서 직접 DB 커넥션을 만들지 않는다. 대신 DAO가 DB 커넥션을 가져올 때마다 호출하는 makeConnection()에서 DB 연결횟수 카운터를 증가시킨다.

CountingConnectionMaker는 자신의 관심인 DB 연결횟수 카운팅 작업을 마치면 실제 DB 커넥션을 만들어주는 realConnectionMaker에 저장된 ConnectionMaker 타입의 오브젝트의 makeConnection()을 호출해서 그 결과를 DAO에게 돌려준다.

생성자를 보면 CountingConnectionMaker도 DI를 받는 것을 알 수 있다. CountingConnectionMaker가 추가되면서 런타임 의존관계가 어떻게 바뀌는지 살펴보자.


~~~
+---------+        +------------------+
|:UserDao |―――――――>|:DConnectionMaker |
|￣￣￣￣￣|        |￣￣￣￣￣￣￣￣￣￣|
+---------+        +------------------+
~~~
CountingConnectionMaker를 사용하기 전의 런타임 의존관계다. UserDao 오브젝트는 ConnectionMaker 타입의 DConnectionMaker 오브젝트에 의존한다.

UserDao는 ConnectionMaker의 인터페이스에만 의존하고 있기 때문에, ConnectionMaker 인터페이스를 구현하고 있다면 어떤것이든 DI가 가능하다. 그래서 UserDao 오븢게트가 DI 받는 대상의 설정을 조정해서 DConnection 오브젝트 대신 CountingConnectionMaker 오브젝트로 바꿔치기하는 것이다. 이렇게 해두면 UserDao가 DB커넥션을 가져오라고 할 때마다 CountingConnectionMaker의 makeConnection() 메소드가 실행되고 카운터는 하나씩 증가할 것이다.

그렇다고 해서 DB 커넥션을 제공해주지 않으면 DAO가 동작하지 않을 테니 CountingConnectionMaker가 다시 실제 사용할 DB 커넥션을 제공해주는 DConnectionMaker를 호출하도록 만들어야한다. DI를 사용해서 말이다.

~~~
+---------+        +-------------------------+         +------------------+
|:UserDao |―――――――>|:CountingConnectionMaker |―――――――> |:DConnectionMaker |
|￣￣￣￣￣|        |￣￣￣￣￣￣￣￣￣￣￣￣￣￣|        |￣￣￣￣￣￣￣￣￣￣|
+---------+        +-------------------------+         +------------------+
~~~

새로운 의존관계를 컨테이너가 사용할 설정정보를 이용해 만들어보자. CountingDaoFactory라는 이름의 설정용 클래스를 만든다. 기존 DaoFactory와 달리, connectionMaker() 메소드에서 CountingConnectionMaker 타입 오브젝트를 생성하도록 만든다. 그리고 실제 DB 커넥션을 만들어주는 DConnectionMaker는 이름이 realConnectionMaker()인 메소드에서 생성하게 한다. 그리고 realConnectionMaker()메소드가 만들어주는 오브젝트는 connectionMaker()에서 만드는 오브젝트의 생성자를 통해 DI 해준다.

~~~Java
@Configuration
public class CountingDaoFactory {
  @Bean
  public UserDao userDao() {
    return new UserDao(connectionMaker());
  }

  @Bean
  public ConnectionMaker connectionMaker() {
    return new CountingConnectionMaker(realConnectionMaker());
  }

  @Bean
  public ConnectionMaker realConnectionMaker() {
    return new DConnectionMaker();
  }
}
~~~

이제 커넥션 카운팅을 위한 실행 코드를 만든다. 기본적으로는 UserDaoTest와 같지만 설정용 클래스를 CountingDaoFactory로 변경해줘야 한다. DAO를 DL 방식으로 가져와 어떤 작업이든 여러 번 실행시킨다. 그리고 CountingConnectionMaker빈을 가져와서 그동안 DAO를 통해 DB 커넥션을 요청한 횟수를 담아두는 값을 가져와 출력해보자.

~~~Java
public class UserDaoConnectionCountingTest {
  public static void main(String[] args) throws ClassNotFoundException, SQLException {
    AnnotationConfigApplicationContext context =
      new AnnotationConfigApplicationContext(CountingDaoFactory.class);
      UserDao dao = context.getBean("userDao", UserDao.class);

      // DAO 사용코드

      CountingConnectionMaker ccm = context.getBean("connectionMaker", CountingConnectionMaker.class);

      System.out.println("Connection counter : " + ccm.getCounter());
  }
}
~~~

이렇게 해두면 DAO가 몇개나 존재하던지 상관없다. DI의 장점은 관심사의 분리를 통해 얻어지는 높은 응집도에서 나온다. 모든 DAO가 직접 의존해서 사용할 ConnectionMaker 타입 오브젝트는 connectionMaker() 메소드에서 만든다. 따라서 CountingConnectionMaker의 의존관계를 추가하려면 이 메소드만 수정하면 그만이다. 또한 CountingConnectionMaker를 이용한 분석 잡업이 모두 끝나면, 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하거나 connectionMaker() 메소드를 수정하는 것만으로 DAO의 런타임 의존관계는 이전 상태로 복구된다.

이런 것이 의존관계 주입의 매력을 잘 드러내는 응용 방법이다. DI의 활용방법은 매우 다양하다. 스프링이 제공하는 대부분의 기능은 DI 없이는 존재할 수 없는 것이다. 따라서 스프링을 공부하는 건 DI를 어떻게 활용해야 할지를 공부하는 것이기도 하다.


### 메소드를 이용한 의존관계 주입
지금까지는 UserDao의 의존관계 주입을 위해 생성자를 사용했다. 생성자에 파라미터를 만들어두고 이를 통해 DI 컨테이너가 의존할 오브젝트 레퍼런스를 넘겨주도록 만들었다. 그런데 생성자가 아닌 일반 메소드를 사용할 수도 있을 뿐만 아니라, 생성자를 사용하는 방법보다 더 자주 사용된다.

##### 수정자 메소드를 이용한 주입
수정자 메소드(setter method)는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용된다. 수정자 메소드의 핵심기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것이다. 부가적으로, 입력값에 대한 검증이나 그 밖의 작업을 수행할수도 있다. 수정자 메소드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 내부의 메소드에서 사용하게 하는 DI 방식에서 활용하기에 적당하다.

##### 일반 메소드를 이용한 주입
수정자 메소드처럼 set으로 시작해야 하고 한 번에 한 개의 파라미터만 가질 수 있다는 제약이 싫다면 여러 개의 파라미터를 갖는 일반 메소드를 DI용으로 사용할 수도 있다. 생성자가 수정자 메소드보다 나은 점은 한 번에 여러 개의 파라미터를 받을 수 있다는 점이다. 하지만 파라미터의 개수가 많아지고 비슷한 타입이 여러 개라면 실수하기 쉽다. 임의의 초기화 메소드를 이용하는 DI는 적절한 개수의 파라미터를 가진 여러 개의 초기화 메소드를 만들 수도 있기 때문에 한 번에 모든 필요한 파라미터를 다 받아야 하는 생성자보다 낫다.

스프링은 전통적으로 메소드를 이용한 DI 방법 중에서 수정자 메소드를 가장 많이 사용해왔다. XML을 사용하는 경우에는 자바빈 규약을 따르는 수정자 메소드가 가장 사용하기 편리하다.

UserDao도 수정자 메소드를 이용해 DI 하도록 만들어보자. 기존 생성자는 제거한다. 생성자를 대신할 setConnectionMaker()라는 메소드를 하나 추가하고 파라미터로 ConnectionMaker 타입의 오브젝트를 받도록 선언한다.

~~~Java
public class UserDao {
  private ConnectionMaker connectionMaker;

  public void setConnectionMaker(ConnnectionMaker connectionMaker) {
    this.connectionMaker = connectionMaker;
  }
}
~~~

UserDao를 수정자 메소드 DI 방식이 가능하도록 변경했으니 DI를 적용하는 DaoFactory의 코드도 함께 수정해줘야 한다.

~~~Java
@Bean
public UserDao userDao() {
  UserDao userDao = new UserDao();
  userDao.setConnectionMaker(connectionMaker());
  return userDao;
}
~~~

단지 의존관계를 주입하는 시점과 방법이 달라졌을 뿐 결과는 동일하다. 스프링은 생성자, 수정자 메소드, 초기화 메소드를 이용한 방법 외에도 다양한 의존관계 주입 방법을 지원한다.

## XML을 이용한 설정
XML은 단순한 텍스트 파일이기 때문에 다루기 쉽다. 쉽게 이해할 수 있으며 컴파일과 같은 별도의 빌드 작업이 없다는 것도 장점이다. 환경이 달라져서 오브젝트의 관계가 바뀌는 경우도 빠르게 변경사항을 반영할 수 있다.

### XML설정
DaoFactory 자바 코드에 담겨 있던, DI를 위한 오브젝트 의존관계 정보를 XML을 이용해 만들어보자.

DI가 담긴 XML 파일은 <beans>를 루트 엘리먼트로 사용한다.  <beans>안에는 여러 개의 <bean>을 정의할 수 있다. XML 설정은 @Configuration과 @Bean이 붙은 자바 클래스로 만든 설정과 내용이 동일하다. @Configuration을 <beans> @Bean을 <bean>에 대응하면 된다.

@Bean 메소드를 통해 얻을 수 있는 빈의 DI정보는 다음과 같다
- 빈의 이름 : @Bean 메소드 이름이 빈의 이름이다. 이 이름은 getBean()에서 사용된다.
- 빈의 클래스 : 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다.
- 빈의 의존 오브젝트 : 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다. 의존 오브젝트도 하나의 빈이므로 이름이 있을 것이고, 그 이름에 해당하는 메소드를 호출해서 의존 오브젝트를 가져온다.

#### connectionMaker() 전환
DaoFactory의 connectionMkaer() 메소드에 해당하는 빈을 XML로 정의해보자
~~~
@Configuration -> <beans>
@Bean methodName() -> <bean id="methodName">
return new BeanClass(); -> calss="a.b.c... BeanClass">
~~~
단, <bean> 태그의 class 애트리뷰트에 지정하는 것은 자바 메소드에서 오브젝트를 만들 때 사용하는 클래스 이름이라는 점에 주의하자. 메소드의 리턴 타입을 class 애트리뷰트에 사용하지 않도록 하자. XML에서는 리턴하는 타입을 지정하지 않아도 된다.

이제 변경해 보자
~~~Java
@Bean -------------------------------------> <bean
public ConnectionMaker connectionMaker() {-> id="connectionMaker"
  return new DConnectionMaker();-----------> class="spring...DConnectionMaker"/>
}
~~~

#### userDao() 전환
userDao에서 관심을 가지져야 할 것은 수정자 메소드를 사용해 의존관계를 주입해주는 부분이다. 스프링 개발자가 수정자 메소드를 선호하는 이유 중에는 XML로 의존관계 정보를 마들 때 편리하다는 점도 있다. 자바빈의 관례를 따라서 수정자 메소드는 프로퍼티가 된다. 프로퍼티 이름은 메소드 이름에서 set을 제외한 나머지 부분을 사용한다.

XML에서는 <property> 태그를 사용해 의존 오브젝트와의 관계를 정의한다. <property> 태그는 name과 ref라는 두 개의 애트리뷰트를 갖는다 name은 프로퍼티의 이름이다. 이 프로퍼티 이름으로 수정자 메소드를 알 수 있따. ref는 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름이다.

~~~Java
userDao.setConnectionMaker(connectionMaker());
   set          ConnectionMaker       connectionMaker()
<property name="connectionMaker" ref="connectionMaker"/>
~~~

~~~XML
<bean id="userDao" class="springbook.dao.UserDao">
  <property name="connectionMaker" />
</bean>
~~~

#### XML의 의존관계 주입 정보
두 개의 <bean> 태그를 이용해 @Bean 메소드를 모두 XML로 변환했다. <property> 태그의 name과 ref는 그 의미가 다르므로 이름이 같더라도 어떤 차이가 있는지 구별할 수 있어야 한다. name 애트리뷰트는 DI에 사용할 수정자 메소드의 프로퍼티 이름이며, ref 애트리뷰트는 주입할 오브젝트를 정의한 빈의 ID다.

~~~XML
<beans>
  <bean id="myConnectionMaker" class="springbook.user.dao.DConnectionMaker" />

  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="connectionMaker" ref="myConnectionMaker" />
  </bean>
</beans>
~~~

때로는 같은 인터페이스르 구현한 의존 오브젝트를 여러 개 정의해두고 그중에서 원하는 걸 골라서 DI 하는 경우도 있다.

~~~XML
<beans>
  <bean id="localDBConnectionMaker" class="...LocalDBConnectionMaker" />
  <bean id="testDBConnectionMaker" class="...TestDBConnectionMaker" />
  <bean id="productionDBConnectionMaker" class="...ProductionDBConnectionMaker" />

  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="connectionMaker" ref="localDBConnectionMaker" />
  </bean>
</beans>
~~~

### XML을 이용하는 애플리케이션 컨텍스트
XML에서 빈의 의존관계 정보를 이용하는 IoC/DI 작업에는 GenericXmlApplicationContext를 사용한다. GenericXmlApplicationContext의 생성자 파라미터로 XML 파일의 클래스패스를 지정해주면 된다.

애플리케이션 컨텍스트가 사용하는 XML 설정파일의 이름은 관례를 따라 applicationContext.xml 로 만든다.

~~~XML
<beans>
  <bean id="connectionMaker" class="springbook.user.dao.DConnectionMaker" />
  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="connectionMaker" ref="connectionMaker" />
  </bean>
</beans>
~~~

다음은 UserDaoTest의 애플리케이션 컨텍스트 생성 부분을 수정한다. DaoFactory를 설정정보로 사용했을 때 썼던 AnnotationConfigApplicationContext 대신 GenericXmlApplicationContext를 이용해 다음과 같이 애플리케이션 컨텍스트를 생성하게 만든다.

~~~Java
ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
~~~

UserDaoTest를 실행해도 동일한 결과가 나온다.

GenericXmlApplicationContext 외에도 ClassPathXmlApplicationContext를 이용해 XML로부터 설정정보를 가져오는 애플리케이션 컨텍스트를 만들 수 있다. ClassPathXmlApplicationContext는 XML 파일과 같은 클래스패스에 있는 클래스 오브젝틀르 넘겨서 클래스패스에 대한 힌트를 제공할 수 있다.

UserDao는 springbook.user.dao 패키지에 있으므로 daoContext.xml과 같은 클래스패스 위에 이다. 이 UserDao를 함께 넣어주면 XML 파일의 위치를 UserDao의 위치로부터 상대적으로 지정할 수 있다.

~~~Java
new GenericXmlApplicationContext("springbook/user/dao/daoContext.xml");
new ClassPathXmlApplicationContext("daoContext.xml", UserDao.class);
~~~
하지만 이 방법으로 클래스패스를 지정해야 할 경우가 아니라면 GenericXmlApplicationContext를 사용하는 편이 무난하다.


### DataSource 인터페이스로 변환
#### DataSource 인터페이스 적용
ConnectionMaker는 DB 커넥션을 생성해주는 기능 하나만을 정의한 매우 단순한 인터페이스다. IoC와 DI의 개념을 설명하기 위해 직접 이 인터페이스를 정의하고 사용했지만, 사실 자바에서는 DB 커넥션을 가져오는 오브젝트의 기능을 추상화해서 비슷한 용도로 사용할 수 있게 만들어진 DataSource라는 인터페이스가 이미 존재한다.

DataSource는 getConnection()이라는 DB 커넥션을 가져오는 기능 외에도 여러 개의 메소드를 가지고 있다. 또한 다양한 방법으로 DB 연결과 풀링(pooling)기능을 갖추고 있다.

따라서 DAO에서는 DataSource의 getConnection() 메소드를 사용해 DB 커넥션을 가져오면 된다.

~~~Java
//DataSource 인터페이스
public interface DataSource extends CommonDataSource, Wrapper {
  Connection getConnection() throws SQLException;
  ...
}
~~~

DataSource 인터페이스와 다양한 DataSource 구현 클래스를 사용할 수 있도록 UserDao를 리팩토링해보자.

일단 UserDao에 주입될 의존 오브젝트의 타입을 ConnectionMaker에서 DataSource로 변경하고, DB 커넥션을 가져오는 코드를 makeConnection()에서 getConnection() 메소드로 바꿔준다.

~~~Java
public class UserDao {
  private DataSource dataSource;

  public void setDataSource(DataSource dataSource) {
    this.dataSource = dataSource;
  }

  public void add(User user) throws SQLException {
    Connection c = dataSource.getConnection();
    ...
  }
}
~~~

다음은 DataSource 구현 클래스가 필요하다. DriverManager를 사용하는 SimpleConnectionMaker처럼 단순한 DataSource 구현 클래스를 하나 가져다 사용하자. 스프링이 제공해주는 DataSource 구현 클래스 중에 테스트환경에서 간단히 사용할 수 있는 SimpleDriverDataSource라는 것이 있다. 이 클래스를 사용하도록 DI를 재구성하자.

SimpleDriverDataSource는 DB 연결에 필요한 필수 정보를 제공받을 수 있도록 여러 개의 수정자 메소드를 갖고 있다. 예를 들어 JDBC 드라이버 클래스, JDBC URL, ID, PW등이다.

### 자바 코드 설정 방식
먼저 DaoFactory 설정 방식을 이용해보자. 기존의 connectionMaker() 메소드를 dataSource()로 변경하고 SimpleDriverDataSource의 오브젝트를 리턴하게 한다. 대신 이 오브젝트를 넘기기 전에 DB 연결과 관련된 정보를 수정자 메소드를 이용해 지정해줘야 한다.

~~~Java
@Bean
public DataSource dataSource() {
  SimpleDriverDataSource dataSource = new SimpleDriverDataSource();

  dataSource.setDriverClass(com.mysql.jdbc.Driver.class);
  dataSource.setUrl("jdbc:mysql://localhost/springbook");
  dataSource.setUsername("spring");
  dataSource.setPassword("book");

  return dataSource;
}
~~~

DaoFactory의 userDao() 메소드를 다음과 같이 수정한다.

~~~Java
@Bean
public UserDao userDao() {
  UserDao userDao = new UserDao();
  userDao.setDataSource(dataSource());

  return userDao;
}
~~~
이렇게 해서 UserDao에 DataSource 인터페이스를 적용하고 SimpleDriverDataSource의 오브젝트를 DI로 주입해서 사용할 수 있는 준비가 끝났다. UserDaoTest를 DaoFactory를 사용하도록 수정하고 테스트를 해보자.

### XML 설정 방식
이번에는 XML방식을 사용해보자.
먼저 id가 connectionMaker인 <bean>을 없애고 dataSource라는 이름의 <bean>을 등록한다. 그리고 클래스를 SimpleDriverDataSource로 변경해주면 다음 과같은 <bean>설정이 만들어진다.

~~~XML
<bean id="dataSource"
  class="org.springframework.jdbc.datasource.SimpleDriverDataSource" />
~~~

문제는 <bean> 설정으론 SimpleDriverDataSource의 오브젝트를 만드는 것까지는 가능하지만, DB 접속정보는 나타나 있지 않다는 점이다. XML에서는 어떻게 해서 dataSource() 메소드에서처럼 DB 연결정보를 넣도록 설정을 만들 수 있을까?

## 프로퍼티 값 주입
### 값 주입
DaoFactory의 dataSource() 메소드에서 본 것처럼, 수정자 메소드에는 다른 빈이나 오브젝트뿐 아니라 스트링 같은 단순 값을 넣어줄 수도 있다.

다른 빈 오브젝트의 래퍼런스가 아닌 단순 정보도 오브젝트를 초기화하는 과정에서 수정자 메소드에 넣을 수 있다. 이때 DI에서처럼 오브젝트의 구현 클래스를 다이내믹하게 바꿀 수 있게 해주는 것이 목적은 아니다, 대신 클래스 외부에서 DB 연결정보와 같이 변경 가능한 정보를 설정해줄 수 있도록 만들기 위해서다. 예를 들어 DB 접속 아이디가 바뀌었더라도 클래스 코드는 수정해줄 필요가 없게 해주는 것이다.

텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것을 스프링에서는 '값을 주입한다'고 한다. 스프링의 빈으로 등록될 클래스에 수정자 메소드가 정의되어 있다면 <property>를 사용해 주입할 정보를 지정할 수 있다는 점에서는 <property ref="">와 동일하다. 하지만 다른 빈 오브젝트의 래퍼런스(ref)가 아니라 단순 값(value)을 주입해주는 것이기 때문에 ref 애트리뷰트 대신 value 애트리뷰트를 사용한다.

~~~Java
/// 코드를 통한 DB 연결정보 주입
  dataSource.setDriverClass(com.mysql.jdbc.Driver.class);
  dataSource.setUrl("jdbc:mysql://localhost/springbook");
  dataSource.setUsername("spring");
  dataSource.setPassword("book");
~~~

~~~XML
<property name="driverClass" value="com.mysql.jdbc.Driver" />
<property name="url" value="jdbc:mysql://localhost/springbook" />
<property name="username" value="spring" />
<property name="password" value="book" />
~~~
ref 대신에 value를 사용했을 뿐 기존의 <property> 태그를 사용했던 것과 내용과 방법은 동일하다.

### value 값의 자동 변환
그런데 한 가지 이상한 점이 있다. url, username, password는 모두 스트링 타입이니 원래 스트링 타입이니 원래 텍스트로 정의되는 value 애트리뷰트의 값을 사용하는 것은 문제없다. 그런데 driverClass는 스트링 타입이 아니라 java.lang.Class 타입이다. DaoFactory에 적용한 예를 보면 Driver.class 라는 Class 타입 오브젝트를 전달한다. 그런데 XML에서는 별다른 타입정보 없이 클래스의 이름이 텍스트 형태로 value에 들어가 있다.

실행을 해보면 문제가 없는데, 그렇다면 어떻게 이 "com.mysql.jdbc.Driver"라는 스트링 값이 Class 타입의 파라미터를 갖는 수정자 메소드에 사용될 수 있는 것일까?

이런 설정이 가능한 이유는 스프링이 프로퍼티의 값을, 수정자 메소드의 파라미터타입을 참고로 해서 적절한 형태로 변환해주기 때문이다.

setDriverClass() 메소드의 파라미터 타입이 Class임을 확인하고 "com.mysql.jdbc.Driver"라는 텍스트 값을 com.mysql.jdbc.Driver.class 오브젝트로 자동 변경해주는 것이다. 내부적으로 아래와 같은 변환 작업이 일어난다고 생각하면 된다.

~~~Java
Class driverClass = Class.forName("com.mysql.jdbc.Driver");
dataSource.setDriverClass(driverClass);
~~~

스프링은 value에 지정한 텍스트 값을 적절한 자바 타입으로 변환해준다. Integer, Double, String, Boolean 같은 기본 타입은 물론이고 Class, URL, File, Charset 같은 오브젝트로 변환할 수도 있으며, 값이 여러 개라면 List, Map, Set, Properties나 배열 타입으로도 값의 주입이 가능하다.

이렇게 DataSource 인터페이스로의 전환 작업을 마쳤다. 최종 XML은 다음과 같다

~~~XML
<beans>
  <bean id="dataSource"
    class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
    <property name="driverClass" value="com.mysql.jdbc.Dirver" />
    <property name="url" value="jdbc:mysql://localhost/springbook" />
    <property name="username" value="spring" />
    <property name="password" value="book" />
  </bean>

  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="dataSource" ref="dataSource" />
  </bean>
</beans>
~~~
XML을 사용하는 애플리케이션 컨텍스트를 만들어 사용하도록 UserDaoTest를 수정하고 테스트를 해보면 잘 동작할 것이다.

## 정리
1장에서는 사용자 정보를 DB에 등록하거나 아이디로 조회하는 기능을 가진 간단한 DAO 코드를 만들고, 그 코드의 문제점을 살펴본 뒤, 이를 다양한 방법과 패턴, 원칙, IoC/DI 프레임워크까지 적용해서 개선해왔다.

그 과정을 돌아보자.

- 먼저 책임이 다른 코드를 분리해서 두 개의 클래스로 만들었다.(관심사의 분리, 리팩토링)
- 그중에서 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고, 다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다. 이렇게 해서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도, 그 기능을 사용하는 클래스의 코드는 같이 수정할 필요가 없도록 만들었다.(전략 패턴)
- 이를 통해 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고, 자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만들었다.(개방 폐쇄 원칙)
- 결국 한쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않아도 되게 했고(낮은 결합도), 자신의 책임과 관심사에만 순수하게 집중하는(높은 응집도) 깔끔한 코드를 만들 수 있었다.
- 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리를 만들어 넘겼다. 또는 오브젝트 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨서 오브젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만들어줬다.(제어의 역전/IoC).
- 전통적인 싱글톤 패턴 구현 방식의 단점을 살펴보고, 서버에서 사용되는 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤을 사용하면서도 싱글톤 패턴의 단점을 극복할 수 있도록 설계된 컨테이너를 활용하는 방법에 대해 알아봤다(싱글톤 레지스트리).
- 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어놓고, 런타임 시에 실제 사용할 구체적인 의존 오브젝트를 제3자(DI 컨테이너)의 도움으로 주입받아서 다이내믹한 의존관계를 갖게 해주는 IoC의 특별한 케이스를 알아봤다(의존관계 주입/DI).
- 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 수정자 메소드를 이용하는 방법을 알아봤다(생성자 주입과 수정자 주입).
- 마지막으로, XML을 이용해 DI 설정정보를 만드는 방법과 의존 오브젝트가 아닌 일반 값을 외부에서 설정해서 런타임 시에 주입하는 방법을 알아봤다(XML 설정).

1장을 끝내기 전에, 스프링이랑 '어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크'라는 사실을 꼭 기억하자. 스프링의 관심은 오브젝트와 그 관계다. 하지만 오브젝트를 어떻게 설계하고, 분리하고, 개선하고, 어떤 의존관계를 가질지 결정하는 일은 스프링이 아니라 개발자의 역할이며 책임이다. 스프링은 단지 원칙을 잘 따르는 설계를 적용하려고 할 때 필연적으로 등장하는 번거로운 작업을 편하게 할 수 있도록 도와주는 도구일 뿐임을 잊지말자.

스프링을 사용한다고 좋은 객체지향 설계와 깔끔하고 유연한 코드가 저절로 만들어지는 것은 절대 아니다. 그 부분은 개체지향 설계와 프로그래밍에 대한 학습과 훈련, 경험이 필요한 부분이며 각자가 공부해야할 책임이 있는 과제다. 다만, 스프링은 그런 좋은 설계와 코드를 적용하고자 할 때 좋은 동반자가 되어 줄 것이다.
