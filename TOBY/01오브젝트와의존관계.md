# 오브젝트와 의존관계

## 스프링과 객체지향
스프링에서 가장 중요하게 생각하는 것은 객체지향 프로그래밍이다. 객체지향 기술의 진정한 가치를 회복시키고, 그로부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가자는 것이 스프링의 철학이다.

그래서 스프링에서 가장 관심을 많이 두는 대상은 오브젝트이다.

### 초난감 DAO(Data Access Object)
사용자 정보를 DB에 저장하고 조회할 수 있는 DAO를 만들어 보자
~~~Java
@Data
public class User {
  String id;
  String name;
  String password;
}
~~~
위와 같은 사용자 정보를 저장할 클래스를 만들고,
~~~Java
public class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "id", "pw");

    PreparedStatement ps = c.preparedStatement(
    "insert into users(id, name, password) values(?, ?, ?)";
    );
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    ps.excuteUpdate();

    ps.close();
    c.close();
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Class.forName("com.mysql.jdbc.Driver");
    Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook", "id", "pw");

    PreparedStatement ps = c.preparedStatement(
    "select * from users where id = ?"
    );
    ps.setString(1, id);

    ResultSet rs = ps.excuteQuery();
    rs.next();

    User user = new User();
    user.setId(rs.getString("id"));
    user.setName(rs.getString("name"));
    user.setPassword(rs.getString("password"));

    rs.close();
    ps.close();
    c.close();

    return user;
  }
}
~~~
DAO도 만들었다, 이제 제대로 동작하는지 확인하기 위해 테스트를 해야하는데 어떻게 할까?

### main()을 이용한 DAO 테스트 코드
만들어진 코드를 검증하고자 할때 가장 간단한 방법은 오브젝트 스스로 자신을 검증하도록 만들어주는 것이다. 모든 클래스에는 자신을 엔트리 포인트로 설정해 직접 실행이 가능하게 해주는 스태틱 메소드 main()이 있다.
UserDao 오브젝트를 생성해서 add()와 get()메소드를 검증해보자

~~~Java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
  UserDato dao = new UserDao();

  User user = new User();
  user.setId("retrokarr");
  user.setName("김광현");
  user.setPassword("retro");

  dao.add(user);

  System.out.println(user.getId() + " 등록 성공");

  User user2 = dao.get(user.getId());
  System.out.println(user2.getName());
  System.out.println(user2.getPassword());

  System.out.println(user2.getId() + " 조회 성공");
}

#retrokarr 등록 성공
#김광현
#retro
#retrokarr 조회 성공
~~~
main() 메소드를 실행하면 마지막 네줄의 성공 메세지를 얻을 수 있다.

이렇게 사용자 정보의 동록과 조회가 되는 DAO와 테스트용 메소드까지 완성했다. 그런데 이 코드에는 문제점이 많다. 그 문제점은 무엇일까 생각해보자.

- 왜 코드에 문제가 많다고 하는 것일까?
- DAO 코드를 개선했을때의 장점은 무엇일까?
- 그러한 장점들이 당장, 미래에 주는 이익은 무엇일까?

스프링을 공부한다는 건 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정이다.

## DAO의 분리
### 관심사의 분리
프로그래밍 세계에서는 모든 것이 변한다. 단순히 변수나 오브젝트 필드의 값이 변한다는게 아니라, 오브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뜻이다. 요구사항, 코드, 운영 환경 뿐만 아니라 기술 또한 시간이 지남에 따라 바뀐다.

그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 미래의 변화를 어떻게 대비할 것인가이다. 그래야만 미래에 닥칠지 모르는 거대한 작업으로 인한 부담과 변경에 따른 스트레스, 갈등을 최소화할 수 있다.

미래를 준비하는 데 있어 가장 중요한 과제는 **변화에 어떻게 대비할 것인가** 이며, 가장 좋은 대책은 **변화의 폭을 최소한으로 줄여주는 것** 이다.

###### 객체지향의 의미
> 객체지향 기술이 만들어내는 가상의 추상세계 자체를 효과적으로 구성할 수 있고, 이를 자유롭고 편리하게 변경,발전, 확장시킬 수 있다는 데 더 의미가 있다.

어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있을까? 그것은 *분리와 확장* 을 고려한 설계를 했을때 가능하다.

모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다, 문제는 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 할 곳에 집중되지 않는 경우가 많다는 점이다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비해야 할 일은 한 가지 관심이 한 군데에 집중되게 하는 것이다. 관심이 같은 것끼리는 모으고, 관심이 다른 것은 따로 떨어져 있게 하는 것이다.

###### 관심사의 분리
> 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.

### 커넥션 만들기의 추출

#### UserDao의 관심사항
UserDao의 관심사항에 대해 살펴보자
-  DB와 연결을 위한 커넥션을 어떻게 가져올까라는 관심. 어떤 DB를 사용하고, 어떤 드라이버를 사용하고 등 상세하게 구분할 수 있지만 간단하게 DB 연결에 대한 관심사라고 하자.
- 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것.
- 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아서 리소스를 반환하는 것.

현재는 DB 커넥션을 가져오는 코드는 다른 괌심사와 섞여서 같은 add() 메소드에 담겨 있다. 더 큰 문제는 add() 메소드에 있는 DB 커넥션을 가져오는 코드와 동일한 코드가 get() 메소드에도 중복되어 있다는 점이다. DAO에 메소드가 많아지면 많아질 수록 중복코드가 나타날 것이고, 이렇게 하나의 관심사가 방만하게 중복되고, 여기저기 흩어져서 다른 관심의 대상과 얽혀 있으면, 변경이 일어날 때 고통을 일으키는 원인이 된다.

#### 중복 코드의 메소드 추출
가장 먼저 할 일은 커넥션을 가져오는 중복된 코드를 분리하는 것이다. 중복된 DB 연결 코드를 getConnection()이라는 이름의 독립적인 메소드로 만들어 두자.

~~~Java
public void add(User user) throws ClassNotFoundException, SQLException {
  Connection c = getConnection();
  ...
}

public User get(String id) throws ClassNotFoundException, SQLException {
  Connection c = getConnection();
  ...
}

private Connection getConnection() throws ClassNotFoundException, SQLException {
  Class.forName("com.mysql.jdbc.Driver");
  Connection c = DriverManager.getConnection(
    "jdbc:mysql://localhost/springbook", "spring", "book"
  );

  return c;
}
~~~

메소드가 많아졌다고 상상해보자, DB 연결과 관련된 부분에 변경이 일어났을 경우 앞으로는 getConnection()이라는 한 메소드의 코드만 수정하면 된다. 관심의 종류에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심이 집중되는 부분의 코드만 수정하면 된다.

#### 변경사항에 대한 검증 : 리팩토링과 테스트를
방금 한 작업은 UserDao의 기능에는 변화를 주지 않았다. 다만 여러 메소드에 중복돼서 등장하는 특정 관심사항이 담긴 코드를 별도의 메소드로 분리해낸 것이다. 기능에는 영향을 주지 않으면서 코드의 구조만 변경했다. 이처럼 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 **리팩토링** 이라고 하며, 메소드로 중복된 코드를 뽑아내는 것을 **메소드 추출** 기법이라고 부른다.

###### 리팩토링의 이점
>리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다.

### DB 커넥션 만들기의 독립

초보적인 관심사의 분리 작업이지만, 메소드 추출만으로도 변화에 좀 더 유연하게 대처할 수 있는 코드를 만들었다. 이번에는 좀 더 나아가서 변화에 대응하는 수준이 아니라, 변화를 반기는 DAO를 만들어 보자.

UserDao가 발전하고, 널리 알려지면서 여러 회사에서 구매하여 사용하겠다고 하는 상황을 상상해보자, 문제는 사용을 원하는 회사에서는 다른 DB를 사용하고 있으며, DB커넥션을 가져오는 데 있어 독자적인 방법을 만들어 적용하고 싶어한다는 점이다. 더 큰 문제는 DB 커넥션을 가져오는 방법이 종종 변경될 가능성이 있다는 점이다.

이런경우 UserDao의 소스코드를 제공하고 직접 getConnection() 메소드를 수정해서 사용하라고 할수도 있지만, UserDao의 소스를 공개하고 싶지 않는 경우에는 어떻게 고객 스스로 원하는 DB 커넥션 생성 방식을 적용해가면서 UserDao를 사용하게 할 수 있을까?

#### 상속을 통한 확장

UserDao 코드를 한 단계 더 분리하면 위의 문제를 해결 할 수 있다. UserDao에서 메소드의 구현 코드를 제거하고 getConnection()을 추상 메소드로 만드는 것이다. 이렇게 하면 추상 메소드라서 메소드 코드는 없지만 메소드 자체는 존재한다. 따라서 add(), get() 메소드에서 getConnection()을 호출하는 코드는 그대로 유지할 수 있다.

UserDao의 구입사들은 UserDao 클래스를 상속해서 각각 NUserDao와 DUserDao라는 서브 클래스를 만들고 getConnection() 메소드를 원하는 방식대로 구현할 수 있다. 이렇게 하면 소스코드를 제공해서 수정해 쓰도록 하지 않아도 getConnection() 메소드를 원하는 방식으로 확장한 후에 UserDao의 기능과 함께 사용할 수 있다.

~~~text
          +----------------+
          |UserDao         |
          +----------------+
          |add()           |
          |get()           |
          |getConnection() |
          +--------+-------+
                   △
                   |
         +---------+----------+
         |                    |
+--------+-------+   +--------+-------+
|NUserDao        |   |DUserDao        |
+----------------+   +----------------+
|getConnection() |   |getConnection() |
+----------------+   +----------------+
~~~

~~~Java
public abstract class UserDao {
  public void add(User user) throws ClassNotFoundException, SQLException {
    Connection c = getConnection();
    ...
  }

  public User get(String id) throws ClassNotFoundException, SQLException {
    Connection c= getConnection();
    ...
  }

  public abstrac Connection getConnection() throws ClassNotFoundException, SQLException;
}

public class NUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // N사의 DB connection 생성 코드
  }
}

public class DUserDao extends UserDao {
  public Connection getConnection() throws ClassNotFoundException, SQLException {
    // D 사 DB connection 생성 코드
  }
}
~~~
