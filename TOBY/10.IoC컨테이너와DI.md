# IoC 컨테이너와 DI
스프링이 제공하는 DI 설정 메타데이터를 다루는 여러 가지 방법을 살펴보고, 상황에 맞게 어떤 설정 방식과 응용 기술을 선택할지에 대해 알아보자.

## IoC 컨테이너: 빈 팩토리와 애플리케이션 컨텍스트
스프링 애플리케이션에서는 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립된 컨테이너가 담당한다. 이를 컨테이너가 코드 대신 오브젝트에 대한 제어권을 갖고 있다고 해서 IoC라고 부른다. 그래서 스프링 컨테이너를 IoC 컨테이너라고도 한다.

~~~
스프링 컨테이너 = IoC 컨테이너 = 빈 팩토리 = 애플리케이션 컨텍스트
~~~

오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 때는 컨테이너를 빈 팩토리라고 하며, DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는 데 필요한 여러 가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트라고 부른다.

빈 팩토리와 애플리케이션 컨텍스트는 각각 BeanFactory와 ApplicationContext라는 두개의 인터페이스로 정의되어 있다. ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속한 서브인터페이스다.

~~~Java
public interface ApplicationContext extends ListableBeanFactory,
                                            HierachicalBeanFactory,
                                            MessageSource,
                                            ApplicationEventPublisher,
                                            ResourcePatternResolver {
}
~~~

정확히는 ListableBeanFactory와 HierachicalBeanFactory라는 두 개의 BeanFactory로 끝나는 인터페이스가 모두 BeanFactory 인터페이스의 서브인터페이스이다.

실제로 스프링 컨테이너 또는 IoC 컨테이너라고 말하는 것은 이 ApplicationContext 인터페이스를 구현한 클래스의 오브젝트이다.


## IoC 컨테이너를 이용해 애플리케이션 만들기
가장 간단한 방법은 다음과 같이 ApplicationContext 구현 클래스의 인스턴스를 만드는 것이다.

~~~Java
StaticApplicationContext ac = new StaticApplicationContext();
~~~
IoC 컨테이너가 하나 만들어졌지만 아무런 하는 일이 없는 빈 컨테이너일 뿐이다. 컨테이너가 본격적으로 IoC 컨테이너로서 동작하려면 두 가지가 필요하다. **POJO**, **설정 메타정보** 이다.

### POJO 클래스
애플리케이션의 핵심 코드를 담고 있는 POJO 클래스를 준비해야 한다. POJO는 특정 기술과 스펙에서 독립적일뿐더러 의존관계에 있는 다른 POJO와 느슨한 결합을 갖도록 만들어야 한다.

예시를 보자
~~~Java
public class Hello {
  String name;
  Printer printer;

  public String sayHello() {
    return "Hello " + name;
  }

  public void print() {
    this.printer.print(sayHello());
  }

  public void setName(String name) {
    this.name = name;
  }

  public void setPrinter(Printer printer) {
    this.printer = printer;
  }
}

public interface Printer {
  void print(String message);
}
~~~

위의 두 POJO 클래스는 Printer라는 인터페이스를 사이에 두고 느슨하게 연결되어 있다. 구체적으로 서로의 이름과 존재를 알 필요도 없다. 단지 서로 관계를 맺고 사용될 때 필요한 최소한의 인터페이스 정보만 공유하면 된다.

Hello클래스는 코드로만 보자면 Printer라는 인터페이스에만 의존한다. 실제로 런타임 시에 어떤 구체적인 클래스의 오브젝트를 사용하게 될지는 알지도 못하고, 사실 관심도 없다.

~~~Java
public class StringPrinter implements Printer {
  private StringBuffer buffer = new StringBuffer();

  public void print(String message) {
    this.buffer.append(message);
  }

  public String toString() {
    return this.buffer.toString();
  }
}

public class ConsolePrinter implements Printer {
  public void print(String message) {
    System.out.println(message);
  }
}
~~~
각자 기능에 충실하게 독립적으로 설계된 POJO 클래스를 만들고, 결합도가 낮은 유연한 관계를 가질 수 있도록 인터페이스를 이용해 연결해주는 것까지가 IoC 컨테이너가 사용할 PJOJ를 준비하는 첫 단계다.

### 설정 메타정보
두 번째 필요한 것은 POJO 클래스들 중에 사용할 것을 선정하고 이를 IoC 컨테이너가 제어할 수 있도록 메타정보를 만들어 제공하는 작업이다.

IoC 컨테이너의 가장 기초적인 역할은 오브젝트를 생성하고 이를 관리하는 것인데, 스프링 컨테이너가 관리하는 이런 오브젝트를 빈(Bean) 이라고 부른다. IoC 컨테이너가 필요로 하는 설정 메타정보는 이 빈을 어떻게 만들고 어떻게 동작하게 할 것인가에 관한 정보이다.

스프링의 설정 메타정보는 BeanDefinition 인터페이스로 표현되는 순수한 추상 정보다. IoC 컨테이너는 바로 이 BeanDefinition으로 만들어진 메타정보를 담은 오브젝트를 사용해 IoC와 DI 작업을 수행한다. 스프링의 메타 정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지 않는다. 단지 원본의 포맷과 구조, 자료의 특성에 맞게 읽어와 BeanDefinition 오브젝트로 변환해주는 BeanDefinitionReader(Interface)가 있으면 된다.

IoC컨테이너가 사용하는 빈 메타정보는 대략 다음과 같다
- 빈 아이디, 이름, 별칭: 빈 오브젝트를 구분할 수 있는 식별자
- 클래스 또는 클래스 이름: 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보
- 스코프: 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
- 프로퍼티 값 또는 참조: DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
- 생성자 파라미터값 또는 참조 : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
- 지연된 로딩 여부, 우선 빈 여부, 자동와이어링 여부, 부모 빈 정보, 빈팩토리 이름 등

스프링 IoC 컨테이너는 각 빈에 대한 정보를 담은 설정 메타정보를 읽어들인 뒤에, 빈 오브젝트를 생성하고 프로퍼티나 생성자를 통해 의존 오브젝트를 주입해주는 DI 작업을 수행한다.
