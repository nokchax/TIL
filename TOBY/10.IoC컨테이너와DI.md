# IoC 컨테이너와 DI
스프링이 제공하는 DI 설정 메타데이터를 다루는 여러 가지 방법을 살펴보고, 상황에 맞게 어떤 설정 방식과 응용 기술을 선택할지에 대해 알아보자.

## IoC 컨테이너: 빈 팩토리와 애플리케이션 컨텍스트
스프링 애플리케이션에서는 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 애플리케이션 코드 대신 독립된 컨테이너가 담당한다. 이를 컨테이너가 코드 대신 오브젝트에 대한 제어권을 갖고 있다고 해서 IoC라고 부른다. 그래서 스프링 컨테이너를 IoC 컨테이너라고도 한다.

~~~
스프링 컨테이너 = IoC 컨테이너 = 빈 팩토리 = 애플리케이션 컨텍스트
~~~

오브젝트의 생성과 오브젝트 사이의 런타임 관계를 설정하는 DI 관점으로 볼 때는 컨테이너를 빈 팩토리라고 하며, DI를 위한 빈 팩토리에 엔터프라이즈 애플리케이션을 개발하는 데 필요한 여러 가지 컨테이너 기능을 추가한 것을 애플리케이션 컨텍스트라고 부른다.

빈 팩토리와 애플리케이션 컨텍스트는 각각 BeanFactory와 ApplicationContext라는 두개의 인터페이스로 정의되어 있다. ApplicationContext 인터페이스는 BeanFactory 인터페이스를 상속한 서브인터페이스다.

~~~Java
public interface ApplicationContext extends ListableBeanFactory,
                                            HierachicalBeanFactory,
                                            MessageSource,
                                            ApplicationEventPublisher,
                                            ResourcePatternResolver {
}
~~~

정확히는 ListableBeanFactory와 HierachicalBeanFactory라는 두 개의 BeanFactory로 끝나는 인터페이스가 모두 BeanFactory 인터페이스의 서브인터페이스이다.

실제로 스프링 컨테이너 또는 IoC 컨테이너라고 말하는 것은 이 ApplicationContext 인터페이스를 구현한 클래스의 오브젝트이다.


## IoC 컨테이너를 이용해 애플리케이션 만들기
가장 간단한 방법은 다음과 같이 ApplicationContext 구현 클래스의 인스턴스를 만드는 것이다.

~~~Java
StaticApplicationContext ac = new StaticApplicationContext();
~~~
IoC 컨테이너가 하나 만들어졌지만 아무런 하는 일이 없는 빈 컨테이너일 뿐이다. 컨테이너가 본격적으로 IoC 컨테이너로서 동작하려면 두 가지가 필요하다. **POJO**, **설정 메타정보** 이다.

### POJO 클래스
애플리케이션의 핵심 코드를 담고 있는 POJO 클래스를 준비해야 한다. POJO는 특정 기술과 스펙에서 독립적일뿐더러 의존관계에 있는 다른 POJO와 느슨한 결합을 갖도록 만들어야 한다.

예시를 보자
~~~Java
public class Hello {
  String name;
  Printer printer;

  public String sayHello() {
    return "Hello " + name;
  }

  public void print() {
    this.printer.print(sayHello());
  }

  public void setName(String name) {
    this.name = name;
  }

  public void setPrinter(Printer printer) {
    this.printer = printer;
  }
}

public interface Printer {
  void print(String message);
}
~~~

위의 두 POJO 클래스는 Printer라는 인터페이스를 사이에 두고 느슨하게 연결되어 있다. 구체적으로 서로의 이름과 존재를 알 필요도 없다. 단지 서로 관계를 맺고 사용될 때 필요한 최소한의 인터페이스 정보만 공유하면 된다.

Hello클래스는 코드로만 보자면 Printer라는 인터페이스에만 의존한다. 실제로 런타임 시에 어떤 구체적인 클래스의 오브젝트를 사용하게 될지는 알지도 못하고, 관심도 없다.

~~~Java
public class StringPrinter implements Printer {
  private StringBuffer buffer = new StringBuffer();

  public void print(String message) {
    this.buffer.append(message);
  }

  public String toString() {
    return this.buffer.toString();
  }
}

public class ConsolePrinter implements Printer {
  public void print(String message) {
    System.out.println(message);
  }
}
~~~
각자 기능에 충실하게 독립적으로 설계된 POJO 클래스를 만들고, 결합도가 낮은 유연한 관계를 가질 수 있도록 인터페이스를 이용해 연결해주는 것까지가 IoC 컨테이너가 사용할 PJOJ를 준비하는 첫 단계다.

### 설정 메타정보
두 번째 필요한 것은 POJO 클래스들 중에 사용할 것을 선정하고 이를 IoC 컨테이너가 제어할 수 있도록 메타정보를 만들어 제공하는 작업이다.

IoC 컨테이너의 가장 기초적인 역할은 오브젝트를 생성하고 이를 관리하는 것인데, 스프링 컨테이너가 관리하는 이런 오브젝트를 빈(Bean) 이라고 부른다. IoC 컨테이너가 필요로 하는 설정 메타정보는 이 빈을 어떻게 만들고 어떻게 동작하게 할 것인가에 관한 정보이다.

스프링의 설정 메타정보는 BeanDefinition 인터페이스로 표현되는 순수한 추상 정보다. IoC 컨테이너는 바로 이 BeanDefinition으로 만들어진 메타정보를 담은 오브젝트를 사용해 IoC와 DI 작업을 수행한다. 스프링의 메타 정보는 특정한 파일 포맷이나 형식에 제한되거나 종속되지 않는다. 단지 원본의 포맷과 구조, 자료의 특성에 맞게 읽어와 BeanDefinition 오브젝트로 변환해주는 BeanDefinitionReader(Interface)가 있으면 된다.

IoC컨테이너가 사용하는 빈 메타정보는 대략 다음과 같다
- 빈 아이디, 이름, 별칭: 빈 오브젝트를 구분할 수 있는 식별자
- 클래스 또는 클래스 이름: 빈으로 만들 POJO 클래스 또는 서비스 클래스 정보
- 스코프: 싱글톤, 프로토타입과 같은 빈의 생성 방식과 존재 범위
- 프로퍼티 값 또는 참조: DI에 사용할 프로퍼티 이름과 값 또는 참조하는 빈의 이름
- 생성자 파라미터값 또는 참조 : DI에 사용할 생성자 파라미터 이름과 값 또는 참조할 빈의 이름
- 지연된 로딩 여부, 우선 빈 여부, 자동와이어링 여부, 부모 빈 정보, 빈팩토리 이름 등

스프링 IoC 컨테이너는 각 빈에 대한 정보를 담은 설정 메타정보를 읽어들인 뒤에, 빈 오브젝트를 생성하고 프로퍼티나 생성자를 통해 의존 오브젝트를 주입해주는 DI 작업을 수행한다.

~~~
메타 정보 리소스 -> 메타정보 리더 -> 설정 메타정보
설정 메타 정보 + POJO 클래스 -input-> IoC 컨테이너 -output-> DI 된 빈 오브젝트로 이뤄진 애플리케이션
~~~

스프링 애플리케이션이랑 POJO 클래스와 설정 메타정보를 이용해서 IoC 컨테이너가 만들어주는 오브젝트의 조합이다.

~~~Java
//IoC 컨테이너 생성, 생성과 동시에 컨테이너로 동작한다.
StaticApplicationContext ac = new StaticApplicationContext();
//Hello 클래스를 hello1이라는 이름의 싱글톤 빈으로 컨테이너에 등록한다.
ac.registerSingleton("hello1", Hello.class);

//IoC 컨테이너가 등록한 빈을 생성헀는지 확인하기 우해 빈을 요청하고 Null이 아닌지 확인한다.
Hello hello1 = ac.getBean("hello1", Hello.class);
assertThat(hello1, is(notNullValue()));
~~~

주의해야할 점은 IoC 컨테이너가 관리하는 빈은 오브젝트 단위지 클래스 단위가 아니라는 사실이다. 보통은 싱글톤으로 만들지만, 경우에 따라서는 하나의 클래스를 여러 개의 빈을 등록하기도 한다.

위에서는 디폴트 메타정보를 사용해서 싱글톤 빈을 등록해주는 registerSingleton() 메소드를 사용했는데, 이번에는 직접 BeanDefinition 타입의 설정 메타정보를 만들어서 IoC 컨테이너에 등록하는 방법을 사용해보자.

RootBeanDefinition은 가장 기본적인 BeanDefinition 인터페이스의 구현 클래스다. 아래와 같이 RootBeanDefinition 오브젝트를 만들어서 빈에 대한 설정정보를 넣어주고 IoC 컨테이너에 등록할 수 있다.

~~~Java
//빈 메타정보를 담은 오브젝트를 만든다. 빈 클래스는 Hello로 지정한다.
//<bean class="springbook.learningtest...Hello" />에 해당
BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
//빈의 name프로퍼티에 들어갈 값을 지정한다.
//<property name="name" value="Spring" />에 해당
helloDef.getPropertyValues().addPropertyValue("name", "Spring");
//앞에서 생성한 빈 메타정보를 hello2라는 이름을 가진 빈으로 해서 등록한다.
//<bean id="hello2" ... />에 해당
ac.registerBeanDefinition("hello2", helloDef);
~~~


~~~Java
// BeanDefinition으로 등록된 빈이 컨테이너에 의해 만들어지고 프로퍼티 설정이 됐는지 확인
Hello hell2 = ac.getBean("hello2", Hello.class);
assertThat(hello2.sayHello(), is("Hello Spring"));
//처음 등록한 빈과 두 번째 등혹한 빈이 모두 동일한 Hello클래스지만 별개의 오브젝트로 생성된 것을 확인할 수 있다.
assertThat(hello1, is(not(hello2)));
assertThat(ac.getBeanFactory().getBeanDefinitionCount(), is(2));
~~~
마지막줄을 보면, IoC 컨테이너에서 등록된 빈 설정 메타정보를 가져올 수도 있다.

빈에 DI 되는 프로퍼티는 크게 스트링이나 숫자 등의 값과 다른 빈 오브젝트를 가리키는 레퍼런스로 분류할 수 있다. 레퍼런스로 지정된 프로퍼티는 다른 빈 오브젝트를 주입해서 오브젝트 사이의 관계를 만들어내는 데 사용된다.

Hello 타입의 빈과 StringPrinter 타입의 빈을 hello와 printer라는 빈 이름으로 생성하고 printer 빈이 hello 빈에게 DI 되도록 만들어보자.

~~~Java
@Test
public void registerBeanWithDependency() {
  StaticApplicationContext ac = new StaticApplicationContext();

  //StringPrinter 클래스 타입이며  printer라는 이름을 가진 빈을 등록한다.
  ac.registerBeanDefnition("printer", new RootBeanDefinitnion(StringPrinter.class)):

  BeanDefinition helloDef = new RootBeanDefinition(Hello.class);
  //단순 값을 갖는 프로퍼티 등록
  helloDef.getPropertyValues().addPropertyValue("name", "Spring");
  //아이디가 printer인 빈에 대한 레퍼런스를 프로퍼티로 등록
  helloDef.getPropertyValues().addPropertyValue("printer", new RuntimeBeanReference("printer"));

  ac.registerBeanDefinition("hell', helloDef");

  Hello hello = ac.getBean("hello", Hello.class);
  hello.print();

  //Hello 클래스의 print() 메소드는 DI 된 Printer 타입의 오브젝트에게 요청해서 인사말을 출력한다. 이 결과 스트링으로 저장해두는 printer 빈을 통해 확인한다.
  assertThat(ac.getBean9"printer").toString(), is("Hello Spring");
}
~~~

이제 IoC 컨테이너가 POJO 클래스와 설정 메타정보를 이용해 어떻게 최종 사용할 애플리케이션 런타임 오브젝트를 만들어내는지 이해할 수 있다. IoC 컨테이너는 이렇게 애플리케이션을 구성하는 빈 오브젝트를 생성하는 것이 핵심기능이지만, 일단 빈 오브젝트가 생성되고 관계가 만들어지면 그 뒤로는 거의 관여하지 않은다. 싱글톤 빈은 애플리케이션 컨텍스트의 초기화 작업 중에 모두 만들어진다.

## IoC 컨테이너의 종류와 사용 방법
ApplicationContext 인터페이스를 바르게 구현헀다면 어떤 클래스든 스프링의 IoC 컨테이너로 사용할 수 있다. 그런데 스프링 애플리케이션에서 직접 코드를 통해 ApplicationContext 오브젝트를 생성하는 경우는 거의 없다. 대부분 간단한 설정을 통해 ApplicationContext가 자동으로 만들어지는 방법을 사용하기 떄문이다.

스프링이 제공하는 ApplicationContext 구현 클래스에는 어떤 종류가 있고 어떻게 사용되는지 살펴보자.
### StaticApplicationContext
StaticApplicationContext는 코드를 통해 빈 메타정보를 등록하기 위해 사용한다. 스플이의 기능에 대한 학습 테스트를 만들 때를 제외하면 실제로 사용되지 않는다. 실전에서는 사용하지 말자. 스프링의 웹 관련 기능을 공부하고 학습 테스트로 검증해보고 싶을 때 유용하게 사용할 수 있는데, 이때는 서브클래스인 StaticWebApplicationContext를 사용하자.

### GenericApplicationContext
GenericApplicationContext는 가장 일반적인 애플리케이션 컨텍스트의 구현 클래스로, 실전에서 사용될 수 있는 모든 기능을 갖추고 있다. 컨테이너의 주요 기능을 DI를 통해 확장할 수 있도록 설계되어 있다.
XML 파일과 같은 외부의 리소스에 있는 빈 설정 메타정보를 리터를 통해 읽어들여서 메타정보로 정환해서 사용한다.

특정 포맷의 빈 설정 메타정보를 읽어서 이를 애플리케이션 컨텍스트가 사용할 수 있는 BeanDefinition 정보로 변환하는 기능을 가진 오브젝트는 BeanDefinitionReader 인터페이스를 구현해서 만들고, 빈 설정정보 리더라고 불린다. XML로 작성된 빈 설정정보를 읽어서 컨테이너에게 전달하는 댚적인 빈 설정정보 리더는 XmlBeanDefinitionReader다.

~~~XMl
<beans>
  <bean id="hello" class="springbook.learningtest.spring.ioc.bean.Hello">
    <property name="name" value="Spring" />
    <property name="printer" ref="printer" />
  </bean>
  <bean id="printer" class="springbook...StringPrinter" />
</beans>
~~~
~~~Java
@Test
public void genericApplicationContext() {
  GenericApplicationContext ac = new GenericApplicationContext();
  XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(ac);
  //MmlBeanDefinitionReader는 기본적으로 클래스패스로 정의된 리소스로부터 파일을 읽는다.
  reader.loadBeanDefinitions("springbook///genericapplicationContext.xml");
  ac.refresh(); //모든 메타정보를 틍록 했으니 앺를리케이션 컨테이너를 초기화하라는 명령

  Hello hello = ac.getBean("hello", Hello.class);
  hello.print();

  assertThat(ac.getBean("printer").toString(), is("Hello Spring"));
}
~~~

리소스 대신 스트링을 넘기면 기본적으로 클래스패스 리소스로 인식한다. classpath:나 file:, http: 같은 접두어를 이용해 구체적인 리소스 타입을 지정해도 된다.

스프링 IoC 컨테이너가 사용할 수 있는 BeanDefinition 오브젝트로 변환만 될 수 있다면 설정 메타정보는 어떤 포맷으로 만들어져도 상관없다. 스프링은 XML 말고도 프로퍼티 파일에서 빈 설정 메타정보를 가져오는 PropertiesBeanDefinitionReader도 제공한다.

~~~
//프로퍼티 파일로 작성된 빈 설정 메타정보
printer.(Class)=springbook.learningtest.spring.ioc.bean.StringPrinter

hello.(Class)=springbook.learningtest.spring.ioc.bean.Hello
hello.name=Spring
hello.printer(ref)=printer
~~~

빈 설정 리더를 만들어두기만 하면 어떤 형태로도 빈 설정 메타정보를 작성할 수 있다. DB의 테이블에 빈 설정정보를 저장해두고 이를 읽어서 사용하거나, 원격 서버로부터 정보를 읽어올 수도 있다. 스프링에서는 대표적으로 XML 파일, 자바 소스코드 애노테이션, 자바 클래스 세 가지 방식으로 빈 설정 메타정보를 작성할 수 있다.

GenericApplicationContext는 빈 설정 리더를 여러 개 사용해서 여러 리소스로부터 설정 메타정보를 읽어들이게도 할 수 있다. 모든 설정 정보를 가져온 후에 refresh() 메소드를 한 번 호출해서 애플리케이션 컨텍스트가 필요한 초기화 작업을 수행하게 해주면 된다.

하지만 이런 GenericApplicationContext도 직접 사용할 일은 없을 것이다. 그런데 코드에서 직접 만들고 초기화하지 않을 뿐, 실제로는 자주 사용된다. 스프링 테스트 컨텍스트 프레임워크를 활용하는 JUnit 테스트는 테스트 내에서 사용할 수 있도록 애플리케이션 컨텍스트를 자동으로 만들어준다. 이때 생성되는 애플리케이션 컨텍스트가 바로 GenericApplicationContext다.

아래와 같이 테스트 클래스를 만들었다면 테스트가 실행되면서 GenericApplicationContext가 생성되고 @ContextConfiguration에 지정한 XML 파일로 초기화가 돼서 테스트 내에서 사용할 수 있도록 준비된다.

~~~Java
@RunWith(SpringJUnit4ClassRunner.class)
// 애플리케이션 컨텍스트 생성과 동시에 XML 파일을 읽어오고 초기화까지 수행한다.
@ContextConfiguartion(locations = "/test-applicationContext.xml")
public class UserServiceTest {
  @Autowired ApplicationContext applicationContext;
  ...
}
~~~

### GenericXmlApplicationContext
GenericXmlApplicationContext는 XmlBeanDefinitionReader를 내장하고 있기 때문에, XML 파일을 읽어들이고 refresh()를 통해 초기화하는 것까지 한 줄로 끝낼 수 있다.

~~~Java
// 애플리케이션 컨텍스트 생성과 동시에 XML 파일을 읽어오고 초기화까지 수앻한다.
GenericApplicationContext ac = new GenericXmlApplicationContext("springbook/.../genericApplicationContext.xml");
~~~

### WebApplicationContext
스프링 애플리케이션에서 가장 많이 사용되는 애플리케이션 컨텍스트로, ApplicationContext를 확장한 인터페이스다. 이름 그대로 웹 환경에서 사용할 때 필요한 기능이 추가된 애플리케이션 컨텍스트다. 스프링 애플리케이션은 대부분 서블릿 기반의 독립 웹 애플리케이션(War)으로 만들어지기 때문이다.

XML 설정파일을 사용하도록 만들어진 XmlWebApplicationContext를 가장 많이사용하며, 애노테이션을 이용한 설정 리소스만 사용한다면 AnnotationConfigWebApplicationContext를 쓰면된다. 디폴트는 XmlWebApplicationContext다.

WebApplicationContext의 사용방법을 알아보기 위해 우선 스프링의 IoC 컨테이너를 적용했을 때 애플리케이션을 기동시키는 방법에 대해 살펴보자. 스프링 IoC 컨테이너는 빈 설정 메타정보를 이용해 빈 오브젝트를 만들고 DI 작업을 수행한다.

하지만 이것만으로는 애플리케이션이 동작하지 않는다. 자바 애플리케이션의 main() 메소드처럼 어디에선가 특정 빈 오브젝트의 메소드를 호출함으로써 애플리케이션을 동작 시켜야한다.

보통 이런 기동 역할을 맡은 빈을 사용하려면 IoC 컨테이너에서 요청해서 빈 오브젝트를 가져와야 한다. 그래서 간단히 스프링 애플리케이션을 만들고 IoC 컨테이너를 직접 셋업했다면 아래와 같은 코드가 반드시 등장한다.

~~~Java
ApplicationContext ac = ...
Hello hello = ac.getBean("hello", Hello.class);
hello.print();
~~~
