# 서비스 추상화
자바에는 사용 방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라서 기술이 바뀌고, 그에 따라 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야 하는 건 피곤한 일이다.

5장에서는 지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지를 살펴보자.

## 사용자 레벨 관리 기능 추가
지금까지의 UserDao는 User 오브젝트에 담겨 있는 사용자 정보를 CRUD하는 작업만 가능했다. 사용자 정보를 DB에 넣고 빼는 것을 제외하면 어떤 비즈니스 로직도 있지 않다.

여기에 비즈니스 로직을 추가하기 위해 다음과 같은 유저 레벨과 사용자 관리 기능을 추가해보자.
- 사용자의 레벨은 BASIC, SILVER, GOLD
- 가입시에 BASIC, 이후에 활동에 따라 업그레이드가 가능
- 로그인 60회 이상일 경우 BASIC -> SIVLER
- SILVER이면서 추천 30회 이상일 경우 GOLD
- 사용자 레벨 변경 작업은 배치작업으로 진행한다.

### 필드 추가
#### Level 이늄
User 클래스에 사용자의 레벨을 저장할 필드를 추가하자. DB의 User 테이블에는 어떤 타입으로 넣을지, 또 이에 매핑되는 자바의 User 클래스에는 어떤 타입으로 넣을지 생각해보자.

DB에는 varchar 타입은 좋지 않다, 이처럼 일정한 종류의 정보를 문자열로 넣는 것은 좋지 않다, 대신 각 레벨을 코드화해서 숫자로 넣어보자. 범위가 작은 숫자로 관리하면 DB 용량도 적게 차지하고 가벼워서 좋다.
그렇다면 자바에서는 어떻게 표현할까?

##### 숫자로 표현
아래 처럼 상수 값을 정해놓고 int 타입으로 레벨을 사용한다고 해보자.
~~~java
class User {
  private static final int BASIC = 1;
  private static final int SILVER = 2;
  private static final int GOLD = 3;

  int level;

  public void setLevel(int level) {
    this.level = level;
  }
}
~~~

BASIC, SILVER, GOLD처럼 의미 있는 상수도 정의해놨으니 아래처럼 코드로 작성할 수 있다.
~~~java
if(user1.getLevel() == User.BASIC) {
  user1.setLevel(User.SILVER);
}
~~~
문제는 level의 타입이 int이기 때문에 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다는 점이다. 1,2,3 이외의 숫자가 들어가면 기능은 문제없이 돌아가는 것처럼 보이지만 심각한 버그가 만들어진다.

~~~java
user1.setLevel(other.getSum());
user1.setLevel(1000);// 범위를 벗어나는 값을 넣을 가능성
~~~
그래서 숫자 타입을 직접 사용하는 것보다 자바5 이상에서 제공하는 이늄(enum)을 이용하는 게 안전하고 편리하다.

##### 이늄으로 표현
~~~java
public enum Level {
  BASIC(1), SILVER(2), GOLD(3); //세 개의 이늄 오브젝트 정의

  private final int value;

  Level(int value) {//DB에 저장할 값을 넣어줄 생성자를 만든다.
    this.value = value;    
  }

  public int intValue() {//값을 가져오는 메소드
    return value;
  }

  public static Level valueOf(int value) {//값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드
    switch(value) {
      case 1: return BASIC;
      case 2: return SILVER;
      case 3: return GOLD;
      default: throw new AssertionError("Unknown value: " + value);
    }
  }
}
~~~
이렇게 만든 Level 이늄은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다. user1.setLevel(1000)과 같은 코드는 컴파일러가 타입이 일치하지 않는다는 에러를 내면서 걸러줄것이다.

#### User 필드 추가
Level 타입의 변수를 아래처럼 User 클래스에 추가하자. 사용자 레벨 관리 로직에서 필요한 로그인 횟수와 추천수도 추가하자.
~~~java
public class User {
  ...
  Level level;
  int login;
  int recommend;

  public Level getLevel() {
    return level;
  }

  public void setLevel(Level level) {
    this.level = level;
  }
  ...

  // login, recommend getter/setter
}
~~~

그리고 DB의 USER 테이블에도 아래처럼 필드를 추가한다.
|필드명   |타입   |설정   |
|---|---|---|
|Level   |tinyint   |Not Null   |
|Login   |int   |Not Null   |
|Recommend   |int   |Not Null   |

#### UserDaoTest 테스트 수정
Level 타입의 변수를 아래처럼 User 클래스에 추가하자. 사용자 레벨 관리 로직에서 필요한 로그인 횟수와 추천수도 추가하자.
~~~java
public class User {
  ...
  Level level;
  int login;
  int recommend;

  public Level getLevel() {
    return level;
  }

  public void setLevel(Level level) {
    this.level = level;
  }
  ...

  // login, recommend getter/setter
}
~~~

그리고 DB의 USER 테이블에도 아래처럼 필드를 추가한다.
|필드명   |타입   |설정   |
|---|---|---|
|Level   |tinyint   |Not Null   |
|Login   |int   |Not Null   |
|Recommend   |int   |Not Null   |

#### UserDaoTest 테스트 수정

UserDaoJdbc와 테스트에도 필드를 추가해야 한다. 먼저 테스트 픽스처로 만든 user1, user2, user3에 아래처럼 새로 추가된 새 필드의 값을 넣는다.

~~~java
public class UserDaoTest {
  ...
  @Before
  public void setUp() {
    this.user1 = new User("syntax", "김문법", "syntaxn01", Level.BASIC, 1, 0);
    this.user2 = new User("tree", "김나무", "syntax02", Level.SILVER, 55, 10);
    this.user3 = new User("rogue", "김도둑", "syntax03", Level.Gold, 100, 40);
  }
}
~~~
이에 맞게 User 클래스 생성자도 추가해준다.
~~~java
class User {
  ...
  public User(String id, String name, String password, Level level, int login, int recommend) {
    this.id = id;
    this.name = name;
    this.password = password;
    this.level = level;
    this.login = login;
    this.recommend = recommend;
  }
}
~~~
다음은 UserDaoTest 테스트에서 두 개의 User 오브젝트 필드 값이 모두 같은지 비교하는 checkSameUser() 메소드를 수정하자 아래처럼 새로운 필드를 비교하는 코드를 추가한다.
~~~java
private void checkSameUser(User user1, User user2) {
  assertThat(user1.getId(), is(user2.getId()));
  assertThat(user1.getName(), is(user2.getName()));
  assertThat(user1.getPassword(), is(user2.getPassword()));
  assertThat(user1.getLevel(), is(user2.getLevel()));
  assertThat(user1.getLogin(), is(user2.getLogin()));
  assertThat(user1.getRecommend(), is(user2.getRecommend()));
}
~~~

기존의 addAndGet() 테스트에서는 checkSameUser() 메소들르 사용하지 않고 테스트 메소드에서 직접 assertThat()을 사용했다. 하지만 앞으로 추가되거나 변경돼도 User 오브젝트를 비교하는 로직을 일정하게 유지할 수 있도록 checkSameUser()를 아래처럼 수정하자.

~~~java
@Test
public void addAndGet() {
  ...
  User userget1 = dao.get(user1.getId());
  checkSameUser(userget1, user1);

  User userget2 = dao.get(user2.getId());
  checkSameUser(userget2, user2);
}
~~~
테스트 준비는 다 됐으니, 테스트 대상인 UserDaoJdbc를 수정하자.

#### UserDaoJdbc 수정
등록을 위한 INSERT 문장이 들어 있는 add() 메소드의 SQL과 각종 조회 작업에 사용되는 User 오브젝트 매핑용 콜백인 userMapper에 추가된 필드를 넣자.

~~~java
public class UserDaoJdbc implements UserDao {
  ...
  private RowMapper<User> userMapper =
    new RowMapper<User>() {
      public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();

        user.setId(rs.getStrign("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        user.setLevel(Level.valueOf(rs.getInt("level")));
        user.setLogin(rs.getInt("loign"));
        user.setRecommend(rs.getInt("recommend"));

        return user;
      }
    };

  public void add(user user) {
    this.jdbcTemplate.update(
      "insert into users(id, name, password, level, login, recommend) " +
      "values(?, ?, ?, ?, ?, ?)", user.getId(), user.getName(),
      user.getPassword(), user.getLevel().intValue(),
      user.getLogin(), user.getRecommend());
  }
}
~~~
여기서 눈여겨볼 곳은 Level 타입의 level 필드를 사용하는 부분이다. Level 이늄은 오브젝트이므로 DB에 저장될 수 없는 SQL 타입이다. 따라서 DB에 저장 가능한 정수형 값으로 변환해줘야 한다. 따라서 user.getLevel().intValue()로 미리 정의해둔 정수형 값으로 변환하여 넣어 줬다.

반대로 조회를 했을 경우는 DB에서 int값을 가지고와 Level.valueOf()를 이용해 Level 타입의 이늄 오브젝트로 만들어서 setLevel() 메소드에 넣어줘야 한다.

이제 테스트를 해보자. 테스트를 해보면 아래와 같은 에러가 뜬다.
org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; .... Column 'loign' not found

예외를 보면 login을 loign이라고 잘못 쓴것임을 알 수 있다. JDBC가 사용하는 SQL은 컴파일 과정에서는 자동으로 검증이 되지 않는 단순 문자열에 불과하다. 따라서 SQL 문장이 완성돼서 DB에 전달되기 전까지는 문법 오류나 오타를 발견하기 힘들다. 미리미리 DB까지 연동되는 테스트를 만들었기 때문에 SQL 문장에서 오타가 있음을 빠르게 잡을수 있었다.

만약 테스트가 없는 채로 사용자 정보에 새로운 필드가 추가됐다면 어땠을까? 코드를 빌드하고 서버에 올려서 누군가 사용자의 정보를 읽고 쓰는 기능을 사용하기 전까지는 발견하기 힘들 것이다. 따라서 그때까지 진행한 빌드와 서버 배치, 서버 재시작, 수동 테스트 등에 소모한 시간이 낭비가 되는 것이다. 그만큼 테스트는 중요하다.

### 사용자 수정 기능 추가
사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 기본키인 id를 제외한 나머지 필드는 수정될 가능성이 있다. 수정할 정보가 담긴 User 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 이용해 모두 변경해주는 메소드를 하나 만들자.

#### 수정 기능 테스트 추가
만들어야 할 코드의 기능을 생각해볼 겸 아래와 같은 테스트를 작성하자.
~~~java
@Test
public void update() {
  dao.deleteAll();

  dao.add(user1);

  user1.setName("김광현");
  user1.setPassword("khpw01");
  user1.setLevel(Level.GOLD);
  user1.setLogin(1000);
  user1.setRecommend(999);
  dao.update(user1);

  User user1update = dao.get(user1.getId());
  checkSameUser(user1, user1update);
}
~~~
픽스처 오브젝트를 하나 등록하고 id를 제외한 필드의 내용을 바꾼뒤 update()를 호출한다. 이후 id로 조회하고 나온 오브젝트와 픽스처 오브젝트를 비교하면 된다.

#### UserDao와 UserDaoJdbc 수정
이제는 UserDao 인터페이스에 update() 메소드가 없다고 에러가 뜰 것이다. 우선 인터페이스에 메소드를 추가하자.
~~~java
public interface UserDao {
  ...
  public void update(User user1);
}
~~~

인터페이스에 추가하고 나면 이제는 UserDaoJdbc차례다. 아래와 같이 구현하자.
~~~java
public void update(User user) {
  this.jdbcTemplate.update(
    "update users set name = ?, password = ?, level = ?, login = ?, " +
    "recommend = ? where id = ? ", user.getName(), user.getPassword(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend(), user.getId());
}
~~~
이제 테스트를 돌려보면 성공할 것이다.

#### 수정 테스트 보완
테스트를 성공했으니 만족하고 넘어갈 수도 있지만 항상 테스트에 뭔가 불만을 가지고 의심스럽게 코드를 살펴보자. JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가장 실수가 많이 일어나는 곳은 SQL 문장이다. SQL 키워드를 잘못 입력한 경우라면 테스트를 통해 에러가 나니 확인이 쉽지만, 위의 update() 테스트같은 경우 처럼 검증 못하는 오류가 날 수도있다.

만약 SQL문장에서 WHERE절이 없다면? 모든 로우에 업데이트가 일어나는 문제가 발생하지만, 이 테스트로는 검증할 수 없다.

이 문제를 해결할 방법을 생각해보자.
첫 번째 방법은 JdbcTemplate의 update()가 돌려주는 리턴 값을 확인하는 것이다. JdbcTemplate의 update()는 UPDATE나 DELETE 같이 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 개수를 돌려준다. 이 정보를 이용하는 것이다.

두 번째 방법은 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것이다. 여기서는 두 번째 방법을 사용해 보자.

아래는 두 번째 방법으로 테스트를 보완한 것이다.
~~~java
@Test
public void update() {
  dao.deleteAll();

  dao.add(user1);
  dao.add(user2);

  user1.setName("김광현");
  user1.setPassword("khpw01");
  user1.setLevel(Level.GOLD);
  user1.setLogin(1000);
  user1.setRecommend(999);

  dao.update(user1);

  User user1update = dao.get(user1.getId());
  checkSameUser(user1, user1update);
  User user2same = dao.get(user2.getId());
  checkSameUser(user2, user2same);
}
~~~
update() 메소드의 SQL에서 WHERE절을 빼먹었다면 이 테스트는 실패할 것이다. 사용자 정보를 수정하는 기능을 추가했으니 이제 본격적으로 사용자 관리 비즈니스 로직을 구현해보자.

### UserService.upgradeLevels()
레벨 관리 긴으은 UserDao의 getAll() 메소드로 사용자를 다 가져와서 레벨 업그레이드 작업을 진행하면서 UserDao의 update()를 호출해 DB에 결과를 넣어주면 된다.

그렇다면 사용자 관리 로직은 어디에 두는 것이 좋을까? UserDaoJdbc는 적당하지 않다. DAO는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비지니스 로직을 두는 곳이 아니다. 사용자 관리비즈니스 로직을 담을 클래스를 하나 추가하자. UserService로 이 클래스는 인터페이스 타입으로 userDao 빈을 DI 받아 사용하게 만든다.

UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야 한다. 데이터 액세스 로직이 바뀌었다고 비즈니스 로직 코드를 수정하는 일이 있어서는 안 된다. 따라서 DAO의 인터페이스를 사용하고 DI를 적용해야 한다. 그리고 UserService를 위한 테스트 클래스도 하나 추가하자.

~~~
+---------------+        +-----------+          +---------+
|UserServiceTest|        |UserService|          |I)UserDao|
+---------------|------->+-----------|--------->+---------+
|               |        |           |          |         |
+---------------+        +-----------+          +----+----+
                                                     △
                                             +-------+--------+
                                             |                |
                                      +------+----+     +-----+----+
                                      |UserDaoJdbc|     |UserDaoJpa|
                                      +-----------+     +----------+
                                      |           |     |          |
                                      +-----------+     +----------+
~~~

#### UserService 클래스와 빈 등록
UserService 클래스를 만들고 사용할 UserDao 오브젝트를 저장할 인스턴스 변수를 선언하자.
~~~java
public class UserService {
  UserDao userDao;

  public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
  }
}
~~~

스프링 설정파일에 userService 빈을 추가하고 userDao 빈을 DI받도록 프로퍼티를 추가하자.
~~~xml
<bean id="userService" class="springbook.user.service.UserService">
  <property name="userDao" ref="userDao" />
</bean>

<bean id="userDao" class="springbook.dao.UserDaoJdbc">
  <property name="dataSource" ref="dataSource" />
</bean>
~~~

#### UserServiceTest 테스트 클래스
다음은 테스트 클래스를 추가하고 UserService 빈을 제공 받을 수 있도록 @Autowired가 붙은 인스턴스 변수로 선언하자.
~~~java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/test-applicationContext.xml")
public class UserServiceTest {
  @Autowired
  UserService userService;
}
~~~

JUnit 테스트로 실행해보면 테스트 메소드가 하나도 없다고 에러가 뜰 것이다. 간단히 userService 빈이 생성돼서 userService 변수에 주입되었는지만 확인해보자.
~~~java
@Test
public void bean() {
  assertThat(this.userService, is(notNullValue()));
}
~~~
테스트가 성공적으로 성공할 것이다. 이 테스트는 다른 메소드를 생성하면 삭제하도록 하자.

#### upgradeLevels() 메소드
로직을 추가할 준비는 끝났고 사용자 레벨 관리 기능을 먼저 만들고 테스트를 만들어보자.
앞에서 살펴본 로직을 보고 구현하면 아래와 같은 메소드로 만들수 있다.
~~~java
public void upgradeLevels() {
  List<User> users = userDao.getAll();
  for(User user : users) {
    Boolean changed = null;
    if(user.getLevel() == Level.BASIC && user.getLogi() >= 50) {
      user.setLevel(Level.SILVER);
      changed = true;
    }
    else if(user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
      user.setLevel(Level.GOLD);
      changed = true;
    }
    else if(user.getLevel() == Level.GOLD ) {
      changed = false;
    }
    else {
      changed = false;
    }

    if(changed)
      userDao.update(user);
  }
}
~~~
본격적인 비즈니스 로직이 들어가니 조건문도 많이 나오고 코드가 조금 복잡해 보인다. 정말 뛰어난 개발자라면 아무리 간단해 보여도 실수할 수 있음을 알고 있기 때문에 테스트를 만들어서 직접 동작하는 모습을 확인해보려고 할 것이다.

#### upgradeLevels() 테스트
테스트 방법을 생각해보자. 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다. 사용자 레벨은 세 가지가 있고, 변경이 일어나지 않는 GOLD를 제외한 나머지 두 가지는 업그레이드가 되는 경우와 아닌 경우가 있을 수 있으므로 최소한 다섯 가지 경우를 살펴봐야 한다. 다섯 종류의 사용자를 등록하고 업그레이드를 진행한 후에 예상한 대로 경과가 나오는지 확인해보자.

텍스트 픽스쳐의 개수가 UserDaoTest에서보다 많아졌으니 이번에는 리스트를 아래처럼 이용해보자.
~~~java
class UserServiceTest {
  ...
  List<User> users; //테스트 픽스쳐

  @Before
  public void setUp() {
    users = Arrays.asList(
      new User("kkh01", "김공일", "p1", Level.BASIC, 49, 0),
      new User("kkh02", "김공이", "p2", Level.BASIC, 50, 0),
      new User("kkh03", "김공삼", "p3", Level.SILVER, 60, 29),
      new User("kkh04", "김공사", "p4", Level.SILVER, 60, 30),
      new User("kkh05", "김공오", "p5", Level.GOLD, 100, 100)
    );
  }
}
~~~
테스트에 사용할 데이터를 경계가 되는 값의 전후로 선택하여 등록하는 것이 좋다.
이제 테스트를 만들어보자.
~~~java
@Test
public void upgradeLevels() {
  userDao.deleteAll();
  for(User user : users) userDao.add(user);

  userService.upgradeLevels();

  checkLevel(users.get(0), Level.BASIC);
  checkLevel(users.get(1), Level.SILVER);
  checkLevel(users.get(2), Level.SILvER);
  checkLevel(users.get(3), Level.GOLD);
  checkLevel(users.get(4), Level.GOLD);
}

private void checkLevel(User user, Level expectedLevel) {
  User userUpdate = userDao.get(user.getId());
  assertThat(userUpdate.getLevel(), is(expectedLevel));
}
~~~
테스트는 문제없이 성공할 것이다.

### UserService.add()
