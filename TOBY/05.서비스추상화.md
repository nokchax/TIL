# 서비스 추상화
자바에는 사용 방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. **환경과 상황에 따라서 기술이 바뀌고, 그에 따라 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야 하는 건 피곤한 일이다.**

5장에서는 지금까지 만든 DAO에 트랜잭션을 적용해보면서 **스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지를 살펴보자.**

## 사용자 레벨 관리 기능 추가
지금까지의 UserDao는 사용자 정보를 CRUD하는 작업만 가능했다. DB에 넣고 빼는 것을 제외하면 어떤 비즈니스 로직도 있지 않다.

여기에 비즈니스 로직을 추가하기 위해 다음과 같은 유저 레벨과 사용자 관리 기능을 추가해보자.
- 사용자의 레벨은 BASIC, SILVER, GOLD
- 가입시에 BASIC, 이후에 활동에 따라 업그레이드가 가능
- 로그인 60회 이상일 경우 BASIC -> SIVLER
- SILVER이면서 추천 30회 이상일 경우 GOLD
- 사용자 레벨 변경 작업은 배치작업으로 진행한다.

### 필드 추가
#### Level 이늄
User 클래스에 사용자의 레벨을 저장할 필드를 추가하자. DB의 User 테이블에는 어떤 타입으로 넣을지, 또 이에 매핑되는 자바의 User 클래스에는 어떤 타입으로 넣을지 생각해보자.

DB에는 varchar 타입은 좋지 않다, 이처럼 일정한 종류의 정보를 문자열로 넣는 것은 좋지 않다, 대신 각 레벨을 코드화해서 숫자로 넣어보자. 범위가 작은 숫자로 관리하면 DB 용량도 적게 차지하고 가벼워서 좋다.
그렇다면 자바에서는 어떻게 표현할까?

##### 숫자로 표현
아래 처럼 상수 값을 정해놓고 int 타입으로 레벨을 사용한다고 해보자.
~~~java
class User {
  private static final int BASIC = 1;
  private static final int SILVER = 2;
  private static final int GOLD = 3;

  int level;

  public void setLevel(int level) {
    this.level = level;
  }
}
~~~

BASIC, SILVER, GOLD처럼 의미 있는 상수도 정의해놨으니 아래처럼 코드로 작성할 수 있다.
~~~java
if(user1.getLevel() == User.BASIC) {
  user1.setLevel(User.SILVER);
}
~~~
문제는 level의 타입이 int이기 때문에 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다는 점이다. 1,2,3 이외의 숫자가 들어가면 기능은 문제없이 돌아가는 것처럼 보이지만 심각한 **버그** 가 만들어진다.

~~~java
user1.setLevel(other.getSum());
user1.setLevel(1000);// 범위를 벗어나는 값을 넣을 가능성
~~~
그래서 자바5 이상에서 제공하는 이늄(enum)을 이용하는 게 안전하고 편리하다.

##### 이늄으로 표현
~~~java
public enum Level {
  BASIC(1), SILVER(2), GOLD(3); //세 개의 이늄 오브젝트 정의

  private final int value;

  Level(int value) {//DB에 저장할 값을 넣어줄 생성자를 만든다.
    this.value = value;    
  }

  public int intValue() {//값을 가져오는 메소드
    return value;
  }

  public static Level valueOf(int value) {//값으로부터 Level 타입 오브젝트를 가져오도록 만든 스태틱 메소드
    switch(value) {
      case 1: return BASIC;
      case 2: return SILVER;
      case 3: return GOLD;
      default: throw new AssertionError("Unknown value: " + value);
    }
  }
}
~~~
이렇게 만든 Level 이늄은 내부에는 DB에 저장할 int 타입의 값을 갖고 있지만, 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다. user1.setLevel(1000)과 같은 코드는 컴파일러가 타입이 일치하지 않는다는 에러를 내면서 걸러줄것이다.

#### User 필드 추가
Level 타입의 변수를 아래처럼 User 클래스에 추가하자. 사용자 레벨 관리 로직에서 필요한 로그인 횟수와 추천수도 추가하자.
~~~java
public class User {
  ...
  Level level;
  int login;
  int recommend;

  public Level getLevel() {
    return level;
  }

  public void setLevel(Level level) {
    this.level = level;
  }
  ...

  // login, recommend getter/setter
}
~~~

그리고 DB의 USER 테이블에도 아래처럼 필드를 추가한다.
|필드명   |타입   |설정   |
|---|---|---|
|Level   |tinyint   |Not Null   |
|Login   |int   |Not Null   |
|Recommend   |int   |Not Null   |

#### UserDaoTest 테스트 수정
UserDaoJdbc와 테스트에도 필드를 추가해야 한다. 먼저 테스트 픽스처로 만든 user1, user2, user3에 아래처럼 새로 추가된 새 필드의 값을 넣는다.

~~~java
public class UserDaoTest {
  ...
  @Before
  public void setUp() {
    this.user1 = new User("syntax", "김문법", "syntax01", Level.BASIC, 1, 0);
    this.user2 = new User("tree", "김나무", "syntax02", Level.SILVER, 55, 10);
    this.user3 = new User("rogue", "김도둑", "syntax03", Level.Gold, 100, 40);
  }
}
~~~
이에 맞게 User 클래스 생성자도 추가해준다.
~~~java
class User {
  ...
  public User(String id, String name, String password, Level level, int login, int recommend) {
    this.id = id;
    this.name = name;
    this.password = password;
    this.level = level;
    this.login = login;
    this.recommend = recommend;
  }
}
~~~
다음은 UserDaoTest 테스트에서 두 개의 User 오브젝트 필드 값이 모두 같은지 비교하는 checkSameUser() 메소드를 수정하자 아래처럼 새로운 필드를 비교하는 코드를 추가한다.
~~~java
private void checkSameUser(User user1, User user2) {
  assertThat(user1.getId(), is(user2.getId()));
  assertThat(user1.getName(), is(user2.getName()));
  assertThat(user1.getPassword(), is(user2.getPassword()));
  assertThat(user1.getLevel(), is(user2.getLevel()));
  assertThat(user1.getLogin(), is(user2.getLogin()));
  assertThat(user1.getRecommend(), is(user2.getRecommend()));
}
~~~

기존의 addAndGet() 테스트에서는 checkSameUser() 메소들르 사용하지 않고 테스트 메소드에서 직접 assertThat()을 사용했다. 하지만 앞으로 추가되거나 변경돼도 User 오브젝트를 비교하는 로직을 일정하게 유지할 수 있도록 checkSameUser()를 아래처럼 수정하자.

~~~java
@Test
public void addAndGet() {
  ...
  User userget1 = dao.get(user1.getId());
  checkSameUser(userget1, user1);

  User userget2 = dao.get(user2.getId());
  checkSameUser(userget2, user2);
}
~~~
테스트 준비는 다 됐으니, 테스트 대상인 UserDaoJdbc를 수정하자.

#### UserDaoJdbc 수정
등록을 위한 INSERT 문장이 들어 있는 add() 메소드의 SQL과 각종 조회 작업에 사용되는 User 오브젝트 매핑용 콜백인 userMapper에 추가된 필드를 넣자.

~~~java
public class UserDaoJdbc implements UserDao {
  ...
  private RowMapper<User> userMapper =
    new RowMapper<User>() {
      public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();

        user.setId(rs.getStrign("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        user.setLevel(Level.valueOf(rs.getInt("level")));
        user.setLogin(rs.getInt("loign"));
        user.setRecommend(rs.getInt("recommend"));

        return user;
      }
    };

  public void add(user user) {
    this.jdbcTemplate.update(
      "insert into users(id, name, password, level, login, recommend) " +
      "values(?, ?, ?, ?, ?, ?)", user.getId(), user.getName(),
      user.getPassword(), user.getLevel().intValue(),
      user.getLogin(), user.getRecommend());
  }
}
~~~
여기서 눈여겨볼 곳은 Level 타입의 level 필드를 사용하는 부분이다. Level 이늄은 오브젝트이므로 DB에 저장될 수 없는 SQL 타입이다. 따라서 DB에 저장 가능한 정수형 값으로 변환해줘야 한다. 따라서 user.getLevel().intValue()로 미리 정의해둔 정수형 값으로 변환하여 넣어 줬다.

반대로 조회를 했을 경우는 DB에서 int값을 가지고와 Level.valueOf()를 이용해 Level 타입의 이늄 오브젝트로 만들어서 setLevel() 메소드에 넣어줘야 한다.

테스트를 해보면 아래와 같은 에러가 뜬다.
org.springframework.jdbc.BadSqlGrammarException: PreparedStatementCallback; .... Column 'loign' not found

예외를 보면 login을 loign이라고 잘못 쓴것임을 알 수 있다. JDBC가 사용하는 SQL은 컴파일 과정에서는 자동으로 검증이 되지 않는 단순 문자열에 불과하다. 따라서 SQL 문장이 완성돼서 DB에 전달되기 전까지는 문법 오류나 오타를 발견하기 힘들다. 미리미리 DB까지 연동되는 테스트를 만들었기 때문에 SQL 문장에서 오타가 있음을 빠르게 잡을수 있었다.

만약 테스트가 없는 채로 사용자 정보에 새로운 필드가 추가됐다면 어땠을까? 코드를 빌드하고 서버에 올려서 누군가 사용자의 정보를 읽고 쓰는 기능을 사용하기 전까지는 발견하기 힘들 것이다. 따라서 그때까지 진행한 빌드와 서버 배치, 서버 재시작, 수동 테스트 등에 소모한 시간이 낭비가 되는 것이다. 그만큼 테스트는 중요하다.

### 사용자 수정 기능 추가
사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 기본키인 id를 제외한 나머지 필드는 수정될 가능성이 있다. 수정할 정보가 담긴 User 오브젝트를 전달하면 id를 참고해서 사용자를 찾아 필드 정보를 UPDATE 문을 이용해 모두 변경해주는 메소드를 하나 만들자.

#### 수정 기능 테스트 추가
만들어야 할 코드의 기능을 생각해볼 겸 아래와 같은 테스트를 작성하자.
~~~java
@Test
public void update() {
  dao.deleteAll();

  dao.add(user1);

  user1.setName("김광현");
  user1.setPassword("khpw01");
  user1.setLevel(Level.GOLD);
  user1.setLogin(1000);
  user1.setRecommend(999);
  dao.update(user1);

  User user1update = dao.get(user1.getId());
  checkSameUser(user1, user1update);
}
~~~
픽스처 오브젝트를 하나 등록하고 id를 제외한 필드의 내용을 바꾼뒤 update()를 호출한다. 이후 id로 조회하고 나온 오브젝트와 픽스처 오브젝트를 비교하면 된다.

#### UserDao와 UserDaoJdbc 수정
이제는 UserDao 인터페이스에 update() 메소드가 없다고 에러가 뜰 것이다. 우선 인터페이스에 메소드를 추가하자.
~~~java
public interface UserDao {
  ...
  public void update(User user1);
}
~~~

인터페이스에 추가하고 나면 이제는 UserDaoJdbc차례다. 아래와 같이 구현하자.
~~~java
public void update(User user) {
  this.jdbcTemplate.update(
    "update users set name = ?, password = ?, level = ?, login = ?, " +
    "recommend = ? where id = ? ", user.getName(), user.getPassword(),
    user.getLevel().intValue(), user.getLogin(), user.getRecommend(), user.getId());
}
~~~
이제 테스트를 돌려보면 성공할 것이다.

#### 수정 테스트 보완
테스트를 성공했으니 만족하고 넘어갈 수도 있지만 항상 테스트에 뭔가 불만을 가지고 의심스럽게 코드를 살펴보자. JDBC 개발에서 리소스 반환과 같은 기본 작업 다음으로 실수가 많이 일어나는 곳은 SQL 문장이다. SQL 키워드를 잘못 입력한 경우라면 테스트를 통해 에러가 나니 확인이 쉽지만, 위의 update() 테스트같은 경우 처럼 검증 못하는 오류가 날 수도있다.

만약 SQL문장에서 WHERE절이 없다면? 모든 로우에 업데이트가 일어나는 문제가 발생하지만, 이 테스트로는 검증할 수 없다.

이 문제를 해결할 방법을 생각해보자.
첫 번째 방법은 JdbcTemplate의 update()가 돌려주는 리턴 값을 확인하는 것이다. JdbcTemplate의 update()는 UPDATE나 DELETE 같이 테이블의 내용에 영향을 주는 SQL을 실행하면 영향받은 로우의 개수를 돌려준다. 이 정보를 이용하는 것이다.

두 번째 방법은 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 직접 확인하는 것이다.

아래는 두 번째 방법으로 테스트를 보완한 것이다.
~~~java
@Test
public void update() {
  dao.deleteAll();

  dao.add(user1);
  dao.add(user2);

  user1.setName("김광현");
  user1.setPassword("khpw01");
  user1.setLevel(Level.GOLD);
  user1.setLogin(1000);
  user1.setRecommend(999);

  dao.update(user1);

  User user1update = dao.get(user1.getId());
  checkSameUser(user1, user1update);
  User user2same = dao.get(user2.getId());
  checkSameUser(user2, user2same);
}
~~~
update() 메소드의 SQL에서 WHERE절을 빼먹었다면 이 테스트는 실패할 것이다. 사용자 정보를 수정하는 기능을 추가했으니 이제 본격적으로 사용자 관리 비즈니스 로직을 구현해보자.

### UserService.upgradeLevels()
레벨 관리 기능은 UserDao의 getAll() 메소드로 사용자를 다 가져와서 레벨 업그레이드 작업을 진행하면서 UserDao의 update()를 호출해 DB에 결과를 넣어주면 된다.

그렇다면 사용자 관리 로직은 어디에 두는 것이 좋을까? UserDaoJdbc는 적당하지 않다. DAO는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비지니스 로직을 두는 곳이 아니다. 사용자 관리비즈니스 로직을 담을 클래스를 하나 추가하자. UserService로 이 클래스는 인터페이스 타입으로 userDao 빈을 DI 받아 사용하게 만든다.

UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야 한다. 데이터 액세스 로직이 바뀌었다고 비즈니스 로직 코드를 수정하는 일이 있어서는 안 된다. 따라서 DAO의 인터페이스를 사용하고 DI를 적용해야 한다. 그리고 UserService를 위한 테스트 클래스도 하나 추가하자.

~~~
+---------------+        +-----------+          +---------+
|UserServiceTest|        |UserService|          |I)UserDao|
+---------------|------->+-----------|--------->+---------+
|               |        |           |          |         |
+---------------+        +-----------+          +----+----+
                                                     △
                                             +-------+--------+
                                             |                |
                                      +------+----+     +-----+----+
                                      |UserDaoJdbc|     |UserDaoJpa|
                                      +-----------+     +----------+
                                      |           |     |          |
                                      +-----------+     +----------+
~~~

#### UserService 클래스와 빈 등록
UserService 클래스를 만들고 사용할 UserDao 오브젝트를 저장할 인스턴스 변수를 선언하자.
~~~java
public class UserService {
  UserDao userDao;

  public void setUserDao(UserDao userDao) {
    this.userDao = userDao;
  }
}
~~~

스프링 설정파일에 userService 빈을 추가하고 userDao 빈을 DI받도록 프로퍼티를 추가하자.
~~~xml
<bean id="userService" class="springbook.user.service.UserService">
  <property name="userDao" ref="userDao" />

<bean id="userDao" class="springbook.dao.UserDaoJdbc">
  <property name="dataSource" ref="dataSource" />
</bean>
~~~

#### UserServiceTest 테스트 클래스
다음은 테스트 클래스를 추가하고 UserService 빈을 제공 받을 수 있도록 @Autowired가 붙은 인스턴스 변수로 선언하자.
~~~java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/test-applicationContext.xml")
public class UserServiceTest {
  @Autowired
  UserService userService;
}
~~~
JUnit 테스트로 실행해보면 테스트 메소드가 하나도 없다고 에러가 뜰 것이다. 간단히 userService 빈이 생성돼서 userService 변수에 주입되었는지만 확인해보자.
~~~java
@Test
public void bean() {
  assertThat(this.userService, is(notNullValue()));
}
~~~
테스트가 성공적으로 성공할 것이다. 이 테스트는 다른 메소드를 생성하면 삭제하도록 하자.

#### upgradeLevels() 메소드
로직을 추가할 준비는 끝났고 사용자 레벨 관리 기능을 먼저 만들고 테스트를 만들어보자.
앞에서 살펴본 로직을 보고 구현하면 아래와 같은 메소드로 만들수 있다.
~~~java
public void upgradeLevels() {
  List<User> users = userDao.getAll();
  for(User user : users) {
    Boolean changed = null;
    if(user.getLevel() == Level.BASIC && user.getLogi() >= 50) {
      user.setLevel(Level.SILVER);
      changed = true;
    }
    else if(user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
      user.setLevel(Level.GOLD);
      changed = true;
    }
    else if(user.getLevel() == Level.GOLD) {
      changed = false;
    }
    else {
      changed = false;
    }

    if(changed)
      userDao.update(user);
  }
}
~~~
비즈니스 로직이 들어가니 조건문도 많이 나오고 코드가 조금 복잡해 보인다. 뛰어난 개발자라면 아무리 간단해 보여도 실수할 수 있음을 알고 있기 때문에 테스트를 만들어서 직접 동작하는 모습을 확인해보려고 할 것이다.

#### upgradeLevels() 테스트
테스트 방법을 생각해보자. 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다. 사용자 레벨은 세 가지가 있고, 변경이 일어나지 않는 GOLD를 제외한 나머지 두 가지는 업그레이드가 되는 경우와 아닌 경우가 있을 수 있으므로 최소한 다섯 가지 경우를 살펴봐야 한다. 다섯 종류의 사용자를 등록하고 업그레이드를 진행한 후에 예상한 대로 경과가 나오는지 확인해보자.

텍스트 픽스쳐의 개수가 UserDaoTest에서보다 많아졌으니 이번에는 리스트를 아래처럼 이용해보자.
~~~java
class UserServiceTest {
  ...
  List<User> users; //테스트 픽스쳐

  @Before
  public void setUp() {
    users = Arrays.asList(
      new User("kkh01", "김공일", "p1", Level.BASIC, 49, 0),
      new User("kkh02", "김공이", "p2", Level.BASIC, 50, 0),
      new User("kkh03", "김공삼", "p3", Level.SILVER, 60, 29),
      new User("kkh04", "김공사", "p4", Level.SILVER, 60, 30),
      new User("kkh05", "김공오", "p5", Level.GOLD, 100, 100)
    );
  }
}
~~~
테스트에 사용할 데이터를 경계가 되는 값의 전후로 선택하여 등록하는 것이 좋다.
이제 테스트를 만들어보자.
~~~java
@Test
public void upgradeLevels() {
  userDao.deleteAll();
  for(User user : users)
    userDao.add(user);

  userService.upgradeLevels();

  checkLevel(users.get(0), Level.BASIC);
  checkLevel(users.get(1), Level.SILVER);
  checkLevel(users.get(2), Level.SILvER);
  checkLevel(users.get(3), Level.GOLD);
  checkLevel(users.get(4), Level.GOLD);
}

private void checkLevel(User user, Level expectedLevel) {
  User userUpdate = userDao.get(user.getId());
  assertThat(userUpdate.getLevel(), is(expectedLevel));
}
~~~
테스트는 문제없이 성공할 것이다.

### UserService.add()
사용자 관리 비즈니스 로직에서 대부분은 구현했지만, 하나 빠진것이 있다. 처음 가입하는 사용자는 기본적으로 BASIC 레벨이어야 한다는 부분이다.

이 로직은 어디에 담는 것이 좋을까?

UserDaoJdbc의 add() 메소드는 적합하지 않다, UserDaoJdbc는 주어진 User 오브젝트를 DB에 저장하는 방법에만 관심을 가져야 한다. 비즈니스 로직을 책임지는 것은 바람직하지 않다.

User 클래스에서 아예 level 필드를 BASIC으로 초기화하는 것은 어떨까? 이 방법은 처음 가입할 때를 제외하면 무의미한 정보가 되니 문제가 있어 보인다.

사용자 관리에 대한 비즈니스 로직을 담고 있는 UserService에 이 로직을 넣는건 어떨까? UserDao의 add() 메소드는 사용자 정보를 담은 User 오브젝트를 받아서 DB에 넣어주는 데 충실한 역할을 한다면, UserService에도 add()를 만들어두고 사용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하게 하면 될 것이다.

이번엔 테스트부터 만들어보자. 검증할 기능은 UserService의 add()를 호출하면 레벨이 BASIC으로 설정되는 것이다. 그런데 UserService의 add()에 전달되는 User 오브젝트가 이미 level 필드에 값이 설정되어 있는 경우는 어떻게 해야할까? 정하기 나름이긴 하지만, 우선 level의 값이 비어 있는 경우 로직을 따라서 BASIC을 부여하고, 미리 설정된 레벨을 가진 User 오브젝트는 그대로 두면 된다.

테스트 케이스는 두 종류를 만들면 된다. 레벨이 미리 정해진 경우와 레벨이 비어 있는 경우. 사용자의 레벨이 변경됐는지 확인하는 방법은 두가지가 있다. UserService의 add() 메소드를 호출할 때 파라미터로 넘긴 User 오브젝트에 level 필드를 확인해보는 것이고, 다른 하나는 UserDao의 get() 메소드를 이용해서 DB에 저장된 User 정보를 가져와 확인하는 법이다. UserService는 UserDao를 통해DB에 사용자 정보를 저장하기 때문에 이를 확인해보는 게 가장 확실한 방법이다. UserService가 UserDao를 제대로 사용하는지도 함께 검증할 수 있고, 디폴트 레벨 설정 후에 UserDao를 호출하는지도 검증되기 때문이다. add() 메소드의 테스트는 아래와 같다.

~~~java
@Test
public void add() {
  userDao.deleteAll();

  User userWithLevel = users.get(4); // GOLD
  User userWithoutLevel = users.get(0);
  userWithOutLevel.setLevel(null);

  userService.add(userWithLevel);
  userService.add(userWithoutLevel);

  User userWithLevelRead = userDao.get(userWithLevel.getId());
  User userWithoutLevelRead = userDao.get(userWithoutLevel.getId());

  assertThat(userWithLevelRead.getLevel(), is(userWithLevel.getLevel()));
  assertThat(userWithoutLevelRead.getLevel(), is(userWithoutLevel.getLevel()));
}
~~~

레벨이 이미 설정됐던 것은 그대로 유지되어 있어야 하고, 레벨이 없던 것은 디폴트인 BASIC으로 설정됐는지 확인해준다. 이제는 테스트가 성공하도록 코드를 구현해보자.

~~~java
public void add(User user) {
  if(user.getLevel() == null)
    user.setLevel(Level.BASIC);

  userDao.add(user);
}
~~~
테스트를 돌리면 성공할 것이다. 다만 테스트가 조금 복잡한 것이 흠인데, 간단한 비즈니스 로직을 담은 코드를 테스트하기 위해 DAO와 DB까지 모두 동원되는 점이 조금 불편하다. 이런 테스트를 깔끔하고 간단하게 만드는 법은 이후에 다뤄보자.


### 코드 개선
비즈니스 로직의 구현을 마쳤다. 하지만 깔끔한 코드를 추구하기 위해 다시 한번 검토해보자. 다음과 같은 질문을 해보자.
- 코드에 중복된 부분은?
- 코드가 무엇을 하는 것인지 이해하기 불편한가?
- 코드가 자신이 있어야 할 자리에 있는가?
- 변경이 일어난다면 어떤 것이 있을 수 있고, 변화에 쉽게 대응할 수 있게 작성됐는가?

#### upgradeLevels() 메소드 코드의 문제점
upgradeLevels() 메소드를 살펴보면 몇 가지 문제점이 보인다.
1. for 루프 속에 들어 있는 if/else if/else 블록이 읽기 불편하다.
2. 플래그를 두고 이를 변경하고 마지막에 이를 확인해서 업데이트 하는 방식도 깔끔해보이지 않는다.

코드가 깔끔해 보이지 않는 이유는 성격이 다른 여러 가지 로직이 한데 섞여있끼 때문이다.
~~~java
if(user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
  user.setLevel(Level.SILVER);
  changed = true;
}
...

if(changed)
  userDao.update(user);
~~~
1. user.getLevel() == Level.BASIC은 현재 레벨이 무엇인지 파악하는 로직이며,
2. user.getLogin() >= 50 은 업그레이드 조건을 담은 로직이다.
3. user.setLevel(Level.SILVER); 는 다음 단계의 레벨이 무엇이며 업그레이드를 위한 작업은 어떤 것인지가 담겨있다.
4. changed = true; 이 자체로는 의미가 없고 단지 멀리 떨어져있는 if(changed) {}의 작업이 필요한지를 알려주기 위한 임시 플래스 값이다.

이처럼 관련이 있어 보이지만 사실은 성격이 다른 것들이 섞여 있거나 분리돼서 나타나는 구조로 볼 수 있다.

이런 if 조건 블록이 레벨 개수만큼 반복된다. 새로운 레벨이 추가된다면 Level 이늄도 수정해야 하고, upgradeLevels()의 레벨 업그레이드 로직을 담은 코드에 if 조건식과 블록을 추가해줘야 한다. 업그레이드 조건이 복잡해지거나 업그레이드 작업에서 하는 일이 많아진다면 갈수록 이해하기 힘들고 관리하기 힘들어진다.

현재 레벨과 업그레이드 조건을 동시에 비교하는 부분도 문제가 될 수 있다. BASIC이면서 로그인 횟수가 50이 되지 않는 경우는 마지막 else 블록으로 이동한다. 새로운 레벨이 추가돼도 역시 기존 if 조건들에 맞지 않을 테니 else 블록으로 이동할 것이다. 성격이 다른 두 가지 경우가 모두 한 곳에서 처리되는 것은 뭔가 이상하다. 제대로 만들려면 조건을 두 단계에 걸쳐서 비교해야 한다. 첫 단계에서는 레벨을 확인하고 각 레벨별로 다시 조건을 판당하는 조건식을 넣어야 한다. 이렇게 만들면 지금보다 깔끔하게 예외적인 상황을 분리해서 처리할 수 있겠지만 코드는 훨씬 더 복잡해질 것이다.

아직은 별로 복잡해 보이지 않고, 주어진 비즈니스 로직을 잘 처리하는 코드인 듯 보이지만 사실 따져보면 상당히 변화에 취약하고 다루기 함든 코드임을 알 수 있다. 문제점이 뭔지 따져보고 설명하는 것조차 힘들다.

#### UpgradeLevels() 리팩토링
가장 먼저 추상적인 레벨에서 로직을 작성해보자. 기존의 upgradeLevels() 메소드는 자주 변경될 가능성이 있는 구체적인 내용이 추상적적인 로직의 흐름과 함께 섞여 있다. 레벨을 업그레이드하는 작업의 기본 흐름만 아래와 같이 먼저 만들어보자. 구체적인 구현에서 외부에 노출할 인터페이스를 분리하는 것과 마찬가지 작업이라고 생각하면 된다.

~~~java
// 기본 작업 흐름만 남겨둔 upgradeLevel()
public void upgradeLevels() {
  List<User> users = userDao.getAll();
  for(User user : users) {
    if(canUpgradeLevel(user)) {
      upgradeLevel(user);
    }
  }
}
~~~
모든 사용자 정보를 가져와 한 명씩 업그레이드가 가능한지 확인하고, 가능하다면 업그레이드를 한다. 참 간단하지 않은가? 구체적인 내용은 모르겠지만 upgradeLevels() 메소드가 어떤 작업을 하는지는 쉽게 이해할 수 있다.

이제 하나씩 구체적인 내용을 담은 메소드를 만들면 된다.

먼저 업그레이드가 가능한지를 알려주는 메소드인 canUpgradeLevel() 메소드를 살펴보자. user에 대해 업그레이드가 가능하면 true, 아니면 false를 리턴하면 된다.

~~~java
private boolean canUpgradeLevel(User user) {
  Level currentLevel = user.getLevel();
  switch(currentLevel) {
    case BASIC: return (user.getLogin() >= 50);
    case SILVER: return (user.getRecommend() >= 30);
    case GOLD: return false;
    degault: throw new IllegalArgumentException("Unknown level: " + currentLevel);
  }
}
~~~
상태에 따라서 업그레이드 조건만 비교하면 되므로, 역할과 책임이 명료해진다.

새로운 레벨이 추가됐지만 업그레이드 로직을 추가하지 않았다면 예외가 발생할 테니 쉽게 확인할 수 있다.

다음은 업그레이드 조건을 만족했을 경우 구체적으로 무엇을 할 것인가를 담고 있는 upgradeLevel() 메소드를 만들어보자. 레벨 업그레이드를 위한 작업은 사용자의 레벨을 다음 단계로 바꿔주는 것과 변경사항을 DB에 업데이트해주는 것이다. 업그레이드 작업용 메소드를 따로 분리해두면 나중에 작업 내용이 추가되더라도 어느 곳을 수정해야 할지가 명확해진다는 장점이 있다.

~~~java
private void upgradeLevel(User user) {
  if(user.getLevel() == Level.BASIC) user.setLevel(Level.SILVER);
  else if(user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
  userDao.update(user);
}
~~~

이 메소드는 사용자의 레벨을 다음 단계로 변경하고 DB에 업데이트하는 두 가지 작업을 한다. 테스트도 통과한다. 그런데 upgradeLevel() 메소드 코드가 마음에 들지 않는다. 다음 단계가 무엇인가 하는 로직과 그때 사용자 오브젝트의 level 필드를 변경해준다는 로직이 함께 있는데다, 너무 노골적으로 드러나 있다. 또한 예외상황에 대한 처리도 없다. 만약 업그레이드 조건을 잘못 파악해서 더 이상 다음 단계가 없는 GOLD 레벨을 처리한다면 아무 처리도 하지 않고 DB에 업데이트 작업만 일어날 것이다. 레벨이 늘어나면 if 문이 점점 길어질 것이고, 레벨 변경 시 사용자 오브젝트에서 level 필드 외의 값도 같이 변경해야 한다면 if 조건 뒤에 붙는 내용도 점점 길어질 것이다.

그러니 이것도 더 분리해보자.
레벨의 순서와 다음 단계 레벨이 무엇인지를 결정하는 일은 Level에게 맡기자. 레벨의 순서를 굳이 UserService에 담아둘 이유가 없다.
~~~java
public enum Level {
  GOLD(3, null), SILVER(2, GOLD), BASIC(1, SILVER);

  private final int value;
  private final Level next;

  Level(int value, Level next) {
    this.value = value;
    this.next = next;
  }

  public int intValue() {
    return value;
  }

  public Level nextLevel() {
    return this.next;
  }

  public static Level valueOf(int value) {
    switch(value) {
      case 1: return BASIC;
      case 2: return SILVER;
      case 3: return GOLD;
      default: throw new AssertionError("Unknown value: " + value);
    }
  }
}
~~~
Level 이늄에 next라는 다음 단계 레벨 정보를 담을 수 있도록 필드를 추가하고, 현재 레벨의 다음 레벨을 가져올 수 있도록 nextLevel() 메소드도 추가해주자. 이렇게 해주면 다음 단계의 레벨이 무엇인지를 일일이 if 조건식으로 만들어서 비즈니스 로직에 담아둘 필요가 없다.

이번엔 사용자 정보가 바뀌는 부분을 UserService 메소드에서 User로 옮겨보자. User의 내부 정보가 변경되는 것은 UserService 보다는 User가 스스로 다루는 게 적절하다. User는 사용자 정보를 담고 있는 단순한 자바빈이지만 User도 엄연히 자바 오브젝트이고 내부 정보를 다루는 기능이 있을 수 있다. UserService가 일일이 레벨 업그레이드 시에 User의 어떤 필드를 수정한다는 로직을 갖고 있기보다는, User에게 레벨 업그레이드를 해야 하니 정보를 변경하라고 요청하는 편이 낫다.

~~~java
public void upgradeLevel() {
  Level nextLevel = this.level.nextLevel();
  if(nextLevel == null) {
    throw new IllegalStateException(this.level + "은 업그레이드가 불가능합니다.");
  }
  else {
    this.level = nextLevel;
  }
}
~~~
UserService의 canUpgradeLevel() 메소드에서 업그레이드 기능 여부를 미리 판단해주기는 하지만, User 오브젝트를 UserService만 사용하는 건 아니므로 스스로 예외상황에 대한 검증 기능을 갖고 있는 편이 안전하다.
Level 이늄은 다음 레벨이 없는 경우에는 nextLevel()에서 null을 리턴하므로 이 경우에는 User의 레벨 업그레이드 작업이 진행돼서는 안되므로 예외를 던져야 한다. 애플리케이션의 로직을 바르게 작성한다면 일어나지 않겠지만 User 오브젝트를 잘못 사용하는 코드가 있다면 확인해줄 수 있으니 유용하다.

이와 같이 User에 업그레이드 작업을 담당하는 독립적인 메소드를 두고 사용할 경우, UserService는 User 오브젝트에게 알아서 업그레이드에 필요한 작업을 수행하라고 요청만 하면 되기 때문에, upgradeLevel()메소드는 아래처럼 간결해진다.

~~~java
private void upgradeLevel(User user) {
  user.upgradeLevel();
  userDao.update(user);
}
~~~
이전에 if 문장이 많이 들어 있던 코드보다 간결하고 작업 내용이 명확하게 드러나는 코드가 됐다. 각 오브젝트가 해야 할 책임도 깔끔하게 분리가 됐다.

개선한 코드를 살펴보면 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아 일을 하는 구조로 만들어졌음을 알 수 있다. UserService, User, Level이 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기면 이런 작업을 수행해달라고 서로 요청하는 구조다. 각자 자기 책임에 충실한 작업만 하고 있으니 코드를 이해하기도 쉽다. 또, 변경이 필요할 때 어디를 수정해야 할지도 쉽게 알 수 있다. 잘못된 요청이나 작업을 시도했을 때 이를 확인하고 예외를 던져줄 준비도 다 되어 있다. 각각을 독립적으로 테스트하도록 만들면 테스트 코드도 단순해진다.

객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를 갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기도 하다.

처음 구현했던 방식은 UserService의 upgradeLevels() 메소드는 User 오브젝트에서 데이터를 가져와서 그것을 가지고 User 오브젝트나 Level 이늄이 해야 할 작업을 대신 수행하고 직접 User 오브젝트의 데이터를 변경해버린다. 이보다는 UserService는 User에게 "레벨 업그레이드 작업을 해달라"고 요청하고, 또 User는 Level에게 "다음 레벨이 무엇인지 알려달라" 고 요청하는 방식으로 동작하는 것이 바람직하다.

이렇게 만들면 코드를 더 이해하기 쉽고 변화에 대응하기가 편하구나라고 생각하자.

#### User 테스트
User에 간단하지만 로직을 담은 메소드를 추가했으니, 테스트 코드를 만들어두자.

~~~java
public class UserTest {
  User user;

  @Before
  public void setUP() {
    user = new User();
  }

  @Test()
  public void upgradeLevel() {
    Level[] levels = Level.values();
    for(Level level : levels) {
      if(level.nextLevel() == null) continue;

      user.setLevel(level);
      user.upgradeLevel();
      assertThat(user.getLevel(), is(level.nextLevel()));
    }
  }

  @Test(expected = IllegalStateException.class)
  public void cannotUpgradeLevel() {
    Level[] levels = Level.values();
    for(level level : levels) {
      if(level.nextLevel() != null) continue;

      user.setLevel(level);
      user.upgradeLevel();
    }
  }
}
~~~
User 클래스에 대한 테스트는 굳이 스프링의 테스트 컨텍스트를 사용하지 않아도 된다. User 오브젝트는 스프링이 IoC로 관리해주는 오브젝트가 아니기 때문이다. @Autowired로 가져오는 대신 생성자를 호출해서 테스트할 User 오브젝트를 만들면 된다.

위를 보면 upgradeLevel() 테스트와 cannotUpgradeLevel() 테스트로 나눠뒀다. 이렇게 해두면 나중에 upgradeLevel() 메소드에 좀 더 복잡한 기능이 추가 됐을 때도 이 테스트를 확장해 사용할 수 있다.

#### UserServiceTest 개선
테스트도 개선해보자. 기존에는 checkLevel() 메소드를 호출할 때 일일이 다음 단계의 레벨이 무엇인지 넣어줬다. 하지만 이것도 중복으로 볼 수 있다. Level이 갖고 있어야 할 다음 레벨이 무엇인가 하는 정보를 테스트에 직접 넣어둘 이유가 없다. 이러면 레벨이 추가되거나 변경될때 테스트도 따라서 수정해야하니 번거롭다.

~~~java
//개선한 upgradedLevels() 테스트
@Test
public void upgradeLevels() {
  userDao.deleteAll();
  for(User user : users)
    userDao.add(user);

  userService.upgradeLevels();

  checkLevelUpgraded(users.get(0), false);
  checkLevelUpgraded(users.get(1), true);
  checkLevelUpgraded(users.get(2), false);
  checkLevelUpgraded(users.get(3), true);
  checkLevelUpgraded(users.get(4), false);
}

private void checkLevelUpgraded(User user, boolean upgraded) {
  User userUpdate = userDao.get(user.getId());
  if(upgraded) {
    //업그레이드가 일어났는지 확인한다. 다음레벨이 무엇인지는 Level에게서 가져온다.
    assertThat(userUpdate.getLevel(), is(user.getLevel().nextLevel()));
  }
  else {
    //업그레이드가 일어나지 않았는지 확인
    assertThat(userUpdate.getLevel(), is(user.getLevel()));
  }
}
~~~

기존의 upgradeLevels() 테스트 코드는 테스트 로직이 분명하게 드러나지 않는 것이 단점이었다. checkLevel()을 호출하면서 파라미터로 Level 이늄을 하나 전달하는데, 테스트 코드만 봐서는 그것이 업그레이드된 경우를 테스트하려는 것이지 쉽게 파악이 안 된다. 그에 반해 개선한 upgradeLevels() 테스트는 각 사용자에 대해 업그레이드를 확인하려는 것인지 아닌지가 좀 더 이해하기 쉽게 true, false로 나타나 있어서 보기 좋다. 또, 업그레이드됐을 때 어떤 레벨인지를 Level 이늄의 nextLevel()을 호출해보면 된다.

다음으로는 코드에 나타난 중복을 제거하자. 업그레이드 조건인 로그인 횟수와 추천 횟수가 애플리케이션 코드와 테스트 코드에 중복돼서 나타난다.

~~~java
//UserService
case BASIC: return (user.getLogin() >= 50);
// UserServiceTest
new User("kh01", "김광현", "p1", Level.BASIC, 50, 0)
~~~
테스트와 애플리케이션 코드에 나타난 어떤 숫자의 중복도 제거해줘야 할까? 라는 질문의 답은 무엇일까? **한 가지 변경 이유가 발생했을 때 여러 군데를 고치게 된다면 중복이다.** 이럴때 가장 좋은 방법은 정수형 상수로 변경하는 것이다.

우선 UserService를 아래와 같이 수정하자.
~~~java
public static final int MIN_LOGOUT_FOR_SILVER = 50;
public static final int MIN_RECOMMEND_FOR_GOLD = 30;

private boolean canUpgradeLevel(User user) {
  Level currentLevel = user.getLevel();
  switch(currentLevel) {
    case BASIC: return (user.getLogin() >= MIN_LOGCOUNT_FOR_SILVER);
    case SILVER: return (user.getRecommend() >= MIN_RECOMMEND_FOR_GOLD);
    case GOLD: return false;
    default: throw new IllegalArgumentException("Unknown Level: " + currentLevel);
  }
}
~~~

다음은 테스트도 아래와 같이 수정하자.
~~~java
import static springbook.user.service.UserService.MIN_LOGCOUNT_FOR_SILVER;
import static springbook.user.service.UserService.MIN_RECOMMEND_FOR_GOLD;

@Before
public void setUp() {
  users = Arrays.asList(
    // 테스트에서는 가능한 한 경계 값을 사용하는 것이 좋다.
    new User("kkh01", "김공일", "p1", Level.BASIC, MIN_LOGCOUNT_FOR_SILVER - 1, 0),
    new User("kkh02", "김공이", "p2", Level.BASIC, MIN_LOGCOUNT_FOR_SILVER - 1, 0),
    new User("kkh03", "김공삼", "p3", Level.SILVER, 60, MIN_RECOMMEND_FOR_GOLD - 1),
    new User("kkh04", "김공사", "p4", Level.SILVER, 60, MIN_RECOMMEND_FOR_GOLD - 1),
    new User("kkh05", "김공오", "p5", Level.GOLD, 100 , Integer.MAX_VALUE),

  )
}
~~~
숫자로만 되어 있는 경우에는 비즈니스 로직을 상세히 코멘트로 달아놓거나 설계문서를 참조하기 전에는 이해하기 힘들었던 부분이 이제는 무슨 의도로 어떤 값을 넣었는지 이해하기 쉬워졌다. 그리고 코드와 테스트 사이에서도 중복을 제거했기 때문에 업그레이드 조건 값이 바뀌는 경우에는 UserService의 상수 값만 변경해주면 된다.

## 트랜잭션 서비스 추상화
레벨 관리 기능도 구현과 테스트를 마쳤으나, 다음과 같은 궁금증이 생겼다. "정기 사용자 레벨 관리 작업을 수행하는 도중에 장애가 생겨 작업을 완료할 수 없다면, 변경된 사용자의 레벨을 그대로 둬야 할까? 아니면 이전 상태로 돌려 둬야 할까?" 여기서는 롤백하는 것으로 하자.

### 모 아니면 도
그렇다면, 지금까지 만든 사용자 레벨 업그레이드 코드는 어떻게 동작할까 한번 보자. 만약 모든 사용자에 대해 업그레이드 작업을 진행하다가 중간에 예외가 발생해서 작업이 중단된다면 어떻게 될까? 이미 변경된 사용자의 레벨은 작업 이전 상태로 돌아갈까? 아니면 바뀐 채로 남아 있을까?

테스트를 통해 확인해보자, 이 테스트는 조금 까다로운 것이, 예외적인 상황을 작업 중간에 강제로 발생시켜야 한다. 테스트의 기본은 자동화된 테스트여야 하니 테스트 도중 네트워크를 끊는다거나 DB를 다운시키는 등의 사람이 간섭하는 방법은 좋지 않다. 가장 좋은 것은 장애가 발생했을 때 일어나는 현상 중의 하나인 예외가 던져지는 상황을 의도적으로 만드는 게 낫다.

#### 테스트용 UserService 대역
그렇다면 작업 중간에 예외를 강제로 만들 수 있을까? 테스트를 위해 코드를 수정하는 것은 좋지 않으니, 테스트용으로 특별히 만든 UserService의 대역을 사용하는 방법이 좋다. 즉, UserService 대신 테스트 목적에 맞게 동작하는 클래스를 만들어 사용하는 것이다.

그렇다면 테스트용 UserService 확장 클래스는 어떻게 만들까? UserService를 복붙한 뒤 일부를 수정하는 것은 중복도 발생하고 번거로워 지므로, 간단히 UserService를 상속해서 일부 메소드를 오버라이딩하는 방법이 낫다.

이전의 테스트에서 5개의 테스트용 사용자 정보 중 두 번쨰와 네 번째가 업그레이드 대상이므로, 네 번째 사용자를 업그레이드 하는 도중에 예외를 발생시키고, 두 번째 사용자의 정보가 업데이트 됐는지 아닌지를 확인하면 된다.

먼저 테스트용으로 UserService를 상속한 클래스를 하나 만든다. 이때 위치는 테스트에서만 사용하므로 테스트 클래스 내부에 스태틱 클래스로 만드는 것이 좋다.

테스트용 UserService의 서브 클래스는 UserService의 기능을 오버라이딩해서 특정 시점에서 강제로 예외가 발생하도록 만들 것이다. 그런데 UserService의 메소드 대부분이 private 접근제한이 걸려 있어서 오버라이딩이 불가능하다. 테스트를 위해 애플리케이션 코드를 직접 수정하는 일은 피하는 것이 좋지만 이번은 예외로 진행하자.

테스트용 서브 클래스에서 오버라이딩할 메소드는 upgradeLevel() 메소드다. 따라서 이 메소드의 접근 권한을 private에서 protected로 변경하자.

~~~java
// 전
private void upgardeLevel(User user);
// 후
protected void upgradeLevel(User user);
~~~
이제 오버라이딩 가능하니 다음과 같이 스태틱 클래스를 테스트에 추가하자

~~~java
//UserService의 테스트용 대역 클래스
static class TestUserSerivce extends UserService {
  private String id;

  private TestUserService(String id) {
    this.id = id;
  }

  protected void upgradeLevel(User user) {
    if(user.getId().equals(this.id))
      throw new TestUserServiceException();

    super.upgradeLevel(user);
  }
}
~~~

그리고 다른 예외가 발생했을 경우와 구분하기 위해 테스트 목적을 띤 예외를 아래와 같이 정의하고 TestUserService와 마찬가지로 테스트 클래스 내에 스태틱 멤버 클래스로 만들어 두자.
~~~java
// 테스트용 예외
static class TestUserServiceException extends RuntimeException {
}
~~~

#### 강제 예외 발생을 통한 테스트
이제 테스트를 만들어보자.

~~~java
@Test
public void upgradeAllOrNothing() {
  UserService testUserService = new TestUserService(users.get(3).getId());
  testUserService.setUserDao(this.userDao);
  userDao.deleteAll();
  for(User user : users)
    userDao.add(user);

  try {
    testUserService.upgradeLevels();
    fail("TestUserServiceException expected");
  } catch(TestUserServiceException e) {
  }

  checkLevelUpgraded(users.get(1), false);
}
~~~
테스트용으로 만들어둔 TestUserService의 오브젝트를 만들자, 이때 생성자 파라미터로 사용자의 id를 넣어준다. 스프링 컨텍스트로부터 가져온 userDao를 테스트용 TestUserService에 수동으로 DI해준다. TestUserService는 upgradeAllOrNothing() 테스트 메소드에서만 특별한 목적으로 사용되는 것이니, 번거롭게 스프링 빈으로 등록할 필요는 없다. 컨테이너에 종속적이지 않은 평범한 자바 코드로 만들어지는 스프링 DI 스타일의 장점이 이런 점이다. UserDao를 DI 해주고 나면 testUserService 오브젝트는 스프링 설정에 의해 정의된 userService 빈과 동일하게 UserDao를 사용해 데이터 액세스 기능을 이용할 수 있다.

사용자 정보를 등록해주고, testUserService의 업그레이드 메소드를 실행시키자. 5개의 User를 가져와 차례로 업그레이드를 하다가 지정해둔 4번째 사용 오브젝트 차례가 되면 TestUserServiceException을 발생시킬 것이다. 혹시라도 테스트 코드를 잘못 작성해서 예외 발생없이 upgradeLevels() 메소드가 정상적으로 종료되면 fail() 메소드 때문에 테스트가 실패할 것이다. fail()은 테스트가 의도한 대로 동작하는지를 확인하기 위해 넣은 것이다.

TestUserServiceException을 잡은 후에는 checkLevelUpgraded() 메소드를 이용해 두 번째 사용자 레벨이 변경됐는지 확인한다. 네 번째 사용자를 처리하다가 예외가 발생해서 작업이 중단됐으니 이미 레벨을 수정했던 두 번째 사용자도 원래대로 돌아가는 상태일 것이다.

테스트를 돌려보면 다음과 같은 메세지를 출력하면서 테스트가 실패한다.
~~~
java.lang.AssertionError
Exception: is <BASIC>
got: <SILVER>
~~~
처리 중 예외가 발생했지만 이전 사용자의 변경 사항이 그대로 유지되고 있음을 볼 수 있다.

#### 테스트 실패의 원인
이렇게 된 이유는 트랜잭션 때문인데, DB와 JDBC 프로그래밍에 대해 지식이 있다면 이런 결과에 대한 예상을 할 수 있었을 것이다. 모든 사용자의 레벨을 업그레이드하는 작업인 upgradeLevels() 메소드가 하나의 트랜잭션 안에서 동작하지 않았기 때문이다. 트랜잭션이란 더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.

모든 사용자에 대한 레벨 업그레이드 작업은 새로 추가된 기술 요구사항대로 전체가 다 성공하든지 아니면 전체가 다 실패하든지 해야한다. 즉, 레벨 업그레이드 작업은 그 작업을 쪼개서 부분적으로 성공하기도 하고, 여러 번에 걸쳐서 진행할 수 있는 작업이 아니라, 더 이상 쪼개질 수 없는 작업이여야 한다. 이 작업도 더 이상 쪼개서 이뤄질 수 없는 원자와 같은 성질을 띤다. 따라서 중간에 예외가 발생해서 작업을 완료할 수 없다면 아예 작업이 시작되지 않은 것처럼 초기 상태로 돌려놔야 한다. 이것이 바로 트랜잭션이다.

upgradeLevels() 메소드의 작업은 이 하나의 작업 단위인 트랜잭션이 적용되지 않았기 때문에 새로 추가된 기술 요건을 만족하지 못하고, 이를 검증하기 위해 만든 테스트가 실패하는 것이다.

### 트랜잭션 경계설정
DB는 완벽한 트랜잭션을 지원한다. SQL을 이용해 다중 로우의 수정이나 삭제를 위한 요청을 했을 때 일부 로우만 삭제되고 나머지는 안 된다거나, 일부 필드는 수정했는데 나머지 필드는 수정이 안되고 실패로 끝나는 경우는 없다. 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다.

하지만 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우도 있다. 계좌이체라든가 이번 장에서 진행했던 사용자의 레벨 관리 배치작업등이 그렇다. 예를들어 계좌이체에는 적어도 DB출금계좌의 잔고를 수정하는 것과 입금계좌 레코드의 잔고를 수정해야 한다.

문제는 첫 번째 SQL을 성공적으로 실행했지만 두 번째 SQL이 성공하기 전에 장애가 생겨서 작업이 중단되는 경우다. 이럴 때는 첫번째 SQL 작업도 취소시켜야하는데, 이렇게 취소 하는 작업을 **트랜잭션 롤백** 이라고 한다. 여러개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시켜야 한다. 이것을 **트랜잭션 커밋** 이라고 한다.

#### JDBC 트랜잭션의 트랜잭션 경계설정
모든 트랜잭션언 시작하는 지점과 끝나는 지점이 있다. 시작하는 방법은 한 가지이지만 끝나는 방법은 두 가지다. 하나는 모든 작업을 무효화하는 롤백, 또 다른 하나는 모든 작업을 다 확정하는 커밋이다.

애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 트랜잭션의 경계라고 부른다. 아래는 JDBC를 이용해 트랜잭션을 적용하는 예제다.
~~~java
//트랜잭션을 사용한 JDBC 코드
Connection c = dataSource.getConnection();

c.setAutoCommit(false); //트랜잭션 시작
try {
  PreparedStatement st1 = c.prepareStatement("update users ...");
  st1.executeUpdate();

  PreparedStatement st2 = c.prepareStatement("delete users ...");
  st2.executeUpdate();
  c.commit(); // 트랜잭션 커밋
} catch(Exception e) {
  c.rollback(); // 트랜잭션 롤백
}

c.close();
//위에서 c.setAutoCommit(false); 코드에서부터 c.rollback();까지의 코드가 하나의 트랜잭션이 된다.
~~~
JDBC의 트랜잭션은 하나의 Connection을 가져와 사용하다가 다는 사이에서 일어난다. 트랜잭션을 시작하려면 자동커밋 옵션을 false로 만들어주면 된다. **JDBC의 기본 설정은 DB 작업을 수행한 직후에 자동으로 커밋이 되도록 되어 있다.**

트랜잭션이 한 번 시작되면 commit() 또는 rollback() 메소드가 호출될 때까지의 작업이 하나의 트랜잭션으로 묶인다. 이렇게 setAutoCommit(false)로 트랜잭션의 시작을 선언하고 commit() 또는 rollback()으로 트랜잭션을 종료하는 작업을 트랜잭션의 경계설정(transaction demarcation)이라고 한다. 트랜잭션의 경계는 하나의 Connection이 만들어지고 닫히는 범위 안에 존재한다는 점도 기억하자. 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 로컬 트랜잭션(local transaction)이라고도 한다.

#### UserService와 UserDao의 트랜잭션 문제
이제는 왜 UserService의 upgradeLevels()에 트랜잭션이 적용되지 않았는지 알 수 있다. JDBC의 트랜잭션 경계 설정 메소드는 모두 Connection 오브젝트를 사용하게 되어 있는데, JdbcTemplate을 사용하기 시작한 이후로 한번도 이 Connection 오브젝트를 볼 수 없었다.

JdbcTemplate은 직접 만들어 봤던 JdbcContext와 작업 흐름이 거의 동일하다. 하나의 템플릿 메소드 안에서 DataSource의 getConnection() 메소드를 호출해서 Connection 오브젝트를 가져오고, 작업을 마치면 Connection을 확실하게 닫아주고 템플릿 메소드를 빠져나온다. 결국 템플릿 메소드 호출 한 번에 한 개의 DB 커넥션이 만들어지고 닫히는 일까지 일어나는 것이다. 일반적으로 트랜잭션은 커넥션보다도 존재 범위가 짧다. 따라서 템플릿 메소드가 호출될 때마다 트랜잭션이 새로 만들어지고 메소드를 빠져나오기 전에 종료된다. 결국 JdbcTemplate의 메소드를 사용하는 UserDao는 각 메소드마다 하나씩의 독립적인 트랜잭션으로 실행될 수 밖에 없다.

앞에서 만든 upgradeAllOrNothing() 테스트 메소드에는 5개의 사용자 오브젝트를 가져와 순차적으로 업그레이드 가능성을 확인하다가 2번째 사용에서 레벨을 변경해서 UserDao의 update() 메소드를 호출한다. JdbcTemplate을 사용하는 UserDao의 update() 메소드는 자동으로 UPDATE 작업의 트랜잭션을 종료시킬 것이고, 수정 결과는 영구적으로 DB에 반영된다. 따라서 그 후에 예외가 발생하든, 서버가 다운되든 상관없이 그 두 번째 사용자의 레벨 업데이트 결과는 DB에 남아있는 것이다.

upgradeLevels()에서 세 번에 걸쳐 UserDao의 update()를 호출했다고 가정해보자. UserDao는 JdbcTemplate을 통해 매번 새로운 DB 커넥션과 트랜잭션을 만들어 사용한다. 따라서 첫 번째 update()를 호출할 때 작업이 성공했다면 그 결과는 이미 트랜잭션이 종료도면서 커밋됐기 때문에 두 번째 update()를 호출하는 시점에서 오류가 발생해서 작업이 중단된다고 해도 첫 번째 커밋한 트랜잭션의 결과는 DB에 그대로 남는다.

데이터 액세스 코드를 DAO로 만들어서 분리해놓았을 경우에는 이처럼 DAO 메소드를 호출할 때마다 하나의 새로운 트랜잭션이 만들어지는 구조가 될 수 밖에 없다. DAO 메소드 내에서 JDBC API를 직접 사용하든 JdbcTemplate을 이용하든 마찬가지다. DAO 메소드에서 DB 커넥션을 매번 만들기 때문에 어쩔 수 없이 나타나는 결과다. 결국 DAO를 사용하면 비즈니스 로직을 담고있는 UserService 내에서 진행되는 여러가지 작업을 하나의 트랜잭션으로 묶는 일이 불가능해진다.

그렇다면 upgradeLevels()와 같이 여러번 DB에 업데이트를 해야 하는 작업을 하나의 트랜잭션으로 만들려면 어떻게 해야 할까? 어떤 일련의 작업이 하나의 트랜잭션으로 묶이려면 그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다. 앞에서 설명한 것처럼 트랜잭션은 Connection 오브젝트 안에서 만들어지기 때문이다. 하지만 현재는 UserService에서 DB 커넥션을 다룰 수 있는 방법이 없다.

#### 비즈니스 로직 내의 트랜잭션 경계 설정
이 문제를 해결하기 위해 DAO 메소드 안으로 upgardeLevels() 메소드의 내용을 옮기는 방법을 생각해볼 수 있다. DAO 안에서 위에 있는 트랜잭션을 이용한 JDBC 코드 처럼 JDBC API를 직접 이용한다면 하나의 DB 커넥션과 트랜잭션을 만들어놓고 여러 명의 사용자에 대한 정보를 업데이트할 수 있다. 하지만 이 방식은 비즈니스 로직과 데이터 로직을 한데 묶어버리는 한심한 결과를 초래한다. 지금까지 성격과 책임이 다른 코드를 분리하고, 느슨하게 연결해서 확장성을 좋게 하려고 많은 노력을 해왔는데, 여기서 트랜잭션 문제를 해결하기 위해 JDBC API와 User의 업그레이드 정책을 담은 코드를 뒤죽박죽으로 만드는 건 안될일이다.

UserService와 UserDao를 그대로 둔 채로 트랜잭션을 적용하려면 결국 트랜잭션의 경계설정 작업을 UserService 쪽으로 가져와야 한다. 프로그램의 흐름을 볼 때 upgardeLevels() 메소드의 시작과 함께 트랜잭션이 시작하고 메소드를 빠져나올 때 트랜잭션이 종료돼야 하기 때문이다. UserDao가 가진 SQL이나 JDBC API를 이용한 데이터 액세스 코드는 최대한 그대로 남겨둔 채로, UserService에는 트랜잭션 시작과 종료를 담당하는 최소한의 코드만 가져오게 만들면 어느 정도 책임이 다른 코드를 분리해둔 채로 트랜잭션 문제를 해결 할 수 있다.

트랜잭션 경계를 upgradeLevels() 메소드 안에 두려면 DB 커넥션도 이 메소드 안에서 만들고, 종료시킬 필요가 있다. 결국 upgardeLevels() 메소드 안에 트랜잭션의 경계 설정을 아래와 같은 구조로 만들어야 한다.

~~~Java
//upgradeLevels의 트랜잭션 결계설정 구조
public void upgradeLevels() throws Exception {
  //(1) DB Connection 생성
  //(2) 트랜잭션 시작
  try {
    //(3) DAO 메소드 호출
    //(4) 트랜잭션 커밋
  } catch(Exception e) {
    //(5) 트랜잭션 롤백
    throw e;
  } finally {
    //(6) DB Connection 종료
  }
}
~~~
트랜잭션을 사용하는 전형적인 JDBC 코드의 구조다. 그러데 여기서 생성된 Connection 오브젝트를 가지고 데이터 액세스 작업을 진행하는 코드는 어쩔 수 없이 UserService로 가져왔지만, 순수한 데이터 액세스 로직은 UserDao에 둬야 하기 때문이다. UserDao의 update() 메소드는 반드시 upgardeLevels() 메소드에서 만든 Connection을 사용해야 한다. 그래야만 같은 트랜잭션 안에서 동작하기 때문이다. 기존의 JdbcTemplate처럼 매번 새로운 Connection 오브젝트를 만들어버리면, upgardeLevels() 안에서 시작한 트랜잭션과는 무관한 별개의 트랜잭션이 만들어지므로 주의해야 한다.

UserService에서 만든 Connection 오브젝트를 UserDao에서 사용하려면 DAO 메소드를 호출할 때마다 Connection 오브젝트를 파라미터로 전달해줘야 한다 결국 DAO메소드들은 아래처럼 변경돼야 할 것이다.


~~~Java
// Connection 오브젝트를 파라미터로 전달받는 UserDao 메소드
public interface UserDao {
  public void add(Connection c, User user);
  public User get(Connection c, String id);
  ...
  public void update(Connection c, User user);
}
~~~

트랜잭션을 담고 있는 Connection을 공유하려면 더 해줄 일이 있다. UserService의 upgardeLevels()는 UserDao의 update()를 직접 호출하지 않는다. UserDao를 사용하는 것은 사용자별로 업그레이드 작업을 진행하는 upgardeLevel() 메소드다. 결국 아래와 같이 UserService의 메소드 사이에도 같은 Connection 오브젝트를 사용하도록 파라미터로 전달해줘야만 한다.

~~~Java
//Connection을 공유하도록 수정한 UserService 메소드
class UserService {
  public void upgardeLevels() throws Exception {
    Connection c = ...;
    ...

    try {
      ...
      upgradeLevel(c, user);
      ...
    }
    ...
  }

  protected void upgardeLevel(Connection c, User user) {
    user.upgradeLevel();
    userDao.update(c, user);
  }
}

interface UserDao {
  public void update(Connection c, User user);
  ...
}
~~~

이렇게 Connection 오브젝트를 전달해서 사용하려면 UserService의 upgardeLevels() 안에서 시작한 트랜잭션에 UserDao의 메소드들도 참여하게 할 수 있다. upgardeLevels() 메소드 안에서 트랜잭션의 경계설정 작업이 일어나야 하고, 그 트랜잭션을 갖고 있는 DB 커넥션을 이용하도록 해야만 별도의 클래스에 만들어둔 DAO내의 코드도 트랜잭션이 적용될 테니 결국 이 방법을 사용할 수밖에 없다.

#### UserService 트랜잭션 경계설정의 문제점
UserService와 UserDao를 이런 식으로 수정하면 트랜잭션 문제는 해결할 수 있겠지만, 그 대신 여러 가지 새로운 문제가 발생한다.

첫째는 DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate을 더 이상 활용할 수 없다는 점이다. JDBC API를 직접 사용하는 초기 방식으로 돌아가야 한다. try/catch/finally 블록은 이제 UserService 내에 존재하고, UserService의 코드는 JDBC 작업 코드의 전형적인 문제점을 그대로 가질 수 밖에 없다.

두 번째 문제점은 DAO의 메소드와 비즈니스 로직을 담고 있는 UserService의 메소드에 Connection 파라미터가 추가돼야 한다는 점이다. upgradeLevels()에서 사용하는 메소드의 어딘가에서 DAO를 필요로 한다면, 그 사이의 모든 메소드에 걸쳐서 Connection 오브젝트가 계속 전달돼야 한다. UserService는 스프링 빈으로 선언해서 싱글톤으로 되어 있으니 UserService의 인스턴스 변수에 이 Connection을 저장해뒀다가 다른 메소드에서 사용하게 할 수도 없다. 멀티스레드 환경에서는 공유하는 인스턴스 변수에 스레드별로 생성하는 정보를 저장하다가는 서로 덮어쓰는 일이 발생하기 때문이다. 결국 트랜잭션이 필요한 작업에 참여하는 UserService의 메소드는 Connection 파라미터로 지저분해질 것이다.

세 번째 문제는 Connection 파라미터가 UserDao 인터페이스 메소드에 추가되면 UserDao는 더 이상 데이터 액세스 기술에 독립적일 수가 없다는 점이다. JPA나 하이버네이트로 UserDao의 구현 방식을 변경하려고 하면 Connection 대신 EntityManager나 Session 오브젝트를 UserDao 메소드가 전달받도록 해야 한다. 결국 UserDao 인터페이스는 바뀔 것이고, 그에 따라 UserService 코드도 함께 수정돼야 한다. 기껏 인터페이스를 사용해 DAO를 분리하고 DI를 적용했던 수고가 물거품이 되고 만 것이다.

마지막으로 DAO 메소드에 Connection 파라미터를 받게 하면 테스트 코드에도 영향을 미친다. 지금까지 DB 커넥션은 전혀 신경 쓰지 않고 테스트에서 UserDao를 사용할 수 있었는데, 이제는 테스트 코드에서 직접 Connection 오브젝트를 일일이 만들어서 DAO 메소드를 호출하도록 모두 변경해야 한다.

### 트랜잭션 동기화
비즈니스 로직을 담고 있는 UserService 메소드 안에서 트랜잭션의 경계를 설정해 관리하려면 지금까지 만들었던 깔끔하게 정리된 코드를 포기해야 할까? 아니면, 트랜잭션 기능을 포기해야 할까? 물론 스프링은 이 딜레마를 해결할 수 있는 멋진 방법을 제공해준다.

#### Connection 파라미터 제거
먼저 Connection을 파라미터로 직접 전달하는 문제를 해결해보자. upgradeLevels() 메소드가 트랜잭션 경계설정을 해야 한다는 사실은 피할 수 없다. 따라서 그 안에서 Connection을 생성하고 트랜잭션 시작과 종료를 관리하게 한다. 대신 여기서 생성된 Connection 오브젝트를 계속 메소드의 파라미터로 전달하다가 DAO를 호출할 때 사용하게 하는 건 피하고 싶다. 이를 위해 스프링이 제안하는 방법은 독립적인 트랜잭션 동기화(transaction synchronization)방식이다. 트랜잭션 동기화란 UserService에서 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 틀별한 저장소에 보관해두고, 이후에 호출되는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 하는 것이다. 정확히는 DAO가 사용하는 JdbcTemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것이다. 그리고 트랜잭션이 모두 종료되면, 그때는 동기화를 마치면 된다.


1. UserService는 Connection을 생성
2. 이를 트랜잭션 동기화 저장소에 저장하고 Connection의 setAutoCommit(false)를 호출해 트랜잭션을 시작시킨 후에 본격적으로 DAO의 기능을 이용
3. 첫 번째 update() 메소드가 호출되고 ,update() 메소드 내부에서 이요하는 JdbcTemplate 메소드에서는 가장먼저
4. 트랜잭션 동기화 저장소에 현재 시작된 트랜잭션을 가진 Connection 오브젝트가 존재하는지 확인하다. 2. upgradeLevels() 메소드 시작부분에서 저장해둔 Connection을 발견하고 이를 가져온다.
5. 가져온 Connection을 이용해 PreparedStatement를 만들어 수정 SQL을 실행한다. 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 때는 JdbcTemplate은 Connection을 닫지 않은 채로 작업을 마친다. 이렇게 해서 트랜잭션


트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 일어날 염려는 없다.

이렇게 트랜잭션 동기화 기법을 사용하면 파라미터를 통해 일일이 Connection 오브젝트를 전달할 필요가 없어진다. 트랜잭션의 경게설정이 필요한 upgradeLevels() 에서만 Connection을 다루게 하고, 여기서 생성된 Connection과 트랜잭션을 DAO의 JdbcTemplate이 사용할 수 있도록 별도의 저장소에 동기화하는 방법을 적용하기만 하면 된다. 더 이상 로직을 담은 메소드에 Connection 타입의 파라미터가 전달될 필요도 없고, UserDao의 인터페이스에도 일일이 JDBC 인터페이스인 Connection을 사용한다고 노출할 필요가 없다.

#### 트랜잭션 동기화 적용
문제는 멀티스레드 환경에서도 안전한 트랜잭션 동기화 방법을 구현하는 일이 기술적으로 간단하지 않다는 점인데, 다행히도 스프링은 JdbcTemplate과 더불어 이런 트랜잭션 동기화 기능을 지원하는 간단한 유틸리티 메소드를 제공하고 있다.

아래 코드는 트랜잭션 동기화 방법을 적용한 UserService 클래스의 코드이다.
~~~Java
private DataSource dataSource;

public void setDataSource(DataSource dataSource) {
  this.dataSource = dataSource;
}

public void upgradeLevels() throws Exception {
  TransactionSynchronizationManager.initSynchronization(); //트랜잭션 동기화 관리자를 이용해 동기화 작업을 초기화한다.
  Connection c = DataSourceUtils.getConnection(dataSource);
  c.setAutoCommit(false);

  try {
    List<User> users = userDao.getAll();
    for(User user : users) {
      if(canUpgradeLevel(user)) {
        upgradeLevel(user);
      }
    }
    c.commit();
  } catch(Exception e) {
    c.rollback();
    throw e;
  } finally {
    DataSourceUtils.releaseConnection(c, dataSource);
    TransactionSynchronizationManager.unbindResource(this.dataSource);
    TransactionSynchronizationManager.clearSynchronization();
  }
}
~~~

UserService에서 DB 커넥션을 직접 다룰 때 DataSource가 필요하므로 DataSource 빈에 대한 DI 설정을 해두야 한다.

스프링이 제공하는 트랜잭션 동기화 관리 클래스는 TransactionSynchronizationManager다. 이 클래스를 이용해 먼저 트랜잭션 동기화 작업을 초기화하도록 요청한다. 그리고 DataSourceUtils에서 제공하는 getConnection() 메소드를 통해 DB 커넥션을 생성한다. DataSource에서 Connection을 직접 가져오지 않고, 스프링이 제공하는 유틸리티 메소드를 쓰는 이유는 이 DataSourceUtils의 getConnection()메소드는 Connection 오브젝트를 생성해줄 뿐만 아니라 트랜잭션 동기화에 사용하도록 저장소에 바인딩해주기 때문이다.

동기화 준비가 됐으면 트랜잭션을 시작하고 DAO의 메소드를 사용하는 트랜잭션 내의 작업을 진행한다. 트랜잭션 동기화가 되어 있는 채로 JdbcTemplate을 사용하면 JdbcTemplate의 작업에서 동기화시킨 DB 커넥션을 사용하게 된다. 결국 UserDao를 통해 진행되는 모든 JDBC 작업은 upgradeLevels() 메소드에서 만든 Connection 오브젝트를 사용하고 같은 트랜잭션에 참여하게 된다. 작업을 정상적으로 마치면 트랜잭션을 커밋해준다. 그리고 스프링 유틸리티 메소드의 도움을 받아 커넥션을 닫고 트랜잭션 동기화를 마치도록 요청하면 된다. 만약 에러가 발생하면 트랜잭션을 롤백해준다. 이때도 DB 커넥션을 닫는 것과 동기화 작업 중단은 동일하게 진행해야 한다. JDBC의 트랜잭션 경계설정 메소드를 사용해 트랜잭션을 이용하는 전형적인 코드에 간단한 트랜잭션 동기화 작업만 붙여줌으로써, 지저분한 Connection 파라미터의 문제를 깔끔하게 해결했다.

#### 트랜잭션 테스트 보완
이제 트랜잭션이 적용됐는지 테스트를 해보자. 앞에서 만든 UserServiceTest의 upgradeAllOrNothing() 테스트에 아래와 같이 dataSource 빈을 가져와 주입해주는 코드를 추가해야 한다. 테스트용으로 확장해서 만든 TestUserService는 UserService의 서브클래스이므로 UserService와 마찬가지로 트랜잭션 동기화에 필요한 DataSource를 DI 해줘야 하기 때문이다.

~~~java
@Autowired DataSource dataSource;
...

@TestUserSerivce
public void upgradeAllOrNothing() throws Exception {
  UserService testUserService = new TestUserService(users.get(3).getId());
  testUserService.setUserDao(this.userDao);
  testUserService.setDataSource(this.dataSource);
  ...
}
~~~
upgradeAllOrNothing() 테스트를 다시 실행해보자. 이번엔 테스트가 성공할 것이다. 새로운 기술적인 요구사항에 맞게 사용자 레벨 업그레이드 작업에 트랜잭션이 적용됐다. 이제 모든 사용자의 레벨 업그레이드 작업을 완료하지 못하고 작업이 중단되면 이미 변경된 사용자의 레벨도 모두 원래 상태로 돌아갈 것이다.

나머지 테스트도 문제없이 동작하게 하려면 UserService의 dataSource 프로퍼티 설정을 아래와 같이 설정파일에 추가해줘야 한다. TestUserService를 직접 구성하는 upgradeAllOrNothing() 테스트와는 달리, upgradeLevels() 테스트는 스프링 컨테이너가 초기화한 userService를 사용해야 하기 때문이다.

~~~xml
//dataSource 프로퍼티를 추가한 userService 빈 설정
<bean id="userService" class="springbook.user.service.UserService">
  <property name="userDao" ref="userDao" />
  <property name="dataSource" ref="dataSource" />
</bean>
~~~

#### JdbcTemplate과 트랜잭션 동기화
한 가지 궁금한 점이 있다. JdbcTemplate의 동작방식이다. 지금까지 JdbcTemplate은 update()나 query() 같은 JDBC 작업의 템플릿 메소드를 호출하면 직접 Connection을 생성하고 종료하는 일을 모두 담당한다고 설명했다. 테스트에서 특별한 준비 없이 DAO의 메소드를 직접 사용했을 때도 제대로 동작하는 것을 보면 스스로 Connection을 생성해서 사용한다는 사실을 알 수 있다.

JdbcTemplate은 영리하게 동작하도록 설계되어 있다. 만약 미리 생성돼서 트랜잭션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우에는 JdbcTemplate이 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행한다. 반면에 upgradeLevels() 메소드에서 처럼 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되는 JdbcTemplate의 메소드에서는 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저장소에 들어 있는 DB 커넥션을 가져와서 사용한다. 이를 통해 이미 시작된 트랜잭션에 참여하는 것이다.

따라서 DAO를 사용할 때 트랜잭션이 굳이 필요 없다면 바로 호출해서 사용해도 되고, DAO 외부에서 트랜잭션을 만들고 이를 관리할 필요가 있다면 미리 DB 커넥션을 생서한 다음 트랜잭션 동기화를 해주고 사용하면 된다. 트랜잭션 동기화를 해주고 나면 DAO에서 사용하는 JdbcTemplate은 자동으로 트랜잭션 안에서 동작할 것이다. 따라서 트랜잭션 적용 여부에 맞춰 UserDao 코드를 수정할 필요가 없다. JDBC 코드의 try/catch/finally 작업 흐름 지원, SQLException의 예외 변환과 함께 JdbcTemplate이 제공해주는 세 가지 유용한 기능 중 하나다.

비즈니스 로직 레벨의 트랜잭션을 적용했지만 JdbcTemplate을 포기할 필요도 없고, 지저분한 Connection 파라미터를 계속 물고 다니지 않아도 된다. UserDao는 여전히 데이터 액세스 기술에 종속되지 않는 깔끔한 인터페이스 메소드를 유지하고 있다. 그리고 테스트에서 DAO를 직접 호출해서 사용하는 것도 아무런 문제가 되지 않는다.
