# 템플릿
1장에서는 초난감 DAO 코드에 DI를 적용해나가는 과정을 통해서 관심이 다른 코드를 다양한 방법으로 분리하고, 확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업을 했다.

확장에는 자유롭게 열려 있고 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙(OCP)을 다시 한번 생각해보자. 이 원칙은 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있어 변하지 않으려는 성질이 있음을 말해준다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이용에 의해 다른 시점에 독립적으로 변경될 수 있는 효유ㅜㄹ적인 구조로 만들어주는 것이 바로 이 개방 폐쇄 원칙이다.

템플릿이랑 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

## 다시 보는 초난감 DAO
UserDao의 코드에는 아직 문제점이 남아 있다. DB 연결과 관련된 여러 가지 개선 작업은 했지만. 심각한 문제점이 있는데, 바로 예외상황에 대한 처리다.

### 예외처리 기능을 갖춘 DAO
제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있다. 바로 예외처리다. 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 하기 때문이다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

#### JDBC 수정 기능의 예외처리 코드
UserDao의 가장 단순한 메소드인 deleteAll()을 살펴보자.

~~~java
//JDBC API를 이용한 DAO 코드인 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = dataSource.getConnection();

  PreparedStatement ps = c.prepareStatement("delete from users");
  ps.executeUpdate();

  ps.close();
  c.close();
}
~~~

PreparedStatement를 처리하는 중에 예외가 발생하면 메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 된다. 문제는 Connection과 PreparedStatement의 close() 메소드가 실행되지 않아서 리소스가 반환되지 않을 수 있다는 점이다.

DB풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.

cf) close() 메소드는 사용한 리소스를 풀로 다시 돌려주는 역할을 한다.

예외상황에서도 리소스를 제대로 반환할 수 있도록 try/catch/finally를 적용해보자.

~~~java
// 예외 발생시에도 리소스를 반환하도록 수정한 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = null;
  PreparedStatement ps = null;

  try {
    c = dataSource.getConnection();
    ps = c.prepareStatement("delete from users");
    ps.executeUpdate();
  } catch(SQLException e) {
    throw e;
  } finally {
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      c.close();
    } catch(SQLException e) {
    }
  }
}
~~~
예외상황에서도 안전한 코드가 됐다. close()도 SQLException이 발생할 수 있는 메소드라서 try/catch 문으로 처리해줘야 한다. 만약 getConnection()에서 DB 커넥션을 가져오다가 일시적인 DB 서버 문제나, 네트워크 문제 또는 그 밖의 예외상황 때문에 예외가 발생했다면 ps는 물론이고 변수 c도 아직 null 상태 이므로 if문에서 체크후에 close() 해줬다.

#### JDBC 조회 기능의 예외처리
조회를 위한 JDBC 코드는 ResultSet이 추가 되기 때문에 좀 더 복잡해진다.
~~~java
//JDBC 예외처리를 적용한 getCount() 메소드
public int getCount() throws SQLExeption {
  Connection c = null;
  PreparedStatement ps = null;
  ResultSet rs = null;

  try {
    c = dataSource.getConnection();

    ps = c.prepareStatement("select count(*) from users");

    rs = ps.executeQuery();
    rs.next();
    return rs.getInt(1);
  } catch(SQLException e) {
    throw e;
  } finally {
    if(rs != null) {
      try {
        rs.close();
      } catch(SQLException e) {
      }
    }
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      try {
        c.close();
      } catch(SQLException e) {
      }
    }
  }
}
~~~

이제 UserDao의 모든 메소드에 동일한 방식으로 try/catch/fianlly 블록을 적용했다. 예외상황에 대한 처리까지 모두 마쳤으니, 이제 서버환경에서도 안정적으로 수행될 수 있으면서 DB연결 기능을 자유롭게 확장할 수 있는 이상적인 DAO가 됐다. 실전에 사용해도 문제가 없는 잘 설계된 DAO다. 하지만 여전히 뭔가 아쉬움이 남아 있다.

## 변한느 것과 변하지 않는 것
### JDBC try/catch/finally 코드의 문제점
try/catch/finally 블록을 적용해서 완성도 높은 DAO 코드가 됐지만, 막상 코드를 훑어보면 한숨이 나온다. 복잡한 try/catch/finally 블록이 2중으로 중첩까지 되어 나오는데다, 모든 메소드마다 반복된다.

이런 코드를 작성할 때 사용할 수 있는 가장 효과적인 방법은 복사해서 붙이기 신공이다. 그런데 속도를 내서 작업하다가 어느 순간 한 줄을 빼먹고 복사했거나, 몇 줄을 잘못 삭제했다면 어떻게 될까? c.close() 라인 하나 뺴먹은 것과 같은 실수를 했어도 테스트를 돌려보면 별문제가 없어보이지만 해당 메소드가 호출되고 나면 커넥션이 하나씩 반환되지 않고 쌓여가게 된다. 서버에 배치해서 사용하면 언젠가 서비스가 중단되는 상황이 발생한다.

설령 실수를 하지 않고 완벽하게 작성했더라도 이런 코드는 계속 폭탄이 될 가능성을 지니고 있다. 누군가 DAO 로직을 수정하려고 했을 때 복잡한 try/catch/finally 블록 안에서 필요한 부분을 찾아서 수정해야 하고, 언젠가 꼭 필요한 부분을 잘못 삭제해버리면 역시 같은 문제가 반복된다.

이런 코드를 효과적으로 다룰 수 있는 방법은 없을까? 개발자라면 당연히 이런 의문을 가져야 한다. 물론 이런 문제를 효과적으로 다룰 수 있는 방법이 있다. 이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.

### 분리와 재사용을 위한 디자인 패턴 적용
UserDao의 메소드를 개선하는 작업을 시작해보자. 가장 먼저 할 일은 변하는 성격이 다른 것을 찾아내는 것이다. deleteAll() 메소드의 코드를 다시 살펴보자.

~~~java
//개선할 deleteAll() 메소드
Connection c = null;
PreparedStatement ps = null;

try {
  c = dataSource.getConnection();

  ps = c.prepareStatement("delete from users"); //변하는 부분

  ps.executeUpdate();
} catch(SQLException e) {
  throw e;
} finally {
  if(ps != null) {
    try {
      ps.close();
    } catch(SQLException e) {
    }
  }
  if(c != null) {
    try {
      c.close();
    } catch(SQLException e) {
    }
  }
}
~~~
아래 부분을 제외하고는 모두 변하지 않는 부분 이다.
~~~java
ps = c.prepareStatement("delete from users"); //변하는 부분
~~~
위처럼 PreparedStatement를 만들어서 업데이트용 쿼리를 실행하는 메소드라면 deleteAll() 메소드와 구조는 거의 비슷할 것이다. 비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않는 고정되는 부분과, 각 메소드마다 로직에 따라 변하는 부분을 위와 같이 구분해 볼 수 있다.

만약 add() 메소드라면 위 코드에서 변하는 부분으로 표시한 코드를 아래와 같이 바꾸기만 하면 된다.
~~~java
// add() 메소드에서 수정할 부분
...
ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
ps.setString(1, user.getId());
ps.setString(2, user.getName());
ps.setString(3, user.getPassword());
~~~

그렇다면 이 로직에 따라서 변하는 부분을 변하지 않는 나머지 코드에서 분리하는 것이 어떨까? 그렇게 할 수 있다면 변하지 않는 부분을 재사용할 수 있는 방법이 있지 않을까?

#### 메소드 추출
먼저 생각해볼 수 있는 방법은 변하는 부분을 메소드로 빼는 것이다. 변하지 않는 부분이 변하는 부분을 감싸고 있기 때문에 변하지 않는 부분을 추출하기가 어려워 보이기 때문에 반대로 해보자.

~~~java
// 변하는 부분을 메소드로 추출한 후의 deleteAll()
public void deleteAll() throws SQLException {
  ...
  try {
    c = dataSource.getConnection();

    ps = makeStatement(c);// 변하는 부분을 메소드로 추출하고 변하지 않는 부분에서 호출하도록 만들었다.

    ps.executeUpdate();
  } catch(SQLException e) {...}
}

private PreparedStatement makeStatement(Connection c) throws SQLException {
  PreparedStatement ps;
  ps = c.prepareStatement("delete from users");
  return ps;
}
~~~
자주 바뀌는 부분을 메소드로 독립시켰는데 당장 봐서는 별 이득이 없어 보인다. 왜냐하면 보통 메소드 추출 리팩토링을 적용하는 경우에는 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하는데, 이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드는 DAO 로직마다 새롭게 만들어서 확장돼야 하는 부분이기 때문이다. 뭔가 반대로 됐다.

#### 템플릿 메소드 패턴의 적용
다음은 템플릿 메소드 패턴을 이용해서 분리해보자. 템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.

추출해서 별도의 메소드로 독립시킨 makeStatement() 메소드를 다음과 같이 추상 메소드 선언으로 변경한다. 물론 UserDao 클래스도 추상 클래스가 돼야 할 것이다.
~~~java
abstract protected PreparedStatement makeStatement(Connection c) throws SQLException;
~~~

그리고 이를 상속하는 서브클래스를 만들어서 거기서 이 메소드를 구현한다.
~~~java
// makeStatement()를 구현한 UserDao 서브클래스
public class UserDaoDeleteAll extends UserDao {
  protected PreparedStatement makeStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
~~~

이제 UserDao 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 이쏙, 확장 때문에 기존의 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 객체지향 설계의 핵심 원리인 개방 폐쇄 원칙(OCP)을 그럭저럭 지키는 구조를 만들어낼 수는 있는 것 같다. 하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다. 가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다.

만약 이 방식을 사용한다면 UserDao의 JDBC 메소드가 4개일 경우 4개의 서브클래스를 만들어서 사용해야 한다. 이래서는 장점보다 단점이 더 많아 보인다.

또 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다는 점이다. 변하지 않는 코드를 가진 USerDao의 JDBC try/catch/finally 블록과 변하는 PreparedStatement를 담고 있는 서브클래스들이 이미 클래스 레벨에서 컴파일 시점에 이미 그 관계가 결정되어 있다. 따라서 그 관계에 대한 유연성이 떨어져 버린다. 상속을 통해 확장을 꾀하는 템플릿 메소드 패턴의 단점이 고스란히 드러난다.

#### 전략 패턴의 적용
개방 폐쇅 원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다.

전략 패턴은 OCP 관점에서 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.

~~~
+---------------+        +-----------------+
|context        |        |Strategy         |
+---------------+------->+-----------------+
|contextMethod()|        |algorithmMethod()|
+----------------        +--------+--------+
                                  △
                      +-----------+----------+
                      |                      |
             +--------+---------+  +---------+--------+
             |ConcreateStrategyA|  |ConcreateStrategyB|
             +------------------+  +------------------+
             |algorithmMethod() |  |algorithmMethod() |
             +------------------+  +------------------+
~~~
deleteAll() 메소드에서 변하지 않는 부분이라고 명시한 것이 바로 이 contextMethod()가 된다. deleteAll()은 JDBC를 이용해 DB를 업데이트하는 작업이라는 변하지 않는 맥락(context)를 갖는다. deleteAll()의 컨텍스트를 정리해보면 다음과 같다.

- DB 커넥션 가져오기
- PreparedStatement를 만들어줄 외부 기능 호출하기
- 전달받은 PreparedStatement 실행하기
- 예외가 발생하면 이를 다시 메소드 밖으로 던지기
- 모든 경우에 만들어진 PreparedStatement와 Connection을 적절히 닫아주기

두 뻔째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전략이라고 볼 수 있다. 전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스의 메소드를 통해 PreparedStatement 생성 전략을 호출해주면 된다.

PreparedStatement를 만드는 전략의 인터페이스는 컨텍스트가 만들어둔 Connection을 전달받아서, PreparedStatement를 만들고 만들어진 PreparedStatement오브젝트를 돌려준다. 이를 인터페이스로 정의하면 아래와 같다.

~~~java
...
public interface StatementStrategy {
  PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
~~~

이 인터페이스를 상속해서 실제 전략, 즉 바뀌는 부분인 PreparedStatement를 생성하는 클래스를 만들어보자.

~~~java
// deleteAll() 메소드의 기능을 구현한 StatementStrategy 전략 클래스
...
public class DeleteAllStatement implements StatementStrategy {
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
~~~
이제 확장된 PreparedStrategy 전략인 DeleteAllStatement가 만들어졌다. 이것을 contextMethod()에 해당하는 UserDao의 deleteAll() 메소드에서 사용하면 그럭저럭 전략 패턴을 적용했다고 볼 수 있다.

~~~java
// 전략 패턴을 따라 DeleteAllStatement가 적용된 deleteAll() 메소드
...
try {
  c = dataSource.getConnection();

  StatementStrategy strategy = new DeleteAllStatement();
  ps = strategy.makePreparedStatement(c);

  ps.executeUpdate();
} catch(SQLException e) {
  ...
}
~~~

하지만 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(OCP의 폐쇄 원칙) 전략을 바꿔 쓸 수 있다(OCP의 개방 원칙)는 것인데, 이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다면 뭔가 이상하다. 컨텍스트가 StatementStrategy 인터페이스뿐 아니라 특정 구현 클래스인 DeleteAllStatement를 직접 알고 있다는건, 전략 패턴에도 OCP에도 잘 들어맞는다고 볼 수 없기 때문이다.


#### DI 적용을 위한 클라이언트 / 컨텍스트 분리
이 문제를 해결하기 위해 전략 패턴의 실제적인 사용 방법을 좀 더 살펴보자.

전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는 게 일반적이다. Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것이다.

~~~
// 전략패턴에서 Client의 역할
+--------------+   supply      +---------------+    supply        +-----------------+
|Client        |   strategy    |context        |  context infos   |Strategy         |
+--------------+-------------->+---------------+----------------->+-----------------+
|              |               |contextMethod()|                  |algorithmMethod()|
+-----+--------+               +---------------+                  +-----------------+
      |                                                                   △
      |                                                       +----------------------+
      |                                                       |                      |
      |                                              +--------+---------+  +---------+--------+
      |   select strategy and create                 |ConcreateStrategyA|  |ConcreateStrategyB|
      +--------------------------------------------->+------------------+  +------------------+
                                                     |algorithmMethod() |  |algorithmMethod() |
                                                     +------------------+  +------------------+
~~~
어디서 많이 보던 그림이다. 처음 UserDao의 ConnectionMaker를 독립시키고 나서 UserDao가 구체적인 ConnectionMaker 구현 클래스를 만들어 사용하는 데 문제가 있다고 판단됐을 때 적용했던 바로 그 방법이다. 그때는 컨텍스트(UserDao)가 필요로 하는 전략(ConnectionMaker)의 특정 구현 클래스(DConnectionMaker) 오브젝트를 클라이언트(UserDaoTest)가 만들어서 제공해주는 방법을 사용했다.

이 구조에서 전략 오브젝트 생성과 컨텍스트로의 전달을 담담하는 책임을 분리시킨 것이 바로 ObjectFactory이며, 이를 일반화한 것이 앞에서 살펴봤던 의존관계 주입(DI)이었다.

아무튼 여기서 이 팬턴 구조를 코드에 적용해보자. 중요한 것은 이 컨텍스트에 해당하는 JDBC try/catch/finally 코드를 클라이언트 코드인 StatementStrategy를 만드는 부분에서 독립시켜야 한다는 점이다.
deleteAll() 메소드에서 다음 코드는 클라이언트에 들어가야 할 코드다. 나머지 코드는 컨텍스트 코드이므로 분리해야한다.

~~~java
StatementStrategy strategy = new DeleteAllStatement();
~~~

컨텍스트에 해당하는 부분은 별도의 메소드로 독립시켜보자.

~~~java
// 메소드로 분리한 try/catch/finally 컨텍스트 코드
public void jdbcContextStatementStrategy(StatementStrategy stmt) throws SQLException {
  Connection c = null;
  PreparedStatement ps = null;

  try {
    c = dataSource.getConnection();

    ps = stmt.makePreparedStatement(c);

    ps.executeUpdate();
  } catch(SQLException e) {
    throw e;
  } finally {
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {}
    }
    if(c != null) {
      try {
        c.close();
      } catch(SQLException e) {}
    }
  }
}
~~~
이 메소드는 컨텍스트의 핵심적인 내용을 잘 담고 있다. 클라이언트로부터 StatementStrategy 타입의 전략 오브젝트를 제공받고 JDBC try/catch/finally 구조로 만들어진 컨텍스트 내에서 작업을 수행한다. 제공받은 전략 오브젝트는 PreparedStatement 생성이 필요한 시점에 호출해서 사용한다. 모든 JDBC 코드의 틀에박힌 작업은 이 컨텍스트 메소드 안에 잘 담겨 있다.

다음은 클라이언트에 해당하는 부분을 살펴보자. 컨텍스트를 별도의 메소드로 분리했으니 deleteAll() 메소드가 클라이언트가 된다. 따라서 전략 오브젝트를 만들고 컨텍스트를 호출하는 책임을 지고 있다.

~~~java
// 클라이언트 책임을 담당할 deleteAll() 메소드
public void deleteAll() throws SQLException {
  StatementStrategy st = new DeleteAllStatement();
  jdbcContextWithStatementStrategy(st);
}
~~~
이제 구조로 볼 때 완벽한 전략 패턴의 모습을 갖췄다. 비록 클라이언트와 컨텍스트는 클래스를 분리하진 않았지만, 의존관계와 책임으로 볼 때 이상적인 클라이언트/컨텍스트 관계를 갖고 있다. 특히 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달한다는 면에서 DI 구조라고 이해할 수도 있다.

지금까지 해온 관심사를 분리하고 유연한 확장관계를 유지하도록 만든 작업은 매우 중요하다. 이 구조가 기반이 돼서 앞으로 진행할 UserDao 코드의 본격적인 개선 작업이 가능하다.

## JDBC 전략 패턴의 최적화
지금까지 기존의 deleteAll() 메소드에 담겨 있던 변하지 않는 부분, 자주 변하는 부분을 전략 패턴을 사용해 깔끔하게 분리해냈다. 독립된 JDBC 작업 흐름이 담긴 jdbcContextWithStatementStrategy()는 DAO 메소드들이 공유할 수 있게 됐다. DAO 메소드는 전략 패턴의 클라이언트로서 컨텍스트에 해당하는 jdbcContextWithStatementStrategy() 메소드에 적절한 전략, 즉 바뀌는 로직을 제공해주는 바업ㅂ으로 사용할 수 있다. 여기서 컨텍스트는 PreparedStatement를 실행하는 JDBC의 작업 흐름이고, 전략은 PreparedStatement를 생성하는 것이다.

### 전략 클래스의 추가 정보
이번엔 add() 메소드에도 적용해보자. 먼저 add() 메소드에서 변하는 부분인 PreparedStatement를 만드는 코드를 AddStatement 클래스로 옮겨 담는다.

~~~java
// add() 메소드의 PreparedStatement 생성 로직을 분리한 클래스
public class AddStatement implements StatementStrategy {
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");

    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    return ps;
  }
}
~~~

그런데 PreparedStatement를 만들때 user라는 부가적인 정보가 필요하기 때문에 에러가 난다. 등록할 사용자 정보는 클라이언트에 해당하는 add() 메소드가 갖고 있다. 따라서 클라이언트가 AddStatement의 전략을 수행하려면 부가정보인 user를 제공해 줘야 한다.

다음과 같이 생성자를 통해 제공받게 만들자
~~~java
public class AddStatement implements StatementStrategy {
  User user;

  public AddStatement(User user) {
    this.user = user;
  }

  public PreparedStatement makePreparedStatement(Connection c) {
    ...
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());
    ...
  }
}
~~~

이제는 에러 없이 동작할 것이다. 다음은 클라이언트인 UserDao의 add() 메소드를 아래와 같이 user 정보를 생성자를 통해 전달해주도록 수정하자.

~~~java
public void add(User user) throws SQLException {
  StatementStrategy st = new AddStatement(user);
  jdbcContextWithStatementStrategy(st);
}
~~~
이렇게 해서 deleteAll()과 add() 두 군데에서 모두 PreparedStatement를 실행하는 JDBC try/catch/finally 컨텍스트를 공유해서 사용할 수 있게 됐다. 앞으로 비슷한 기능의 DAO 메소드가 필요할 때마다 이 Statement 전략과 jdbcContextWithStatementStrategy() 켄턱스트를 활용할 수 있으니 try/catch/finally로 범벅된 코드를 만들다가 실수할 염려는 없어졌다. DAO 코드도 간결해졌다.

### 전략과 클라이언트의 동거
여기서 만족하지 말고 좀 더 개선할 부분을 찾아보자.
현재 만들어진 구조에 두 가지 불만이 있다. 먼저 DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다는 점이다. 이렇게 되면 기존 UserDao 때보다 클래스 파일의 개수가 많이 늘어난다.

또 다른 불만은 DAO 메소드에서 StatementStrategy에 전달한 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점이다.

이 두 가지 문제를 해결할 수 있는 방법을 생각해보자.

#### 로컬 클래스
클래스 파일이 많아지는 문제는 간단한 해결 방법이 있다. StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의해버리는 것이다.

DeleteAllStatement나 AddStatement는 UserDao 밖에서는 사용되지 않는다. 둘 다 UserDao에서만 사용되고, UserDao의 메소드 로직에 강하게 결합되어 있다. 이처럼 특정 메소드에서만 사용되는 것이라면 아래와 같이 로컬 클래스로 만들 수도 있다.

~~~java
// add() 메소드 내의 로컬 클래스로 이전한 AddStatement
public void add(User user) throws SQLException {
  class AddStatement implements StatementStrategy {
    User user;

    public AddStatement(User user) {
      this.user = user;
    }

    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");

      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      return ps;
    }
  }

  StatementStrategy st = new AddStatement(user);
  jdbcContextWithStatementStrategy(st);
}
~~~

AddStatement 클래스를 로컬 클래스로서 add() 메소드 안에 집어넣었다. 이런 식으로 클래스를 정의하는 방식이 생소할지 모르겠지만 자바 언어에서 허용하는 클래스 선언 방법의 하나다. 마치 로컬 변수로 선언하듯이 선언하면 된다. 로컬 클래스는 선언된 메소드 내에서만 사용할 수 있다. AddStatement가 사용될 곳이 add() 메소드뿐이라면, 이렇게 사용하기 전에 바로 정의해서 쓰는 것도 나쁘지 않다. 덕분에 클래스 파일이 하나 줄었고, add() 메소드 안에서 PreparedStatement 생성 로직을 함께 볼 수 있으므로 코드를 이해하기에도 좋다.

로컬 클래스에는 또 한 가지 장점이 있다. 바로 로컬 클래스는 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있다는 점이다. AddStatement는 User 정보를 필요로 한다. 이를 위해 생성자를 만들어서 add() 메소드에서 이를 전달해 주도록 했다. 그런데 이렇게 add() 메소드 내에  AddStatement 클래스를 정의하면 번거롭게 생성자를 통해 User 오브젝트를 전달해줄 필요가 없다.
