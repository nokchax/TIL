# 템플릿
1장에서는 초난감 DAO 코드에 DI를 적용해나가는 과정을 통해서 관심이 다른 코드를 다양한 방법으로 분리하고, 확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업을 했다.

확장에는 자유롭게 열려 있고 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙(OCP)을 다시 한번 생각해보자. 이 원칙은 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있어 변하지 않으려는 성질이 있음을 말해준다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이용에 의해 다른 시점에 독립적으로 변경될 수 있는 효유ㅜㄹ적인 구조로 만들어주는 것이 바로 이 개방 폐쇄 원칙이다.

템플릿이랑 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

## 다시 보는 초난감 DAO
UserDao의 코드에는 아직 문제점이 남아 있다. DB 연결과 관련된 여러 가지 개선 작업은 했지만. 심각한 문제점이 있는데, 바로 예외상황에 대한 처리다.

### 예외처리 기능을 갖춘 DAO
제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있다. 바로 예외처리다. 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 하기 때문이다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

#### JDBC 수정 기능의 예외처리 코드
UserDao의 가장 단순한 메소드인 deleteAll()을 살펴보자.

~~~java
//JDBC API를 이용한 DAO 코드인 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = dataSource.getConnection();

  PreparedStatement ps = c.prepareStatement("delete from users");
  ps.executeUpdate();

  ps.close();
  c.close();
}
~~~

PreparedStatement를 처리하는 중에 예외가 발생하면 메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 된다. 문제는 Connection과 PreparedStatement의 close() 메소드가 실행되지 않아서 리소스가 반환되지 않을 수 있다는 점이다.

DB풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.

cf) close() 메소드는 사용한 리소스를 풀로 다시 돌려주는 역할을 한다.

예외상황에서도 리소스를 제대로 반환할 수 있도록 try/catch/finally를 적용해보자.

~~~java
// 예외 발생시에도 리소스를 반환하도록 수정한 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = null;
  PreparedStatement ps = null;

  try {
    c = dataSource.getConnection();
    ps = c.prepareStatement("delete from users");
    ps.executeUpdate();
  } catch(SQLException e) {
    throw e;
  } finally {
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      c.close();
    } catch(SQLException e) {
    }
  }
}
~~~
예외상황에서도 안전한 코드가 됐다. close()도 SQLException이 발생할 수 있는 메소드라서 try/catch 문으로 처리해줘야 한다. 만약 getConnection()에서 DB 커넥션을 가져오다가 일시적인 DB 서버 문제나, 네트워크 문제 또는 그 밖의 예외상황 때문에 예외가 발생했다면 ps는 물론이고 변수 c도 아직 null 상태 이므로 if문에서 체크후에 close() 해줬다.

#### JDBC 조회 기능의 예외처리
조회를 위한 JDBC 코드는 ResultSet이 추가 되기 때문에 좀 더 복잡해진다.
~~~java
//JDBC 예외처리를 적용한 getCount() 메소드
public int getCount() throws SQLExeption {
  Connection c = null;
  PreparedStatement ps = null;
  ResultSet rs = null;

  try {
    c = dataSource.getConnection();

    ps = c.prepareStatement("select count(*) from users");

    rs = ps.executeQuery();
    rs.next();
    return rs.getInt(1);
  } catch(SQLException e) {
    throw e;
  } finally {
    if(rs != null) {
      try {
        rs.close();
      } catch(SQLException e) {
      }
    }
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      try {
        c.close();
      } catch(SQLException e) {
      }
    }
  }
}
~~~

이제 UserDao의 모든 메소드에 동일한 방식으로 try/catch/fianlly 블록을 적용했다. 예외상황에 대한 처리까지 모두 마쳤으니, 이제 서버환경에서도 안정적으로 수행될 수 있으면서 DB연결 기능을 자유롭게 확장할 수 있는 이상적인 DAO가 됐다. 실전에 사용해도 문제가 없는 잘 설계된 DAO다. 하지만 여전히 뭔가 아쉬움이 남아 있다.
