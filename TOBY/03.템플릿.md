# 템플릿
1장에서는 초난감 DAO 코드에 DI를 적용해나가는 과정을 통해서 관심이 다른 코드를 다양한 방법으로 분리하고, 확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업을 했다.

확장에는 자유롭게 열려 있고 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙(OCP)을 다시 한번 생각해보자. 이 원칙은 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있어 변하지 않으려는 성질이 있음을 말해준다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이용에 의해 다른 시점에 독립적으로 변경될 수 있는 효유ㅜㄹ적인 구조로 만들어주는 것이 바로 이 개방 폐쇄 원칙이다.

템플릿이랑 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

## 다시 보는 초난감 DAO
UserDao의 코드에는 아직 문제점이 남아 있다. DB 연결과 관련된 여러 가지 개선 작업은 했지만. 심각한 문제점이 있는데, 바로 예외상황에 대한 처리다.

### 예외처리 기능을 갖춘 DAO
제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있다. 바로 예외처리다. 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 하기 때문이다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

#### JDBC 수정 기능의 예외처리 코드
UserDao의 가장 단순한 메소드인 deleteAll()을 살펴보자.

~~~java
//JDBC API를 이용한 DAO 코드인 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = dataSource.getConnection();

  PreparedStatement ps = c.prepareStatement("delete from users");
  ps.executeUpdate();

  ps.close();
  c.close();
}
~~~

PreparedStatement를 처리하는 중에 예외가 발생하면 메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 된다. 문제는 Connection과 PreparedStatement의 close() 메소드가 실행되지 않아서 리소스가 반환되지 않을 수 있다는 점이다.

DB풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.

cf) close() 메소드는 사용한 리소스를 풀로 다시 돌려주는 역할을 한다.

예외상황에서도 리소스를 제대로 반환할 수 있도록 try/catch/finally를 적용해보자.

~~~java
// 예외 발생시에도 리소스를 반환하도록 수정한 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = null;
  PreparedStatement ps = null;

  try {
    c = dataSource.getConnection();
    ps = c.prepareStatement("delete from users");
    ps.executeUpdate();
  } catch(SQLException e) {
    throw e;
  } finally {
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      c.close();
    } catch(SQLException e) {
    }
  }
}
~~~
예외상황에서도 안전한 코드가 됐다. close()도 SQLException이 발생할 수 있는 메소드라서 try/catch 문으로 처리해줘야 한다. 만약 getConnection()에서 DB 커넥션을 가져오다가 일시적인 DB 서버 문제나, 네트워크 문제 또는 그 밖의 예외상황 때문에 예외가 발생했다면 ps는 물론이고 변수 c도 아직 null 상태 이므로 if문에서 체크후에 close() 해줬다.

#### JDBC 조회 기능의 예외처리
조회를 위한 JDBC 코드는 ResultSet이 추가 되기 때문에 좀 더 복잡해진다.
~~~java
//JDBC 예외처리를 적용한 getCount() 메소드
public int getCount() throws SQLExeption {
  Connection c = null;
  PreparedStatement ps = null;
  ResultSet rs = null;

  try {
    c = dataSource.getConnection();

    ps = c.prepareStatement("select count(*) from users");

    rs = ps.executeQuery();
    rs.next();
    return rs.getInt(1);
  } catch(SQLException e) {
    throw e;
  } finally {
    if(rs != null) {
      try {
        rs.close();
      } catch(SQLException e) {
      }
    }
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      try {
        c.close();
      } catch(SQLException e) {
      }
    }
  }
}
~~~

이제 UserDao의 모든 메소드에 동일한 방식으로 try/catch/fianlly 블록을 적용했다. 예외상황에 대한 처리까지 모두 마쳤으니, 이제 서버환경에서도 안정적으로 수행될 수 있으면서 DB연결 기능을 자유롭게 확장할 수 있는 이상적인 DAO가 됐다. 실전에 사용해도 문제가 없는 잘 설계된 DAO다. 하지만 여전히 뭔가 아쉬움이 남아 있다.

## 변한느 것과 변하지 않는 것
### JDBC try/catch/finally 코드의 문제점
try/catch/finally 블록을 적용해서 완성도 높은 DAO 코드가 됐지만, 막상 코드를 훑어보면 한숨이 나온다. 복잡한 try/catch/finally 블록이 2중으로 중첩까지 되어 나오는데다, 모든 메소드마다 반복된다.

이런 코드를 작성할 때 사용할 수 있는 가장 효과적인 방법은 복사해서 붙이기 신공이다. 그런데 속도를 내서 작업하다가 어느 순간 한 줄을 빼먹고 복사했거나, 몇 줄을 잘못 삭제했다면 어떻게 될까? c.close() 라인 하나 뺴먹은 것과 같은 실수를 했어도 테스트를 돌려보면 별문제가 없어보이지만 해당 메소드가 호출되고 나면 커넥션이 하나씩 반환되지 않고 쌓여가게 된다. 서버에 배치해서 사용하면 언젠가 서비스가 중단되는 상황이 발생한다.

설령 실수를 하지 않고 완벽하게 작성했더라도 이런 코드는 계속 폭탄이 될 가능성을 지니고 있다. 누군가 DAO 로직을 수정하려고 했을 때 복잡한 try/catch/finally 블록 안에서 필요한 부분을 찾아서 수정해야 하고, 언젠가 꼭 필요한 부분을 잘못 삭제해버리면 역시 같은 문제가 반복된다.

이런 코드를 효과적으로 다룰 수 있는 방법은 없을까? 개발자라면 당연히 이런 의문을 가져야 한다. 물론 이런 문제를 효과적으로 다룰 수 있는 방법이 있다. 이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.

### 분리와 재사용을 위한 디자인 패턴 적용
UserDao의 메소드를 개선하는 작업을 시작해보자. 가장 먼저 할 일은 변하는 성격이 다른 것을 찾아내는 것이다. deleteAll() 메소드의 코드를 다시 살펴보자.

~~~java
//개선할 deleteAll() 메소드
Connection c = null;
PreparedStatement ps = null;

try {
  c = dataSource.getConnection();

  ps = c.prepareStatement("delete from users"); //변하는 부분

  ps.executeUpdate();
} catch(SQLException e) {
  throw e;
} finally {
  if(ps != null) {
    try {
      ps.close();
    } catch(SQLException e) {
    }
  }
  if(c != null) {
    try {
      c.close();
    } catch(SQLException e) {
    }
  }
}
~~~
아래 부분을 제외하고는 모두 변하지 않는 부분 이다.
~~~java
ps = c.prepareStatement("delete from users"); //변하는 부분
~~~
위처럼 PreparedStatement를 만들어서 업데이트용 쿼리를 실행하는 메소드라면 deleteAll() 메소드와 구조는 거의 비슷할 것이다. 비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않는 고정되는 부분과, 각 메소드마다 로직에 따라 변하는 부분을 위와 같이 구분해 볼 수 있다.

만약 add() 메소드라면 위 코드에서 변하는 부분으로 표시한 코드를 아래와 같이 바꾸기만 하면 된다.
~~~java
// add() 메소드에서 수정할 부분
...
ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
ps.setString(1, user.getId());
ps.setString(2, user.getName());
ps.setString(3, user.getPassword());
~~~

그렇다면 이 로직에 따라서 변하는 부분을 변하지 않는 나머지 코드에서 분리하는 것이 어떨까? 그렇게 할 수 있다면 변하지 않는 부분을 재사용할 수 있는 방법이 있지 않을까?

#### 메소드 추출
먼저 생각해볼 수 있는 방법은 변하는 부분을 메소드로 빼는 것이다. 변하지 않는 부분이 변하는 부분을 감싸고 있기 때문에 변하지 않는 부분을 추출하기가 어려워 보이기 때문에 반대로 해보자.

~~~java
// 변하는 부분을 메소드로 추출한 후의 deleteAll()
public void deleteAll() throws SQLException {
  ...
  try {
    c = dataSource.getConnection();

    ps = makeStatement(c);// 변하는 부분을 메소드로 추출하고 변하지 않는 부분에서 호출하도록 만들었다.

    ps.executeUpdate();
  } catch(SQLException e) {...}
}

private PreparedStatement makeStatement(Connection c) throws SQLException {
  PreparedStatement ps;
  ps = c.prepareStatement("delete from users");
  return ps;
}
~~~
자주 바뀌는 부분을 메소드로 독립시켰는데 당장 봐서는 별 이득이 없어 보인다. 왜냐하면 보통 메소드 추출 리팩토링을 적용하는 경우에는 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하는데, 이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드는 DAO 로직마다 새롭게 만들어서 확장돼야 하는 부분이기 때문이다. 뭔가 반대로 됐다.

#### 템플릿 메소드 패턴의 적용
다음은 템플릿 메소드 패턴을 이용해서 분리해보자. 템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.

추출해서 별도의 메소드로 독립시킨 makeStatement() 메소드를 다음과 같이 추상 메소드 선언으로 변경한다. 물론 UserDao 클래스도 추상 클래스가 돼야 할 것이다.
~~~java
abstract protected PreparedStatement makeStatement(Connection c) throws SQLException;
~~~

그리고 이를 상속하는 서브클래스를 만들어서 거기서 이 메소드를 구현한다.
~~~java
// makeStatement()를 구현한 UserDao 서브클래스
public class UserDaoDeleteAll extends UserDao {
  protected PreparedStatement makeStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
~~~

이제 UserDao 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 이쏙, 확장 때문에 기존의 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 객체지향 설계의 핵심 원리인 개방 폐쇄 원칙(OCP)을 그럭저럭 지키는 구조를 만들어낼 수는 있는 것 같다. 하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다. 가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다.

만약 이 방식을 사용한다면 UserDao의 JDBC 메소드가 4개일 경우 4개의 서브클래스를 만들어서 사용해야 한다. 이래서는 장점보다 단점이 더 많아 보인다.

또 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다는 점이다. 변하지 않는 코드를 가진 USerDao의 JDBC try/catch/finally 블록과 변하는 PreparedStatement를 담고 있는 서브클래스들이 이미 클래스 레벨에서 컴파일 시점에 이미 그 관계가 결정되어 있다. 따라서 그 관계에 대한 유연성이 떨어져 버린다. 상속을 통해 확장을 꾀하는 템플릿 메소드 패턴의 단점이 고스란히 드러난다.

#### 전략 패턴의 적용
개방 폐쇅 원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다. 
