# 템플릿
1장에서는 초난감 DAO 코드에 DI를 적용해나가는 과정을 통해서 관심이 다른 코드를 다양한 방법으로 분리하고, 확장과 변경에 용이하게 대응할 수 있는 설계구조로 개선하는 작업을 했다.

확장에는 자유롭게 열려 있고 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙(OCP)을 다시 한번 생각해보자. 이 원칙은 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고, 어떤 부분은 고정되어 있어 변하지 않으려는 성질이 있음을 말해준다. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이용에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조로 만들어주는 것이 바로 이 개방 폐쇄 원칙이다.

템플릿이랑 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

## 다시 보는 초난감 DAO
UserDao의 코드에는 아직 문제점이 남아 있다. DB 연결과 관련된 여러 가지 개선 작업은 했지만. 심각한 문제점이 있는데, 바로 예외상황에 대한 처리다.

### 예외처리 기능을 갖춘 DAO
제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드에는 반드시 지켜야 할 원칙이 있다. 바로 예외처리다. 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 하기 때문이다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

#### JDBC 수정 기능의 예외처리 코드
UserDao의 가장 단순한 메소드인 deleteAll()을 살펴보자.

~~~java
//JDBC API를 이용한 DAO 코드인 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = dataSource.getConnection();

  PreparedStatement ps = c.prepareStatement("delete from users");
  ps.executeUpdate();

  ps.close();
  c.close();
}
~~~

PreparedStatement를 처리하는 중에 예외가 발생하면 메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 된다. 문제는 Connection과 PreparedStatement의 close() 메소드가 실행되지 않아서 리소스가 반환되지 않을 수 있다는 점이다.

DB풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.

cf) close() 메소드는 사용한 리소스를 풀로 다시 돌려주는 역할을 한다.

예외상황에서도 리소스를 제대로 반환할 수 있도록 try/catch/finally를 적용해보자.

~~~java
// 예외 발생시에도 리소스를 반환하도록 수정한 deleteAll()
public void deleteAll() throws SQLException {
  Connection c = null;
  PreparedStatement ps = null;

  try {
    c = dataSource.getConnection();
    ps = c.prepareStatement("delete from users");
    ps.executeUpdate();
  } catch(SQLException e) {
    throw e;
  } finally {
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      c.close();
    } catch(SQLException e) {
    }
  }
}
~~~
예외상황에서도 안전한 코드가 됐다. close()도 SQLException이 발생할 수 있는 메소드라서 try/catch 문으로 처리해줘야 한다. 만약 getConnection()에서 DB 커넥션을 가져오다가 일시적인 DB 서버 문제나, 네트워크 문제 또는 그 밖의 예외상황 때문에 예외가 발생했다면 ps는 물론이고 변수 c도 아직 null 상태 이므로 if문에서 체크후에 close() 해줬다.

#### JDBC 조회 기능의 예외처리
조회를 위한 JDBC 코드는 ResultSet이 추가 되기 때문에 좀 더 복잡해진다.
~~~java
//JDBC 예외처리를 적용한 getCount() 메소드
public int getCount() throws SQLExeption {
  Connection c = null;
  PreparedStatement ps = null;
  ResultSet rs = null;

  try {
    c = dataSource.getConnection();

    ps = c.prepareStatement("select count(*) from users");

    rs = ps.executeQuery();
    rs.next();
    return rs.getInt(1);
  } catch(SQLException e) {
    throw e;
  } finally {
    if(rs != null) {
      try {
        rs.close();
      } catch(SQLException e) {
      }
    }
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {
      }
    }
    if(c != null) {
      try {
        c.close();
      } catch(SQLException e) {
      }
    }
  }
}
~~~

이제 UserDao의 모든 메소드에 동일한 방식으로 try/catch/finally 블록을 적용했다. 예외상황에 대한 처리까지 모두 마쳤으니, 이제 서버환경에서도 안정적으로 수행될 수 있으면서 DB연결 기능을 자유롭게 확장할 수 있는 이상적인 DAO가 됐다. 실전에 사용해도 문제가 없는 잘 설계된 DAO다. 하지만 여전히 뭔가 아쉬움이 남아 있다.

## 변한느 것과 변하지 않는 것
### JDBC try/catch/finally 코드의 문제점
try/catch/finally 블록을 적용해서 완성도 높은 DAO 코드가 됐지만, 막상 코드를 훑어보면 한숨이 나온다. 복잡한 try/catch/finally 블록이 2중으로 중첩까지 되어 나오는데다, 모든 메소드마다 반복된다.

이런 코드를 작성할 때 사용할 수 있는 가장 효과적인 방법은 복사해서 붙이기 신공이다. 그런데 속도를 내서 작업하다가 어느 순간 한 줄을 빼먹고 복사했거나, 몇 줄을 잘못 삭제했다면 어떻게 될까? c.close() 라인 하나 뺴먹은 것과 같은 실수를 했어도 테스트를 돌려보면 별문제가 없어보이지만 해당 메소드가 호출되고 나면 커넥션이 하나씩 반환되지 않고 쌓여가게 된다. 서버에 배치해서 사용하면 언젠가 서비스가 중단되는 상황이 발생한다.

설령 실수를 하지 않고 완벽하게 작성했더라도 이런 코드는 계속 폭탄이 될 가능성을 지니고 있다. 누군가 DAO 로직을 수정하려고 했을 때 복잡한 try/catch/finally 블록 안에서 필요한 부분을 찾아서 수정해야 하고, 언젠가 꼭 필요한 부분을 잘못 삭제해버리면 역시 같은 문제가 반복된다.

이런 코드를 효과적으로 다룰 수 있는 방법은 없을까? 개발자라면 당연히 이런 의문을 가져야 한다. 물론 이런 문제를 효과적으로 다룰 수 있는 방법이 있다. 이 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내는 작업이다.

### 분리와 재사용을 위한 디자인 패턴 적용
UserDao의 메소드를 개선하는 작업을 시작해보자. 가장 먼저 할 일은 변하는 성격이 다른 것을 찾아내는 것이다. deleteAll() 메소드의 코드를 다시 살펴보자.

~~~java
//개선할 deleteAll() 메소드
Connection c = null;
PreparedStatement ps = null;

try {
  c = dataSource.getConnection();

  ps = c.prepareStatement("delete from users"); //변하는 부분

  ps.executeUpdate();
} catch(SQLException e) {
  throw e;
} finally {
  if(ps != null) {
    try {
      ps.close();
    } catch(SQLException e) {
    }
  }
  if(c != null) {
    try {
      c.close();
    } catch(SQLException e) {
    }
  }
}
~~~
아래 부분을 제외하고는 모두 변하지 않는 부분 이다.
~~~java
ps = c.prepareStatement("delete from users"); //변하는 부분
~~~
위처럼 PreparedStatement를 만들어서 업데이트용 쿼리를 실행하는 메소드라면 deleteAll() 메소드와 구조는 거의 비슷할 것이다. 비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않는 고정되는 부분과, 각 메소드마다 로직에 따라 변하는 부분을 위와 같이 구분해 볼 수 있다.

만약 add() 메소드라면 위 코드에서 변하는 부분으로 표시한 코드를 아래와 같이 바꾸기만 하면 된다.
~~~java
// add() 메소드에서 수정할 부분
...
ps = c.prepareStatement("insert into users(id, name, password) values(?,?,?)");
ps.setString(1, user.getId());
ps.setString(2, user.getName());
ps.setString(3, user.getPassword());
~~~

그렇다면 이 로직에 따라서 변하는 부분을 변하지 않는 나머지 코드에서 분리하는 것이 어떨까? 그렇게 할 수 있다면 변하지 않는 부분을 재사용할 수 있는 방법이 있지 않을까?

#### 메소드 추출
먼저 생각해볼 수 있는 방법은 변하는 부분을 메소드로 빼는 것이다. 변하지 않는 부분이 변하는 부분을 감싸고 있기 때문에 변하지 않는 부분을 추출하기가 어려워 보이기 때문에 반대로 해보자.

~~~java
// 변하는 부분을 메소드로 추출한 후의 deleteAll()
public void deleteAll() throws SQLException {
  ...
  try {
    c = dataSource.getConnection();

    ps = makeStatement(c);// 변하는 부분을 메소드로 추출하고 변하지 않는 부분에서 호출하도록 만들었다.

    ps.executeUpdate();
  } catch(SQLException e) {...}
}

private PreparedStatement makeStatement(Connection c) throws SQLException {
  PreparedStatement ps;
  ps = c.prepareStatement("delete from users");
  return ps;
}
~~~
자주 바뀌는 부분을 메소드로 독립시켰는데 당장 봐서는 별 이득이 없어 보인다. 왜냐하면 보통 메소드 추출 리팩토링을 적용하는 경우에는 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하는데, 이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드는 DAO 로직마다 새롭게 만들어서 확장돼야 하는 부분이기 때문이다. 뭔가 반대로 됐다.

#### 템플릿 메소드 패턴의 적용
다음은 템플릿 메소드 패턴을 이용해서 분리해보자. 템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.

추출해서 별도의 메소드로 독립시킨 makeStatement() 메소드를 다음과 같이 추상 메소드 선언으로 변경한다. 물론 UserDao 클래스도 추상 클래스가 돼야 할 것이다.
~~~java
abstract protected PreparedStatement makeStatement(Connection c) throws SQLException;
~~~

그리고 이를 상속하는 서브클래스를 만들어서 거기서 이 메소드를 구현한다.
~~~java
// makeStatement()를 구현한 UserDao 서브클래스
public class UserDaoDeleteAll extends UserDao {
  protected PreparedStatement makeStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
~~~

이제 UserDao 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있고, 확장 때문에 기존의 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 객체지향 설계의 핵심 원리인 개방 폐쇄 원칙(OCP)을 그럭저럭 지키는 구조를 만들어낼 수는 있는 것 같다. 하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다. 가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다.

만약 이 방식을 사용한다면 UserDao의 JDBC 메소드가 4개일 경우 4개의 서브클래스를 만들어서 사용해야 한다. 이래서는 장점보다 단점이 더 많아 보인다.

또 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다는 점이다. 변하지 않는 코드를 가진 UserDao의 JDBC try/catch/finally 블록과 변하는 PreparedStatement를 담고 있는 서브클래스들이 이미 클래스 레벨에서 컴파일 시점에 이미 그 관계가 결정되어 있다. 따라서 그 관계에 대한 유연성이 떨어져 버린다. 상속을 통해 확장을 꾀하는 템플릿 메소드 패턴의 단점이 고스란히 드러난다.

#### 전략 패턴의 적용
개방 폐쇅 원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다.

전략 패턴은 OCP 관점에서 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.

~~~
+---------------+        +-----------------+
|context        |        |Strategy         |
+---------------+------->+-----------------+
|contextMethod()|        |algorithmMethod()|
+----------------        +--------+--------+
                                  △
                      +-----------+----------+
                      |                      |
             +--------+---------+  +---------+--------+
             |ConcreateStrategyA|  |ConcreateStrategyB|
             +------------------+  +------------------+
             |algorithmMethod() |  |algorithmMethod() |
             +------------------+  +------------------+
~~~
deleteAll() 메소드에서 변하지 않는 부분이라고 명시한 것이 바로 이 contextMethod()가 된다. deleteAll()은 JDBC를 이용해 DB를 업데이트하는 작업이라는 변하지 않는 맥락(context)를 갖는다. deleteAll()의 컨텍스트를 정리해보면 다음과 같다.

- DB 커넥션 가져오기
- PreparedStatement를 만들어줄 외부 기능 호출하기
- 전달받은 PreparedStatement 실행하기
- 예외가 발생하면 이를 다시 메소드 밖으로 던지기
- 모든 경우에 만들어진 PreparedStatement와 Connection을 적절히 닫아주기

두 뻔째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전략이라고 볼 수 있다. 전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스의 메소드를 통해 PreparedStatement 생성 전략을 호출해주면 된다.

PreparedStatement를 만드는 전략의 인터페이스는 컨텍스트가 만들어둔 Connection을 전달받아서, PreparedStatement를 만들고 만들어진 PreparedStatement오브젝트를 돌려준다. 이를 인터페이스로 정의하면 아래와 같다.

~~~java
...
public interface StatementStrategy {
  PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
~~~

이 인터페이스를 상속해서 실제 전략, 즉 바뀌는 부분인 PreparedStatement를 생성하는 클래스를 만들어보자.

~~~java
// deleteAll() 메소드의 기능을 구현한 StatementStrategy 전략 클래스
...
public class DeleteAllStatement implements StatementStrategy {
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("delete from users");
    return ps;
  }
}
~~~
이제 확장된 PreparedStrategy 전략인 DeleteAllStatement가 만들어졌다. 이것을 contextMethod()에 해당하는 UserDao의 deleteAll() 메소드에서 사용하면 그럭저럭 전략 패턴을 적용했다고 볼 수 있다.

~~~java
// 전략 패턴을 따라 DeleteAllStatement가 적용된 deleteAll() 메소드
...
try {
  c = dataSource.getConnection();

  StatementStrategy strategy = new DeleteAllStatement();
  ps = strategy.makePreparedStatement(c);

  ps.executeUpdate();
} catch(SQLException e) {
  ...
}
~~~

하지만 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(OCP의 폐쇄 원칙) 전략을 바꿔 쓸 수 있다(OCP의 개방 원칙)는 것인데, 이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다면 뭔가 이상하다. 컨텍스트가 StatementStrategy 인터페이스뿐 아니라 특정 구현 클래스인 DeleteAllStatement를 직접 알고 있다는건, 전략 패턴에도 OCP에도 잘 들어맞는다고 볼 수 없기 때문이다.


#### DI 적용을 위한 클라이언트 / 컨텍스트 분리
이 문제를 해결하기 위해 전략 패턴의 실제적인 사용 방법을 좀 더 살펴보자.

전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는 게 일반적이다. Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것이다.

~~~
// 전략패턴에서 Client의 역할
+--------------+   supply      +---------------+    supply        +-----------------+
|Client        |   strategy    |context        |  context infos   |Strategy         |
+--------------+-------------->+---------------+----------------->+-----------------+
|              |               |contextMethod()|                  |algorithmMethod()|
+-----+--------+               +---------------+                  +-----------------+
      |                                                                   △
      |                                                       +----------------------+
      |                                                       |                      |
      |                                              +--------+---------+  +---------+--------+
      |   select strategy and create                 |ConcreateStrategyA|  |ConcreateStrategyB|
      +--------------------------------------------->+------------------+  +------------------+
                                                     |algorithmMethod() |  |algorithmMethod() |
                                                     +------------------+  +------------------+
~~~
어디서 많이 보던 그림이다. 처음 UserDao의 ConnectionMaker를 독립시키고 나서 UserDao가 구체적인 ConnectionMaker 구현 클래스를 만들어 사용하는 데 문제가 있다고 판단됐을 때 적용했던 바로 그 방법이다. 그때는 컨텍스트(UserDao)가 필요로 하는 전략(ConnectionMaker)의 특정 구현 클래스(DConnectionMaker) 오브젝트를 클라이언트(UserDaoTest)가 만들어서 제공해주는 방법을 사용했다.

이 구조에서 전략 오브젝트 생성과 컨텍스트로의 전달을 담담하는 책임을 분리시킨 것이 바로 ObjectFactory이며, 이를 일반화한 것이 앞에서 살펴봤던 의존관계 주입(DI)이었다.

아무튼 여기서 이 팬턴 구조를 코드에 적용해보자. 중요한 것은 이 컨텍스트에 해당하는 JDBC try/catch/finally 코드를 클라이언트 코드인 StatementStrategy를 만드는 부분에서 독립시켜야 한다는 점이다.
deleteAll() 메소드에서 다음 코드는 클라이언트에 들어가야 할 코드다. 나머지 코드는 컨텍스트 코드이므로 분리해야한다.

~~~java
StatementStrategy strategy = new DeleteAllStatement();
~~~

컨텍스트에 해당하는 부분은 별도의 메소드로 독립시켜보자.

~~~java
// 메소드로 분리한 try/catch/finally 컨텍스트 코드
public void jdbcContextStatementStrategy(StatementStrategy stmt) throws SQLException {
  Connection c = null;
  PreparedStatement ps = null;

  try {
    c = dataSource.getConnection();

    ps = stmt.makePreparedStatement(c);

    ps.executeUpdate();
  } catch(SQLException e) {
    throw e;
  } finally {
    if(ps != null) {
      try {
        ps.close();
      } catch(SQLException e) {}
    }
    if(c != null) {
      try {
        c.close();
      } catch(SQLException e) {}
    }
  }
}
~~~
이 메소드는 컨텍스트의 핵심적인 내용을 잘 담고 있다. 클라이언트로부터 StatementStrategy 타입의 전략 오브젝트를 제공받고 JDBC try/catch/finally 구조로 만들어진 컨텍스트 내에서 작업을 수행한다. 제공받은 전략 오브젝트는 PreparedStatement 생성이 필요한 시점에 호출해서 사용한다. 모든 JDBC 코드의 틀에박힌 작업은 이 컨텍스트 메소드 안에 잘 담겨 있다.

다음은 클라이언트에 해당하는 부분을 살펴보자. 컨텍스트를 별도의 메소드로 분리했으니 deleteAll() 메소드가 클라이언트가 된다. 따라서 전략 오브젝트를 만들고 컨텍스트를 호출하는 책임을 지고 있다.

~~~java
// 클라이언트 책임을 담당할 deleteAll() 메소드
public void deleteAll() throws SQLException {
  StatementStrategy st = new DeleteAllStatement();
  jdbcContextWithStatementStrategy(st);
}
~~~
이제 구조로 볼 때 완벽한 전략 패턴의 모습을 갖췄다. 비록 클라이언트와 컨텍스트는 클래스를 분리하진 않았지만, 의존관계와 책임으로 볼 때 이상적인 클라이언트/컨텍스트 관계를 갖고 있다. 특히 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달한다는 면에서 DI 구조라고 이해할 수도 있다.

지금까지 해온 관심사를 분리하고 유연한 확장관계를 유지하도록 만든 작업은 매우 중요하다. 이 구조가 기반이 돼서 앞으로 진행할 UserDao 코드의 본격적인 개선 작업이 가능하다.

## JDBC 전략 패턴의 최적화
지금까지 기존의 deleteAll() 메소드에 담겨 있던 변하지 않는 부분, 자주 변하는 부분을 전략 패턴을 사용해 깔끔하게 분리해냈다. 독립된 JDBC 작업 흐름이 담긴 jdbcContextWithStatementStrategy()는 DAO 메소드들이 공유할 수 있게 됐다. DAO 메소드는 전략 패턴의 클라이언트로서 컨텍스트에 해당하는 jdbcContextWithStatementStrategy() 메소드에 적절한 전략, 즉 바뀌는 로직을 제공해주는 바업ㅂ으로 사용할 수 있다. 여기서 컨텍스트는 PreparedStatement를 실행하는 JDBC의 작업 흐름이고, 전략은 PreparedStatement를 생성하는 것이다.

### 전략 클래스의 추가 정보
이번엔 add() 메소드에도 적용해보자. 먼저 add() 메소드에서 변하는 부분인 PreparedStatement를 만드는 코드를 AddStatement 클래스로 옮겨 담는다.

~~~java
// add() 메소드의 PreparedStatement 생성 로직을 분리한 클래스
public class AddStatement implements StatementStrategy {
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");

    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    return ps;
  }
}
~~~

그런데 PreparedStatement를 만들때 user라는 부가적인 정보가 필요하기 때문에 에러가 난다. 등록할 사용자 정보는 클라이언트에 해당하는 add() 메소드가 갖고 있다. 따라서 클라이언트가 AddStatement의 전략을 수행하려면 부가정보인 user를 제공해 줘야 한다.

다음과 같이 생성자를 통해 제공받게 만들자
~~~java
public class AddStatement implements StatementStrategy {
  User user;

  public AddStatement(User user) {
    this.user = user;
  }

  public PreparedStatement makePreparedStatement(Connection c) {
    ...
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());
    ...
  }
}
~~~

이제는 에러 없이 동작할 것이다. 다음은 클라이언트인 UserDao의 add() 메소드를 아래와 같이 user 정보를 생성자를 통해 전달해주도록 수정하자.

~~~java
public void add(User user) throws SQLException {
  StatementStrategy st = new AddStatement(user);
  jdbcContextWithStatementStrategy(st);
}
~~~
이렇게 해서 deleteAll()과 add() 두 군데에서 모두 PreparedStatement를 실행하는 JDBC try/catch/finally 컨텍스트를 공유해서 사용할 수 있게 됐다. 앞으로 비슷한 기능의 DAO 메소드가 필요할 때마다 이 Statement 전략과 jdbcContextWithStatementStrategy() 켄턱스트를 활용할 수 있으니 try/catch/finally로 범벅된 코드를 만들다가 실수할 염려는 없어졌다. DAO 코드도 간결해졌다.

### 전략과 클라이언트의 동거
여기서 만족하지 말고 좀 더 개선할 부분을 찾아보자.
현재 만들어진 구조에 두 가지 불만이 있다. 먼저 DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다는 점이다. 이렇게 되면 기존 UserDao 때보다 클래스 파일의 개수가 많이 늘어난다.

또 다른 불만은 DAO 메소드에서 StatementStrategy에 전달한 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점이다.

이 두 가지 문제를 해결할 수 있는 방법을 생각해보자.

#### 로컬 클래스
클래스 파일이 많아지는 문제는 간단한 해결 방법이 있다. StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의해버리는 것이다.

DeleteAllStatement나 AddStatement는 UserDao 밖에서는 사용되지 않는다. 둘 다 UserDao에서만 사용되고, UserDao의 메소드 로직에 강하게 결합되어 있다. 이처럼 특정 메소드에서만 사용되는 것이라면 아래와 같이 로컬 클래스로 만들 수도 있다.

~~~java
// add() 메소드 내의 로컬 클래스로 이전한 AddStatement
public void add(User user) throws SQLException {
  class AddStatement implements StatementStrategy {
    User user;

    public AddStatement(User user) {
      this.user = user;
    }

    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");

      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      return ps;
    }
  }

  StatementStrategy st = new AddStatement(user);
  jdbcContextWithStatementStrategy(st);
}
~~~

AddStatement 클래스를 로컬 클래스로서 add() 메소드 안에 집어넣었다. 이런 식으로 클래스를 정의하는 방식이 생소할지 모르겠지만 자바 언어에서 허용하는 클래스 선언 방법의 하나다. 마치 로컬 변수로 선언하듯이 선언하면 된다. 로컬 클래스는 선언된 메소드 내에서만 사용할 수 있다. AddStatement가 사용될 곳이 add() 메소드뿐이라면, 이렇게 사용하기 전에 바로 정의해서 쓰는 것도 나쁘지 않다. 덕분에 클래스 파일이 하나 줄었고, add() 메소드 안에서 PreparedStatement 생성 로직을 함께 볼 수 있으므로 코드를 이해하기에도 좋다.

로컬 클래스에는 또 한 가지 장점이 있다. 바로 로컬 클래스는 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있다는 점이다. AddStatement는 User 정보를 필요로 한다. 이를 위해 생성자를 만들어서 add() 메소드에서 이를 전달해 주도록 했다. 그런데 이렇게 add() 메소드 내에  AddStatement 클래스를 정의하면 번거롭게 생성자를 통해 User 오브젝트를 전달해줄 필요가 없다.

내부 메소드는 자신이 정의된 메소드의 로컬 변수에 직접 접근할 수 있기 때문이다. 메소드 파라미터도 일종의 로컬 변수이므로 add() 메소드의 user 변수를 AddStatement에서 직접 사용할 수 있다. 다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 final로 선언해줘야 한다. user 파라미터는 메소드 내부에서 변경될 일이 없으므로 final로 선언해도 무방하다.

이렇게 내부 클래스의 장점을 이용하면 user 정보를 전달받기 위해 만들었던 생성자와 인스턴스 변수를 제거할 수 있으므로 아래와 같이 간결해진다.

~~~java
// add() 메소드의 로컬 변수를 직접 사용하도록 수정한 AddStatement
public void add(final User user) throws SQLException {
  class AddStatement implements StatementStrategy {
    public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
      PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
      ps.setString(1, user.getId());
      ps.setString(2, user.getName());
      ps.setString(3, user.getPassword());

      return ps;
    }
  }

  StatementStrategy st = new AddStatement();
  jdbcContextWithStatementStrategy(st);
}
~~~

로컬 클래스로 만들어 두니 장점이 많다. AddStatement는 복잡한 클래스가 아니므로 메소드 안에서 정의해도 그다지 복잡해 보이지 않든다. 메소드마다 추가해야 했던 클래스 파일을 하나 줄일 수 있다는 것도 장점이고, 내부 클래스의 특징을 이용해 로컬 변수를 바로 가져다 사용할 수 있다는 것도 큰 장점이다.

#### 익명 내부 클래스
AddStatement 클래스는 add() 메소드에서만 사용할 용도로 만들어졌다. 그렇다면 좀 더 간결하게 클래스 이름도 제거할 수 있다. 자바에서 제공하는 익명 내부 클래스를 이용해서 말이다.

AddStatement를 익명 내부 클래스로 만들어보자.
~~~java
// AddStatement를 익명 내부 클래스로 전환
StatementStrategy st = new StatementStrategy() {
  public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
    PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
    ps.setString(1, user.getId());
    ps.setString(2, user.getName());
    ps.setString(3, user.getPassword());

    return ps;
  }
};
~~~
만들어진 익명 내부 클래스의 오브젝트는 딱 한 번만 사용할 테니 굳이 변수에 담아두지 말고 jdbcContextWithStatementStrategy() 메소드의 파라미터에서 바로 생성하는 편이 낫다. 그러면 아래처럼 더 간결해진다.

~~~java
// 메소드 파라미터로 이전한 익명 내부 클래스
public void add(final User user) throws SQLException {
  jdbcContextWithStatementStrategy(
    new StatementStrategy() {
      public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        return ps;
      }
    }
  );
}
~~~

## 컨텍스트와 DI
### JdbcContext의 분리
전략 패턴의 구조로 보자면 UserDao의 메소드가 클라이언트이고, 익명 내부 클래스로 만들어지는 것이 개별적인 전략이고, jdbcContextWithStatementStrategy() 메소드는 컨텍스트다. 그런데 JDBC의 일반적인 작업 흐름을 담고 있는 jdbcContextWithStatementStrategy()는 다른 DAO에서도 사용 가능하다. 그러니 UserDao 클래스 밖으로 독립시켜서 모든 DAO가 사용할 수 있게 해보자.

#### 클래스 분리
분리해서 만들 클래스의 이름은 JdbcContext라고 하자, JdbcContext에 UserDao에 있던 컨텍스트 메소드를 workWithStatementStrategy()라는 이름으로 옮겨놓는다. 이렇게 하면 DataSource가 필요한 것은 UserDao가 아니라 JdbcContext가 돼버린다. 따라서 JdbcContext가 DataSource에 의존하고 있으므로 DataSource타입 빈을 DI 받을 수 있게 해줘야 한다.

~~~java
// JDBC 작업 흐름을 분리해서 만든 JdbcContext 클래스
public class JdbcContext {
  private DataSource dataSource;

  public void setDataSource(dataSource dataSource) {
    this.dataSource = dataSource;
  }

  public void workWithStatementStrategy(StatementStrategy stmt) throws SQLException {
    Connection c = null;
    PreparedStatement ps = null;

    try {
      c = this.dataSource.getConnection();

      ps = stmt.makePreparedStatement(c);

      ps.executeUpdate();
    } catch(SQLException e) {
      throw e;
    } finally {
      if(ps != null) {
        try {
          ps.close();
        } catch(SQLException e) {}
      }

      if(c != null) {
        try {
          c.close();
        } catch(SQLException e) {}
      }
    }
  }
}
~~~
그리고 UserDao가 분리된 JdbcContext를 DI 받을수 있도록 만든다.

~~~java
// JdbcContext를 DI 받아서 사용하도록 만든 UserDao
public class UserDao {
  ...
  private JdbcContext jdbcContext;

  public void setJdbcContext(JdbcContext jdbcContext) {
    this.jdbcContext = jdbcContext;
  }

  public void add(final User user) throws SQLException {
    this.jdbcContext.workWithStatementStrategy(
      new StatementStrategy() { ... }
    );
  }

  public void deleteAll() throws SQLException {
    this.jdbcContext.workWithStatementStrategy(
      new StatementStrategy() { ... }
    );
  }
}
~~~

#### 빈 의존관계 변경
새롭게 작성된 오브젝트 간의 의존관계르 살펴보고 이를 스프링 설정에 적용해보자.

UserDao는 이제 JdbcContext에 의존하고 있다. 그런데 JdbcContext는 인터페이스인 DataSource와는 달리 구체 클래스다. 스프링의 DI는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는 게 목적이다. 하지만 이 경우 JdbcContext는 그 자체로 독립적인 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있을 뿐이고 구현 방법이 바뀔 가능성은 없다. 따라서 인터페이스를 구현하도록 만들지 않았고, UserDao와 JdbcContext는 인터페이스를 사이에 두지 않고 DI를 적용하는 특별한 구조가 된다.

~~~
// JdbcContext를 적용한 UserDao의 의존관계
+-----------+       +---------------+     +---------------+
|UserDao    |       |JdbcContext    |     |DataSource     |
+------------------>--------------------->+---------------+
|add()      |       |contextMethod()|     |getConnection()|
|deleteAll()|       |               |     |               |
+-----------+       +---------------+     +-------+-------+
                                                  △
                                                  |
                                          +-------+-------+
                                          |SimpleDriverDS |
                                          +---------------+
                                          |getConnection()|
                                          |               |
                                          +---------------+
~~~

스프링의 빈 설정은 클래스 레벨이 아니라 런타임 시에 만들어지는 오브젝트 레벨의 의존관계에 따라 정의된다. 빈으로 정의되는 오브젝트 사이의 관계를 그려보면 아래와 같다.

~~~
// JdbcContext가 적용된 빈 오브젝트 관계
+---------------+           +-----------------------+           +-------------------------+
|userDao:UserDao|           |JdbcContext:JdbcContext|           |dataSource:SimpleDriverDS|
+-------------------------->+---------------------------------->+-------------------------+
|jdbcContext    |           |dataSource             |           |driverClass              |
+---------------+           +-----------------------+           |url                      |
                                                                |username                 |
                                                                |password                 |
                                                                +-------------------------+
~~~
기존에는 userDao 빈이 dataSource 빈을 직접 의존했지만 이제는 jdbcContext빈이 그 사이에 끼게 된다.

위의 빈 의존관계를 따라서 XML 설정파일을 수정하자. text-applicationContext.xml을 아래와 같이 수정한다.
~~~XML
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframewordk.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/chema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd">

  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="dataSource" ref="dataSource" /> <!-- 아직 jdbcContext를 적용하지 않은 메소드가 있어서 제거하지 않음-->
    <property name="jdbcContext" ref="jdbcContext" />
  </bean>
  <bean id="jdbcContext" class="springbook.user.dao.JdbcContext">
    <property name="dataSource" ref="dataSource" />
  </bean>

  <bean id="dataSource"
    class="org.springFramework.jdbc.datasource.SimpleDriverDataSource" >
    ...
  </bean>
</beans>
~~~

아직은 userDao의 모든 메소드가 JdbcContext를 사용하는 것은 아니니, 기존 방법을 사용해서 동작하는 메소드를 위해 UserDao가 아직은 dataSource를 DI 받도록 하고 있음에 주의히자.

이제 JdbcContext를 UserDao로부터 완전히 분리하고 DI를 통해 연결될 수 있도록 설정을 마쳤다.

### JdbcContext의 특별한 DI
JdbcContext를 분리하면서 사용했던 DI 방법에 대해 좀 더 생각해보자. UserDao와 JdbcContext 사이에는 인터페이스를 사용하지 않고  DI를 적용했다. 지금까지 적용했던 DI에서는 클래스 레벨에서 구체적인 의존관계가 만들어지지 않도록 인터페이스를 사용헀다. 인터페이스를 적용했기 때문에 코드에서 직접 클래스를 사용하지 않아도 됐고, 그 덕분에 설정을 변경하는 것만으로도 얼마든지 다양한 의존 오브젝트를 변경해서 사용할 수 있게 됐다.

그런데 UserDao는 인터페이스를 거치지 않고 코드에서 바로 JdbcContext 클래스를 사용하고 있다. UserDao와 JdbcContext는 클래스 레벨에서 의존관계가 결정된다. 비록 런타임 시에 DI 방식으로 외부에서 오브젝트를 주입해주는 방식을 사용하긴 했지만, 의존 오브젝트의 구현 클래스를 변경할 수는 없다.

#### 스프링 빈으로 DI
이렇게 인터페이스를 사용하지 않고 DI를 적용하는 것은 문제가 있지 않을까? 스프링 DI의 기본 의도에 맞게 JdbcContext의 메소드를 인터페이스로 뽑아내어 정의해두고, 이를 UserDao에서 사용하게 해야 하지 않을까? 물론 그렇게 해도 상관은 없다. 하지만 꼭 그럴 필요는 없다.

의존관계 주입이라는 개념을 충실히 따르자면, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않게 하고, 런타임 시에 의존할 오브젝트와의 관계를 다이내믹하게 주입해주는 것이 맞다. 따라서 인터페이스를 사용하지 않았다면 엄밀히 말해서 온전한 DI라고 볼 수는 없다. 그러나 스프링의 DI는 넓게 보자면 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC라는 개념을 포괄한다. 그런 의미에서 JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하게 주입했다는 건 Di의 기본을 따르고 있다고 볼 수 있다.

인터페이스를 사용해서 클래스를 자유롭게 변경할 수 있게 하지는 않았지만, JdbcContext를 userDao와 DI구조로 만들어야 할 이유를 생각해보자.

첫째는 JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문이다. JdbcContext는 그 자체로 변경되는 상태정보를 갖고 있지 않다. 내부에서 사용할 dataSource라는 인스턴스 변수는 있지만, dataSource는 읽기전용이므로 JdbcConetxt가 싱글톤이 되는 데 아무런 문제가 없다. JdbcContext는 JDBC 컨테스트 메소드를 제공해주는 일종의 서비스 오브젝트로서 의미가 있고, 그래서 싱글톤으로 등록돼서 여러 오브젝트에서 공유해 사용되는 것이 이상적이다.

둘째는 JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문이다. 이 두 번째 이유가 중요하다. JdbcContext는 dataSource 프로퍼티를 통해 DataSource 오브젝트를 주입받도록 되어 있따. DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록돼야 한다. 스프링이 생성하고 관리하는 IoC 대상이어야 DI에 참여할 수 있기 때문이다. 따라서 JdbcContext는 다른 빈을 DI 받기 위해서라도 스프링 빈으로 등록돼야 한다.

실제로 스프링에는 드물지만 이렇게 인터페이스를 사용하지 않는 클래스를 직접 의존하는 DI가 등장하는 경우도 있다.

여기서 중요한 것은 인터페이스의 사용 여부다. 왜 인터페이스를 사용하지 않았을까? 인터페이스가 없다는 건 UserDao와 JdbcContext가 매우 긴밀한 관계를 가지고 강하게 결합되어 있다는 의미다. UserDao는 항상 JdbcConetxt 클래스와 함께 사용돼야 한다. 비록 클래스는 구분되어 있지만 이 둘은 강한 응집도를 갖고 있다. userDao가 JDBC방식 대신 JPA나 하이버네이트 같은 ORM을 사용해야 한다면 JdbcContext도 통째로 바뀌어야 한다. JdbcContext는 DataSource와 달리 테스트에서도 다른 구현으로 대체해서 사용할 이유가 없다. 이런 경우는 굳이 인터페이스를 두지 말고 강력한 결함을 가진 관계를 허용하면서 위에서 말한 두 가지 이유인, 싱글톤으로 만드는 것과 JdbcContext에 대한 DI 필요성을 위해 스프링의 빈으로 등록해서 UserDao에 DI 되도록 만들어도 좋다.

#### 코드를 이용하는 수동 DI
JdbcContext를 스프링의 빈으로 등록해서 userDao에 DI하는 대신 사용할 수 있는 방법이 있다. UserDao 내부에서 직접 DI를 적용하는 방법이다.

이 방법을 쓰려면 JdbcContext를 스프링의 빈으로 등록해서 사용했던 첫 번째 이유인 싱글톤으로 만들려는 것은 포기해야 한다. 다난 싱글톤을 포기했다고 하더라도 JdbcContext 오브젝트는 DAO마다 하나 씩만 만들어지기 때문에 부담은 거의 없다.

JdbcContext를 스프링 빈으로 등록하지 않았으므로 다른 누군가가 JdbcContext의 생성과 초기화를 책임져야 한다. JdbcContext의 제어권은 UserDao가 갖는 것이 적당하다.

남은 문제는 JdbcContext를 스프링 빈으로 등록해서 사용했던 두 번째 이유다. JdbcContext는 다른 빈을 인터페이스를 통해 간접적으로 의존하고 있다. 다른 빈을 의존하고 있다면, 의존 오브젝트를 DI를 통해 제공받기 위해서라도 자신도 빈으로 등록돼야 한다고 했다. 그렇다면 UserDao에서 JdbcConetxt를 직접 생성해서 사용하는 경우에는 어떻게 해야할까? 여전히 JdbcContext는 dataSource 타입 빈을 다이내믹하게 주입 받아서 사용해야 한다. 그렇지 않으면 DataSource 구현 클래스를 자유롭게 바꿔가면서 적용할 수 없다. 하지만 JdbcContext 자신은 스프링의 빈이 아니니 DI 컨테이너를 통해 DI 받을 수는 없다.

이런 경우에 사용할 수 있는 방법이 한 가지 있다. 그것은 JdbcContext에 대한 제어권을 갖고 생성과 관리를 담당하는 UserDao에게 DI까지 맡기는 것이다. 오브젝트를 생성하고 그 의존 오브젝트를 수정자 메소드로 주입해주는 것이 바로 DI의 동작원리가 아닌가? 그렇다면 UserDao가 임시로 DI 컨테이너처럼 동작하게 만들면 된다.

JdbcContext에 주입해줄 의존 오브젝트인 DataSource는 UserDao가 대신 DI 받도록 하면 된다. UserDao는 직접 DataSource 빈을 필요로 하지 않지만 JdbcContext에 대한 DI 작업에 사용할 용도로 제공받는 것이다. UserDao는 주입받은 DataSource 빈을 JdbcContext를 만들고 초기화하는 과정에만 사용하고 버리면 된다.

스프링의 설정파일에 userDao와 dataSource 두 개만 빈으로 정의한다. 그리고 userDao 빈에 DataSource 타입 프로퍼티를 지정해서 dataSource 빈을 주입받도록 한다. UserDao는 JdbcContext 오브젝트를 만들면서 DI 받은 DataSource 오브젝트를 JdbcContext의 수정자 메소드로 주입해준다. 만들어진 JdbcContext 오브젝트는 userDao의 인스턴스 변수에 저장해두고 사용한다.

복잡해 보이지만 코드를 보며 이해해보자. 먼저 설정 파일에 등록했던 JdbcContext 빈을 제거한다. UserDao의 jdbcContext 프로퍼티도 제거한다. 그리고 UserDao는 DataSource 타입 프로퍼티만 갖도록 한다.

~~~xml
<!-- jdbcContext 빈을 제거한 설정파일 -->
<beans>
  <bean id="userDao" class="springbook.user.dao.UserDao">
    <property name="dataSource" ref="dataSource" />
  </bean>

  <bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
    ...
  </bean>
</beans>
~~~
설정 파일만 보자면 UserDao가 직접 DataSource를 의존하고 있는 것 같지만, 내부적으로는 JdbcContext를 통해 간접적으로 DataSource를 사용하고 있을 뿐이다. 하지만 JdbcContext를 userDao와 묶어서 userDao 빈이라고 생각해보면 빈 레벨에서는 userDao 빈이 dataSource 빈에게 의존하고 있다고 말할 수도 있다.

UserDao는 이제 JdbcContext를 외부에서 주입받을 필요가 없으니 setJdbcContext()는 제거한다. 그리고 setDataSource()메소드를 아래와 같이 수정해준다.

~~~java
// JdbcContext 생성과 DI 작업을 수행하는 setDataSource() 메소드
public class UserDao {
  ...
  private JdbcContext jdbcContext;

  public void setDataSource(DataSource dataSource) {
    this.jdbcContext = new JdbcContext();

    this.jdbcContext.setDataSource(dataSource);

    this.dataSource = dataSource;
  }
}
~~~

setDataSource() 메소드는 DI 컨테이너가 DataSource 오브젝트를 주입해줄 때 호출된다. 이때 JdbcContext에 대한 수동 DI 작업을 진행하면 된다. 먼저 JdbcContext의 오브젝트를 만들어서 인스턴스 변수에 저장해두고, JdbcContext에 userDao가 Di 받은 DataSource오  오브젝트를 주입해주면 완벽한 DI작업이 완료된다. UserDao에서는 JdbcContext가 외부에서 빈으로 만들어져 주입된 것이지, 내부에서 직접 만들고 초기화한 것인지 구분할 필요도 없고 구분할 수도 없다. 필요에 따라서 JdbcContext를 사용하기만 하면 된다.

이 방법의 장점은 굳이 인터페이스를 두지 않아도 될 만큼 긴밀한 관계를 갖는 DAO 클래스와 JdbcContext를 어색하게 따로 빈으로 분리하지 않고 내부에서 직접 만들어 사용하면서도 다른 오브젝트에 대한 DI를 적용할 수 있다는 점이다. 이렇게 한 오브젝트의 수정자 메소드에서 다른 오브젝트를 초기화하고 코드를 이용해 DI 하는 것은 스프링에서도 조종 사용되는 기법이다.

지금까지 JdbcContext와 같이 인터페이스를 사용하지 않고 DAO와 밀접한 관계를 갖는 클래스를 DI에 적용하는 방법 두 가지를 알아봤다. 두 가지 방법 모두 장단점이 있다.

인터페이스를 사용하지 않는 클래스와의 의존관계이지만 스프링의 DI를 이용하기위해 빈으로 등록해서 사용하는 방법은 오브젝트 사이으이 실제 의존관계가 설정파일에 명확하게 드러난다는 장점이 있다. 하지만 DI의 근본적인 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 직접 노출된다는 단점이 있다.

반면에 DAO의 코드를 이용해 수동으로 DI를 하는 방법은 JdbcContext가 UserDao의 내부에서 만들어지고 사용되면서 그 관계를 외부에는 드러내지 않는다는 장점이 있다. 필요에 따라 내부에서 은밀히 DI를 수행하고 그 전략을 외부에는 감출 수 있다. 하지만 JdbcContext를 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI 작업을 위한 부가적인 코드가 필요하다는 단점도 있다.

## 템플릿과 콜백
지금까지 UserDao와 StatementStrategy, JdbcContext를 이용해 만든 코드는 일종의 전략 패턴이 적용된 것이라고 볼 수 있다. 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조다.

전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다. 이런 방식을 스프링에서는 템플릿/콜백 패턴이라고 부른다. 전략 패턴의 컨텍스트를 템플릿이라고 부르고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부른다.

##### 템플릿
템플릿은 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다. 학생들이 도형을 그릴 때 사용하는 도형자 또는 모양자가 바로 템플릿이다. 프로그래밍에서는 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하는 경우에 템플릿이라고 부른다. JSP는 HTML이라는 고정된 부분에 EL과 스크립릿이라는 변하는 부분을 넣은 일종의 템플릿 파일이다. 템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼클래스에 두고, 바뀌는 부분을 서브클래스의 메소드에 두는 구조로 이뤄진다.

##### 콜백
콜백은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다. 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용한다. 자바에선 메소드 자체를 파라미터로 전달할 방법은 없기 때문에 메소드가 담긴 오브젝트를 전달해야 한다. 그래서 펑셔널 오브젝트(functional object)라고도 한다.

### 템플릿/콜백의 동작원리
템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙인 이름이다. 콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.

#### 템플릿/콜백의 특징
여러 개의 메소드를 가진 일반적인 인터페이스를 사용할 수 있는 전략 패턴의 전략과 달린 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다. 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다. 하나의 템플릿에서 여러 가지 종류의 전략을 사용해야 한다면 하나 이상의 콜백 오브젝트를 사용할 수도 있다. 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 보면 된다.

콜백 인터페이스의 메소드에는 보통 파라미터가 있다. 이 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용된다.

JdbcContext에서는 템플릿인 workWithStatementStrategy() 메소드 내에서 생성한 Connection 오브젝트를 콜백의 메소드인 makePreparedStatement()를 실행할 때 파라미터로 넘겨준다. PreparedStatement를 만들기 위해서 JDBC 컨텍스트/템플릿 안에서 만들어진 DB커넥션이 필요하기 때문이다.
~~~
+--------------------+                                                +--------------------+
|client              |                                                |template            |
+--------------------+           (2) Callback 전달 / Template 호출     +--------------------+
|(1)Callback 생성    +----------------------------------------------->|(3) Workflow 시작    |
|        +---------------------+                                      |(4) 참조정보 생성    |
|        |Callback             |  (5) Callback 호출 / 참조정보 전달    |                    |
|        +---------------------|<-------------------------------------|                    |
|        |(6) Client final 변수참조                                    |                    |
|        |(7) 작업 수행         |                                      |                    |
|        |                     |  (8) Callback 작업 결과               |                    |
|        |                     +------------------------------------> |(9) Workflow 진행    |
|        +-----------+---------+                                      |(10) Workflow 마무리 |
|                    |                                                |                    |
|                    |            (11) Template 작업 결과              |                    |
|                    | <----------------------------------------------|                    |
+--------------------+                                                +--------------------+
~~~

- 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공하는 것이다. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.
- 템플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.
- 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다. 경우에 따라 최종 결과를 클라이언트에 다시 돌려주기도 한다.


조금 복잡해 보이지만 DI 방식의 전략 패턴 구조라고 생각하고 보면 간단하다. 클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI다. 템플릿이 사용할 콜백 인터페이스를 구현한 오브젝트를 메소드를 통해 주입해주는 DI 작업이 클라이언트가 템플릿의 기능을 호출하는 것과 동시에 일어난다. 일반적인 DI라면 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용할 것이다. 반면에 템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달바든ㄴ 것이 특징이다. 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 템플릿/콜백의 고유한 특징이다. 클라이언트와 콜백이 강하게 결합된다는 면에서도 일반적인 DI와 조금 다르다.

템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결함한 독특한 활용법이라고 이해할 수 있다. 단순히 전략 패턴으로만 보기엔 독특한 특징이 많으므로 템플릿/콜백을 하나의 고유한 디자인 패턴으로 기억해두면 편리하다. 다만 이 패턴에 녹아 있는 전략 패턴과 수동 DI를 이해할 수 있어야 한다.

#### JdbcContext에 적용된 템플릿/콜백
앞에서 만들었던 UserDao, JdbcContext와 StatementStrategy의 코드에 적용된 템플릿/콜백 패턴을 살펴보자.
아래는 UserDao, JdbcContext를 템플릿/콜백 패턴의 구조에서 살펴본 것이다.
~~~

~~~

### 편리한 콜백의 재활용
템플릿/콜백 방식은 템플릿에 담긴 코드를 여기저기서 반복적으로 사용하는 원시적인 방법에 비해 많은 장점이 있다. 당장에 JdbcContext를 사용하기만 해도 기존에 JDBC기반의 코드를 만들었을 때 발생했던 여러 가지 문제점과 불편함 점을 제거할 수 있다.
클라이언트인 DAO의 메소드는 간결해지고 최소한의 데이터 액세스 로직만 갖고 있게된다.

그런데 이런 템플릿/콜백 방식에서 아쉬운 점이 있다. DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기가 조금 불편하다는 점이다.

#### 콜백의 분리와 재활용
이번에는 복잡한 익명 내부 클래스의 사용을 최소화할 수 있는 방법을 찾아보자. JDBC의 try/catch/finally에 적용했던 방법을 현재 UserDao의 메소드에도 적용해보는 것이다. 만약 분리를 토해 재사용이 가능한 코드를 찾아낼 수 있다면 익명 내부클래스를 사용한 코드를 간결하게 만들 수 도 있다.

아래 클라이언트인 deleteAll() 메소드와 익명 내부 클래스로 만들 콜백 오브젝트의 구조를 다시 살펴보자.

~~~java
// 익명 내부 클래스를 사용한 클라이언트 코드
public void deleteAll() throws SQLException {
  this.jdbcContext.workWithStatementStrategy(
    new StatementStrategy() {// 변하지 않는 콜백 클래스 정의와 오브젝트 생성
      public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        return c.prepareStatement("delete from users"); //변하는 SQL 문장
      }
    }
  )
}
~~~

StatementStrategy 인터페이스의 makePreparedStatement() 메소드를 구현한 콜백 오브젝트 코드를 살펴보면 그 내용은 간단하다. 고정된 SQL 쿼리 하나를 담아서 PreparedStatement를 만드는 게 전부다. 바인딩할 파라미터 없이 미리 만들어진 SQL을 이용해 PreparedStatement를 만들기만 하면 되는 콜백이 적지는 않을 것이다. 즉, deleteAll()과 유사한 내용의 콜백 오브젝가 반복될 가능성이 높다.

그렇다면, 언제나 그랬듯이 중복될 가능성이 있는 자주 바뀌지 않는 부분을 분리해보자. deleteAll() 메소드의 내용을 통틀어서 바뀔 수 있는 것은 오직 "delete from users"라는 문자열 뿐이다. 단순 SQL을 필요로 하는 콜백이라면 나머지 코드는 매번 동일할 것이다. 그렇다면 SQL ㅁ누장만 파라미터로 받아서 바꿀 수 있게 하고 메소드 내용 전체를 분리해 별도의 메소드로 만들어보자.

~~~java
// 변하지 않는 부분을 분리시킨 deleteAll() 메소드
public void deleteAll() throws SQLException {
  executeSql("delete from users"); //변하는 SQL 문장
}

private void executeSql(final String query) throws SQLException {
  this.jdbcContext.workWithStatementStrategy(
    new StatementStrategy() {//변하지 않는 콜백 클래스 정의와 오브젝트 생성
      public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
        return c.prepareStatement(query);
      }
    }
  )
}

~~~
바뀌지 않는 모든 부분을 빼내서 executeSql() 메소드로 만들었다. 바뀌는 부분인 SQL 문장만 파라미터로 받아서 사용하게 만들었다. SQL을 담은 파라미터를 final로 선언해서 익명 내부 클래스인 콜백 안에서 직접 사용할 수 있게 하는 것만 주의하면 된다.

이렇게 해서 재활용 가능한 콜백을 담은 메소드가 만들어졌다. 이제 모든 고정된 SQL을 실행하는 DAO 메소드는 deleteAll() 메소드처럼 executeSql()을 호출하는 한줄이면 끝이다. 복잡한 익명 내부 클래스인 콜백을 직접 만들 필요조차 없어졌다. 처음 try/catch/finally를 다 갖춰서 만들었던 기존의 deleteAll() 메소드와 위의 deleteAll() 메소드를 비교해보자.

변하는 것과 변하지 않는 것을 분리하고 변하지 않는 건 유연하게 재활용할 수 있게 만든다는 간단한 원리를 계속 적용했을 때 이렇게 단순하면서도 안전하게 작성 가능한 JDBC 활용 코드가 완성된다. 바로 이런 게 객체지향 언어와 설계를 사용하는 매력이아닐까.

#### 콜백과 템플릿의 결합
한 단계 더 나아가 보자. executeSql() 메소드는 userDao만 사용하기는 아깝다. 이렇게 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 된다. 엄밀히 말해서 템플릿은 JdbcContext 클래스가 아니라 workWithStatementStrategy() 메소드이므로 JdbcContext 클래스로 콜백 생성과 템플릿 호출이 담긴 executeSql() 메소드를 옮긴다고 해도 문제 될 것은 없다.

먼저 아래와 같이 executeSql 메소드를 옮긴다. 메소드 접근자는 public으로 바꿔서 외부에서 바로 접근이 가능하게 한다.

~~~
// jdbcContext로 옮긴 executeSql() 메소드
public class JdbcContext {
  ...
  public void executeSql(final String query) throws SQLException {
    workWithStatementStrategy(
        new StatementStrategy() {
          public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
            return c.prepareStatement(query);
          }
        }
      )
  }
}
~~~

executeSql() 메소드가 JdbcContext로 이동했으니 UserDao의 메소드에서도 아래처럼 jdbcContext를 통해 executeSql() 메소드를 호출하도록 수정해야 한다.

~~~
// JdbcContext로 옮긴 executeSql()을 사용하는 deleteAll() 메소드
public void deleteAll() throws SQLException {
  thi.jdbcContext.executeSql("delete from users");
}
~~~

이제 모든 DAO 메소드에서 executeSql() 메소드를 사용할 수 있게 됐다. 익명 내부 클래스의 사용으로 조금 복잡해 보였던 클라이언트 메소드는 이제 깔끔하고 단순해졌다.

아래에서 볼 수 있듯이 결국 JdbcContext 안에 클라이언트와 템플릿, 콜백이 모두 함께 공존하면서 동작하는 구조가 됐다.

~~~
// 콜백 재활용을 적용한 JdbcContext
                        +-----------------------+
                        |JdbcContext            |
                        +-----------------------+
                        |<<tempate>>            |
                        |work..()               |<----+
+-----------+           +-----------------------+     |
|UserDao    |           |<<client>>             |     |call template
+-----------+           |executeSql(query)      |     |
|deleteAll()| SQL Query |                       +-----+
|           +---------->+                       |
|           |         +-----------------------+ |
+-----------+         |  <>callback<>         | |
                      |  anonymous inner class| |
                      |                       | |
                      +-----------------------+ |
                        |                       |
                        +-----------------------+                                                                
~~~
일반적으로는 성격이 다른 코드들은 가능한 한 분리하는 편이 낫지만, 이 경우는 반대다. 하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들이기 때문에 한 군데 모여 잇는 게 유리하다. 구체적인 구현과 내부의 전략 패턴, 코드에 의한 DI, 익명 내부 클래스 등의 기술은 최대한 감춰두고, 외부에는 꼭 필요한 기능을 제공하는 단순한 메소드만 노출해주는 것이다.

콜백의 작업이 좀 더 복잡한 add()에도 같은 방법을 적용할 수 있다. add() 메소드의 콜백에서는 SQL 문장과 함께 PreparedStatement에 바인딩될 파라미터 내용이 추가돼야 한다. 바인딩 파라미터의 개수는 일정하지 않으므로 자바 5에서 추가된 가변인자 (varargs)로 정의해두는 것이 좋다. 콜백에서 PreparedStatement를 만든 뒤에 바인딩할 파라미터 타입을 살펴서 적절한 설정 메소드를 호출해주는 작업이 조금 복잡할 수는 있지만, 한 번 만들어두면 매우 편리하게 사용할 수 있으니 도전해볼 만하다.

### 템플릿/콜백의 응용
지금까지 살펴본 템플릿/콜백 패턴은 사실 스프링에서만 사용할 수 있다거나 스프링만이 제공해주는 독점적인 기술은 아니다. 하지만 스프링만큼 이 패턴을 적극적으로 활용하는 프레임워크는 없다. 스프링의 많은 API나 기능을 살펴보면 템플릿/콜백 패턴을 적용한 경우를 많이 발견할 수 있다.

따지고 보면 DI도 순수한 스프링의 기술은 아니다 기본적으로는 객체지향의 장점을 잘 살려서 설계하고 구현하도록 도와주는 여러 가지 원칙과 패턴의 활용 결과일 뿐이다. 스프링은 단지 이를 편리하게 사용할 수 있도록 도와주는 컨테이너를 제공하고, 이런 패턴의 사용 방법을 지지해주는 것뿐이다. 템플릿/콜백 패턴도 DI와 객체지향 설계를 적극적으로 응요한 결과다. 스프링에는 다양한 자바 엔터프라이즈 기술에서 사용할 수 있도록 믿리 만들어져 제공되는 수십 가지 템플릿/콜백 클래스와 API가 있다.

스프링을 사용하는 개발자라면 당연히 스프링이 제공하는 템플릿/콜백 기능을 잘 사용할 수 있어야 한다. 동시에 템플릿/콜백이 필요한 곳이 있으면 직접 만들어서 사용할줄도 알아야 한다. 스프링에 내장된 것을 원리도 ㄴ알지 못한 채로 기계적으로 사용하는 경우와 적용된 패턴을 이해하고 사용하는 경우는 큰 차이가 있다. 스프링이 제공하는 대부분의 기술은 그 구조를 이해하면 손쉽게 확장해서 쓸 수 있다. 기본적으로 OCp를 지키고, 전략 패턴과 DI를 바앝에 깔고 있으니 원한다면 언제든지 확장해서 편리한 방법으로 사용할 수 있다. 그런 면에서 스프링의 기본이 되는 전략 패턴과 DI는 물론이고 템플릿/콜백 패턴도 익숙해지도록 학습할 필요가 있다.

고정된 작업 흐름을 갖고 있으면서 여기저기서 자주 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관을 기르자, 중복된 코드는 먼저 메소드로 분리하는 간단한 시도를 해본다. 그중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략 패턴을 적용하고 DI로 의존관계를 관리하도록 만든다. 그런데 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 이번엔 템플릿/콜백 패턴을 적용하는 것을 고려해볼 수 있다.

가장 전형적인 템플릿/콜백 패턴의 후보는 try/catch/finally 블록을 사용하는 코드다. 일정한 리소스를 만들거나 가져와 작업하면서 예외가 발생할 가능성이 있는 코드는 보톤 try/catch/finally 구조로 코드가 만들어질 가능성이 높다. 예외상황을 처리하기 위한 catchk와 리소스를 반납하거나 제거하는 finally가 필요하기 때문이다. 이런 코드가 한두 번 사용되는 것이 아니라 여기저기서 자주 반복된다면 템플릿/콜백 패턴을 적용하기 적당하다.

#### 테스트와 try/catch/finally
간단한 템플릿/콜백 예제를 만들어보자.
파일을 하나 열어서 모든 라인의 숫자를 더한 합을 돌려주는 코드를 만들어보자. 개발하면서 테스트를 해야 하니까 숫자가 담긴 파일을 먼저 만들어둔다. 다음과 같이 네 개의 숫자를 담고 있는 numbers.txt파일을 하나 준비한다.
~~~
1
2
3
4
~~~

모든 라인의 숫자의 합은 10이다. numbers.txt 파일 경로를 주면 10을 돌려주도록 만들면 된다. 이를 그대로 코드로 표현하면 아래와 같은 테스트로 만들 수 있다.

~~~java
//파일의 숫자 합을 계산하는 코드의 테스트
...
public class ClacSumTest {
  @Test
  public void sumOfNumbers() throws IOException {
    Claculator calculator = new Calculator();
    int sum = calculator.calcSum(getClass().getResource("numbers.txt").getPath());
    assertThat(sum, is(10));
  }
}
~~~
클래스 이름은 Calculator, 메소드는 스트링으로 된 파일 경로를 파라미터로 받는 calcSum()으로 정했다. 아직 테스트 코드만 있으니 컴파일도 안 될 것이다. 간단한 기능이니 바로 코드로 만들어보자. 파일을 열어서 각 라인을 순차적으로 읽는 코드만 만들줄 안다면 간단히 구현할 수 있다.

~~~java
...
public class Calculator {
  public Integer calcSum(String filepath) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader(filepath));
    Integer sum = 0;
    String line = null;
    while((line = br.readLine()) != null) {//마지막 라인까지 한 줄씩 읽어가면서 숫자를 더한다.
      sum += Integer.valueOf(line);
    }

    br.close();
    return sum;
  }
}
~~~
파일을 한 줄씩 읽어올 수 있는 BufferedReader를 만들고 마지막 줄까지 반복해서 읽으면서 미리 만들어둔 sum 변수에 값을 더해주는 간단한 코드다.

초난감 DAO와 마찬가지로 calcSum() 메소드도 파일을 읽거나 처리하다가 예외가 발생하면, 파일이 정상적으로 닫히지 않고 메소드를 빠져나가는 문제가 발생한다. 따라서 try/finally 블록을 적용해서 어떤 경우에라도 파일이 열렸으면 반드시 닫아주도록 만들어야 한다. 그리고 파일을 처리하다가 예외상황이 발생하면 로그를 남기는 기능도 추가해보자. 그러려면 catch 블록도 필요하다.

~~~java
// try/catch/finally를 적용한 calcSum() 메소드
public Integer calcSum(String filepath) throws IOException {
  BufferedReader br = null;

  try {
    br = new BufferedReader(new FileReader(filepath));
    Integer sum = 0;
    String line = null;
    while((line = br.readLine()) != null) {
      sum += Integer.valueOf(line);
    }

    return sum;
  }
  catch(IOException e) {
    System.out.println(e.getMessage());
    throw e;
  }
  finally {
    if(br != null) {
      try { br.close(); }
      catch(IOException e) { System.out.println(e.getMessage()); }
    }
  }
}
~~~

DAO의 JDBC 코드에 적용했던 것과 기본은 개념은 같다. 만들어진 모든 리소스는 확실히 정리하고 빠져나오도록 만드는 것과 모든 예외상황에 대해서는 적절한 처리를 해주도록 하는 것 두 가지다. 만들어야 할 기능이 이게 전부라면, 테스트도 만들었고 예외 상황에 대한 처리도 모두 해줬으니 이쯤에서 마무리해도 좋아 보인다.

#### 중복의 제거와 템플릿/콜백 설계
그런데 이번엔 파일에 있는 모든 숫자의 곱을 계산하는 기능을 추가해야 한다는 요구가 발생했다. Calculator라는 클래스의 이름에 걸맞게 앞으로 많은 파일에 담긴 숫자 데이터를 여러 가지 방식으로 처리하는 기능이 계속 추가될 것이라는 소식도 들려왔다고 생각해보자.

파일을 읽어서 처리하는 비슷한 기능이 새로 필요할 때마다 앞에서 만든 코드를 복사해서 사용할까? 물론 아니어야 한다. 한두 번 까지는 어떻게 넘어간다고 해도, 세 번 이상 반복된다면 본격적으로 코드를 개선할 시점이라고 생각해야한다. 객체지향 언어를 사용하고 객체지향 설계를 통해 코드를 작성하는 개발자의 기본적인 자세다.

템플릿/콜백 패턴을 적용해보자. 먼저 템플릿에 담을 반복되는 작업 흐름은 어떤 것인지 살펴보자. 템플릿이 콜백에게 전달해줄 내부의 정보는 무엇이고, 콜백이 템플릿에게 돌려줄 내욘은 무엇인지도 생각해보자. 이번에는 템플릿이 작업을 마친 뒤 클라이언트에게 전달해줘야 할 것도 있을 것이다. 템플릿/콜백을 적용할 때는 템플릿과 콜백의 경계를 정하고 템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달하는 내용이 무엇인지 파악하는 게 가장 중요하다. 그에 따라 콜백의 인터페이스를 정의해야 하기 때문이다.

가장 쉽게 생각해볼 수 있는 구조는 템플릿이 파일을 열고 각 라인을 읽어올 수 있는 BufferedReader를 만들어서 콜백에게 전달해주고, 콜백이 각 라인을 읽어서 알아서 처리한 후에 최종 결과만 템플릿에게 돌려주는 것이다. 이것을 인터페이스의 메소드로 표현하면 아래와 같다.

~~~java
// BufferedReader를 전달받는 콜백 인터페이스
...
public interface BufferedReaderCallback {
  Integer doSomethingWithReader(BufferedReader br) throws IOException;
}
~~~

이제 템플릿 부분을 메소드로 분리해보자. 템플릿에서는 BufferedReaderCallback 인터페이스 타입의 콜백 오브젝트를 받아서 적절한 시점에 실행해주면 된다. 콜백이 돌려준 결과는 최종적으로 모든 처리를 마친 후에 다시 클라이언트에 돌려주면 된다. 아래는 BufferedReaderCallback을 적용한 템플릿 코드다.

~~~java
// BufferedReaderCallback을 사용하는 템플릿 메소드
public Integer fileReadTemplate(String iflepath, BufferedReaderCallback callback) throws IOException {
  BufferedReader br = null;

  try {
    br = new BufferedReader(new FileReader(filepath));
    int ret = callback.doSomethingWithReader(br);//콜백 오브젝트 호출. 템플릿에서 만든 컨텍스트 정보인 BufferedReader를 전달해주고 콜백의 작업 결과를 받아둔다.
    return ret;
  }
  catch(IOException e) {
    System.out.println(e.getMessage());
    throw e;
  }
  finally {
    if(br != null) {
      try { br.close(); }
      catch(IOException e) { System.out.println(e.getMessage()); }
    }
  }
}
~~~

BufferedReader를 만들어서 넘겨주는 것과 그 외의 모든 번거로운 작업에 대한 작업흐름은 템플릿에서 진행하고, 준비된 BUfferedReader를 이용해 작업을 수행하는 부분은 콜백을 호출해서 처리하도록 만들었다.

이렇게 준비된 fileReadTemplate()을 사용하도록 calcSum() 메소드를 수정해보자.

템플릿으로 분리한 부분을 제외한 나머지 코드를 BufferedReaderCallback 인터페이스로 만든 익명 내부 클래스에 담는다. 처리할 파일의 경로와 함께 준비된 익명 내부 클래스의 오브젝트를 템플릿에 전달한다. 코드를 읽기 편하도록 콜백 오브젝트를 일단 변수에 저장해뒀다가 사용하게 했다. 템플릿이 리턴하는 값을 최종 결과로 사용하면 된다. 아래는 이렇게 수정된 calcSum() 메소드다.

~~~java
// 템플릿/콜백을 적용한 calcSum() 메소드
public Integer calcSum(String filepath) throws IOException {
  BufferedReaderCallback sumCallback =
    new BufferedReaderCallback() {
      public Integer doSomethingWithReader(BufferedReader br) throws IOException {
        Integer sum = 0;
        String line = null;

        while((line = br.readLine()) != null) {
          sum += Integer.valueOf(line);
        }

        return sum;
      }
    };

    return fileReadTemplate(filepath, sumCallback);
}

~~~
이제 파일에 있는 숫자의 곱을 구하는 메소드도 이 템플릿/콜백을 이용해 만들면 된다.

먼저 테스트를 만들어보자. 테스트 메소드가 두 개가 됐는데 사용할 클래스의 오브젝트와 파일 이름이 공유된다. 그렇다면 @Before 메소드에서 미리 픽스처로 만들어두는 게 좋겠다. 두 개쯤이야 그냥 중복돼도 그만일지 모르겠지만, 앞으로 계속 유사한 테스트가 늘어날 것을 생각한다면 미리 테스트 코드도 깔끔하게 정리하는 편이 좋다.

아래는 곱을 계산하는 기능의 테스트 메소드를 추가한 테스트 클래스다.

~~~java
// 새로운 테스트 메소드를 추가한 CalcSumTest
...
public class CalcSumTest {
  Calculator calculator;
  String numFilepath;

  @Before
  public void setUp() {
    this.calculator = new Calculator();
    this.numFilepath = getClass().getResource("numbers.tst").getPath();
  }

  @Test
  public void sumOfNumbers() throws IOException {
    assertThat(calculator.clacSum(this.numFilepath), is(10));
  }

  @Test
  public void multiplyOfNumbers() throws IOException {
    assertThat(calculator.calcMultiply(this.numFilepath), is(24));
  }
}
~~~

이제 이 테스트를 성공시키는 코드를 만들어보자. 아래와 같이 앞에서 만든 sumCallback과 거의 미슷하지만 각 라인의 숫자를 더하는 대신 콥하는 기능을 담은 콜백을 사용하도록 만들어주면 된다.

~~~java
// 곱을 계산하는 콜백을 가진 calcMultiply() 메소드
public Integer calcMultiply(String filepath) throws IOException {
  BufferedReaderCallback multiplyCallback =
    new BufferedReaderCallback() {
      public Integer doSomethingWithReader(BufferedReader br) throws IOException {
        Integer multiply = 1;
        String line = null;

        while((line = br.readLine()) != null) {
          multiply *= Integer.valueOf(line);
        }
        return multiply;
      }
    };

    return fileReadTemplate(filepath, multiplyCallback);
}
~~~
테스트를 진행해도 깔끔하게 성공할 것이다.

#### 템플릿/콜백의 재설계
템플릿/콜백 패턴을 적용해서 파일을 읽어 처리하는 코드를 상당히 깔끔하게 정리할 수 있었다. 이제 try/catch/finally 블록 없이도 파일을 안전하게 처리하는 코드를 사요할 수 있게 됐다.

그런데 위에서 만든 calcSum()과 calcMultiply()에 나오는 두 개의 콜백을 비교해보자. 여기서 또다시 어떤 공통적인 패턴이 발견되진 않는지 주의 깊게 관찰해보자.

~~~
calcMultiply()                            calcSum()
Integer multiply = 1;                     Integer sum = 0;
String line = null;                       String line = null;
while((line = br.readLine()) != null) {   while((line = br.readLine()) != null) {
    multiply *= Integer.valueOf(line);        sum += Integer.valueOf(line);
}                                         }
return multiply;                          return sum;
~~~
조금만 살펴봐도 두 개의 코드가 아주 유사함을 알 수 있다. 먼저 결과를 저장할 변수(multiply, sum)를 초기화하고, BufferedReader를 이용해 파일의 마지막 라인까지 순차적으로 읽으면서 각 라인에서 읽은 내용을 결과를 저장할 변수의 값과 함께 계산하다가, 파일을 다 읽으면서 각 라인에서 읽은 내용을 결과를 저장할 변수의 값과 함께 계산하다가, 파일을 다 읽었으면 결과를 저장하고 있는 변수의 값을 리턴한다.

템플릿과 콜백을 찾아낼 때는, 변하는 코드의 경계를 찾고 그 경계를 사이에 두고 주고받는 일정한 정보가 있는지 확인하면 된다고 했다. 여기서 바뀌는 코드는 실제로 네 번째 줄뿐이다. 앞에서 네 번째 라인으로 전달하는 정보는 첨으에 선언한 변수 값인 multiply 또는 sum이다. 그 네 번째 라인을 처리하고 다시 외부로 전달되는 것은 multiply 또는 sum과 각 라인의 숫자 값을 가지고 계산한 결과다.

이를 콜백 인터페이스로 정의해보면 아래와 같다.
~~~java
// 라인별 작업을 정의한 콜백 인터페이스
...
public interface LineCallback {
  Integer doSomthingWithLine(String line, Integer value);
}
~~~

LineCallback은 파일의 각 라인과 현재까지 계산한 값을 넘겨주도록 되어 있다. 그리고 새로운 계산 결과를 리턴 값을 통해 다시 전달받는다. 이 콜백을 기준으로 코드를 다시 정리해보면 템플릿에 포함되는 작업 흐름은 더 많아지고 콜백은 단순해질 것이다.

아리는 새로 만든 LineCallback 인터페이스를 경계로 해서 만든 새로운 템플릿이다.

~~~java
// LineCallback을 사용하는 템플릿
public Integer lineReadTemplate(String filepath, LienCallback callback, int initVal) throws IOException {
  BufferedReader br = null;
  try {
    br = new BufferedReader(new FileReader(filepath));
    Integer res = initVal;
    String line = null;
    while((line = br.readLine()) != null) {
      res = callback.doSomethingWithLine(line, res);
    }
    return res;
  }
  catch(IOException e) { ... }
  finally { ... }
}
~~~

템플릿에 파일의 각 라인을 읽는 작업이 추가됐다. 계산 결과를 담을 변수를 초기화할 값도 파라미터도 전달받게 만들었다. 새로 만든 템플릿이 기존에 만들었던 템플릿들과 다른 점은 while 뤂 안에서 콜백을 호출한다는 점이다. 콜백을 여러 번 반복적으로 호출하는 구조가 된 것이다.

이번엔 이렇게 수정한 템플릿을 사용하는 코드를 만들어보자. 아래에서 볼 수 있듯이 코드는 이전보다 간결해졌다. 익명 내부 클래스 때문에 라인 수가 많아 보이긴 하지만 사실 핵심 코드는 딱 한 줄뿐이다.

~~~java
// lineReadTemplate()을 사용하도록 수정한 calSum(), calcMultiply() 메소드
public Integer calcSum(String filepath) throws IOException {
  LineCallback sumCallback =
    new LineCallback() {
      public Integer doSomethingWithLine(String line, Integer value) {
        return value + Integer.valueOf(line);
      }
    };

    return lienReadTemplate(filepath, sumCallback, 0);
}

public Integer calcMultiply(String filepath) throws IOException {
  LineCallback multiplyCallback =
    new LineCallback() {
      public Integer doSomethingWithLine(String line, Integer value) {
        return value * Integer.valueOf(line);
      }
    };

  return lineReadTemlate(filepath, multiplyCallback, 1);
}
~~~
앞에서 만들었던 코드보다 깔끔하고 보기 좋다. 여타 로우레벨의 파일 처리 코드가 템플릿으로 분리되고 순수한 계산 로직만 남아 있기 때문에 코드의 관심이 무엇인지 명확하게 보인다. Calculator 클래스와 메소드는 데이터를 가져와 계산한다는 핵심 기능에 충실한 코드만 갖고 있게 됐다.

간다한 예제를 통해 살폅봤듯이 템플릿/콜백 패턴은 다양한 작업에 손쉽게 활용할 수 있다. 콜백이라는 이름이 의미하는 것처럼 다시 불려지는 기능을 만들어서 보내고 템플릿과 콜백, 클라이언트 사이에 정보를 주고받는 일이 청므에는 조금 복잡하게 느껴질지도 모르겠다. 하지만 코드의 특성이 바뀌는 경계를 잘 살피고 그것을 인터페이스를 사용해 분리한다는, 가장 기본적인 객체지향 원칙에만 충실하면 어렵지 않게 템플릿/콜백 패턴을 만들어 활용할 수 있을 것이다.

#### 제네릭스를 이용한 콜백 인터페이스
자바 5에서 추가된 언어적인 특징을 잘 활용하면 좀 더 강력한 템플릿/콜백 구조를 만들 수 있다. 지금까지 사용한 LineCallback과 lineReadTemplate()은 템플릿과 콜백이 만들어내는 결과가 Integer 타입으로 거정되어 있다. 만약 파일을 라인 단위로 처리해서 만드는 결과의 타입을 다양하게 가져가고 싶다면, 자바 언어에 타입 파라미터라는 개념을 도입한 제네릭스(generics)를 이용하면 된다. 제네릭스를 이용하면 다양한 오브젝트 타입을 지원하는 인터페이스나 메소드를 정의할 수 있다.

파일의 각 라인에 있는 문자를 모두 연결해서 하나의 스트링으로 돌려주는 기능을 만든다고 생각해보자. 이번에는 템플릿이 리턴하는 타입이 스트린이어야 한다. 콜백의 작업 결과도 스트링이어야 한다. 기존에 만들었던 Integer 타입의 결과만 다루는 콜백과 템플릿을 스트링 타입의 값도 처리할 수 있도록 확장해보자.

아래와 같이 콜백 인터페이스를 수정한다. 콜백 메소드의 리턴 값과 파라미터 값의 타입을 제네릭 타입 파라미터 T로 선언한다.
~~~java
// 타입 파라미터를 적용한 LineCallback
public interface LineCallback<T> {
  T doSomethingWithLine(String lien, T value);
}
~~~

다음은 템플릿인 lineReadTemplate() 메소드도 아래와 같이 타입 파라미터를 사용해 제네릭 메소드로 만들어준다. 콜백의 타입 파라미터와 초기값인 initVal의 타입 그리고 템플릿의 결과 값 타입을 모두 동일하게 선언해야 한다.

~~~java
// 타입 파라미터를 추가해서 제네릭 메소드로 만든 lineReadTemplate()
public <T> T lineReadTemplate(String filepath, LineCallback<T> callback, T initVal) throws IOException {
  BufferedReader br = null;
  try {
    br = new BufferedReader(new FileReader(filepath));
    T res = initVal;
    String line = null;
    while((line = br.readLine()) != null) {
      res = callback.doSomethingWithLine(line, res);
    }
    return res;
  }
  catch(IOException e) { ... }
  finally { ... }
}
~~~
lineReadTemplate() 메소드는 이제 타입 파라미터 T를 갖는 인터페이스 LineCallback 타입의 오브젝트와 T 타입의 초기값 initVal을 받아서, T 타입의 변수 res를 정의하고, T 타입 파라미터로 선언된 LineCallback의 메소드를 호출해서 처리한 후에 T 타입의 결과를 리턴하는 메소드가 되는 것이다. 이제 LineCallback 콜백과 lineReadTemplate() 템플릿은 파일의 라인을 처리해서 T 타입의 결과를 만들어내는 범용적인 템플릿/콜백이 됐다. 제네릭스 코드에 익숙하지 않으면 타입 파라미터가 많아서 처음 보기에는 복잡해 보일 수 있다. 이럴 땐 타입 파라미터 T를 Integer나 String 같은 특정 타입으로 모두 바꿔서 생각해보면 이해하는 데 도움이 될 것이다.

이제 파일의 모든 라인의 내용을 하나의 문자열로 길게 연결하는 기능을 가진 메소드를 추가해보자. 아래처럼 콜백을 정의할 때 사용할 타입을 지정하면 된다.

~~~java
// 문자열 연결 기능 콜백을 이용해 만든 concatenate() 메소드
public String concatenate(String filepath) throws IOException {
  LineCallback<String> concatenateCallback =
    new LineCallback<String>() {
      public String doSomethingWithLine(String lien, String value) {
        return value + line;
      }
    };
  return lienReadTemplate(filepath, concatenateCallback, "");
}
~~~

각 메소드의 파라미터 타입을 잘 살펴보자. 최종적으로 lineReadTemplate()메소드의 결과도 스트링 타입이 돼서 concatenate() 메소드의 리턴 타입도 스트링으로 정의할 수 있게 됐다.

concatenate() 메소드에 대한 테스트는 아래와 같이 만들 수 있다.
~~~java
@Test
public void concatenateStrings() throws IOException {
  assertThat(calculator.concatenate(this.numFilepath), is("1234"));
}
~~~
파일의 각 라인의 내용을 숫자로 바꾸지 않고 스트링으로 연결하기 때문에 최종 결과가 "1234"가 돼야 한다. 테스트는 물론 성공이다.

기존에 만들었던 calcSum()과 calcMultiply()는 다음과 같이 Integer 타입 파라미터를 가진 인터페이스로 정의해주기만 하면 그대로 사용할 수 있다.

~~~java
LineCallback<Integer> sumCallback =
  new LineCallback<Integer>() { ... };
~~~

이렇게 범용적으로 만들어진 템플릿/콜백을 이용하면 파일을 라인 단위로 처리하는 다양한 기능을 편리하게 만들 수 있다.

새롭게 살펴본 리턴 값을 갖는 템플릿이나 템플릿 내에서 여러 번 호출되는 콜백 오브젝트, 또 제네릭스 타입을 갖는 메소드나 콜백 인터페이스 등의 기법은 스프링의 템플릿/콜백 패턴이 적용된 곳에서 종종 사용되고 있다.

## 스프링의 JdbcTemplate
템플릿과 콜백의 기본적인 원리와 동작방식, 만드는 방법을 알아봤으니 이번에는 스프링이 제공하는 템플릿/콜백 기술을 살펴보자. 스프링은 JDBC를 이용하는 DAO에서 사용할 수 있도록 준비된 다양한 템플릿과 콜백을 제공한다. 거의 모든 종류의 JDBC코드에 사용 가능한 템플릿과 콜백을 제공할 뿐만 아니라, 자주 사용되는 패턴을 가진 콜백은 다시 템플릿에 결합시켜서 간단한 메소드 호출만으로 사용이 가능하도록 만들어져 있기 때문에 템플릿/콜백 방식의 기술을 사용하고 있는지 모르고도 쓸 수 있을 정도로 편리하다.

스프링이 제공하는 JDBC 코드용 기본 템플릿은 JdbcTemplate이다. 앞에서 만들었던 JdbcContext와 유사하지만 훨씬 강력하고 편리한 기능을 제공해준다. 아쉽지만 지금까지 만들었던 JdbcContext는 버리고 스프링의 JdbcTemplate으로 바꿔보자.

현재 UserDao는 DataSource를 DI 받아서 JdbcContext에 주입해 템플릿 오브젝트로 만들어서 사용한다. 이제 JdbcContext를 아래와 같이 JdbcTemplate으로 변경하자. JdbcTemplate은 생성자의 파라미터로 DataSource를 주입하면 된다.

~~~java
// JdbcTemplate의 초기화를 위한 코드
public class UserDao {
  ...
  private JdbcTemplate jdbcTemplate;

  public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);

    this.dataSource = dataSource;
  }
}
~~~
이제 템플릿을 사용할 준비가 됐다.

### update()
deleteAll()에 먼저 적용해보자. deleteAll()에 처음 적용했던 콜백은 StatementStrategy 인터페이스의 makePreparedStatement() 메소드다. 이에 대응되는 JdbcTemplate의 콜백은 PreparedStatementCreator 인터페이스의 createPreparedStatement() 메소드다. 템플릿으로부터 Connection을 제공받아서 PreparedStatement를 만들어 돌려준다는 면에서 구조는 동일하다. PreparedStatementCreator 타입의 콜백을 받아서 사용하는 JdbcTemplate()의 템플릿 메소드는 update()다.

아래는 JdbcTemplate의 콜백과 템플릿 메소드를 사용하도록 수정한 deleteAll() 메소드다.
~~~java
// JdbcTemplate을 적용한 deleteAll() 메소드
public void deleteAll() {
  this.jdbcTempate.update(
    new PreparedStatementCreator() {
      public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
        return con.prepareStatement("delete from users");
      }
    }
  );
}
~~~
앞에서 만들었던 executeSql()은 SQL 문장만 전달하면 미리 준비된 콜백을 만들어서 템플릿을 호출하는 것까지 한 번에 해주는 편리한 메소드였다. JdbcTemplate에도 기능이 비슷한 메소드가 존재한다. 콜백을 받는 update() 메소드와 일므은 동일한데 파라미터로 SQL 문장을 전달한다는 것만 다르다. 아래는 JdbcTemplate의 내장 콜백을 사용하는 메소드를 호출하도록 수정했다.

~~~java
// 내장 콜백을 사용하는 update()로 변경한 deleteAll() 메소드
public void deleteAll() {
  this.jdbcTemplate.update("delete from users");
}
~~~
JdbcTemplate은 앞에서 구상만 해보고 만들지도 못했던 add() 메소드에 대한 편리한 메소드도 제공된다. 치환자를 가진 SQL로 PreparedStatement를 만들고 함께 제공하는 파라미터를 순서대로 바인딩해주는 기능을 가진 update() 메소드를 사용할 수 있다. SQL과 함께 가변인자로 선언된 파라미터를 제공해주면 된다.

현재 add() 메소드에서 만든느 콜백은 아래와 같이 PreapredStatement를 만드는 것과 파라미터를 바인딩하는 두 가지 작업을 수행한다.

~~~java
// add() 메소드의 콜백 내부
PreparedStatement ps =
  c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
ps.setString(1, user.getId());
ps.setString(2, user.getName());
ps.setString(3, user.getPassword());
~~~
이를 JdbcTemplate에서 제공하는 편리한 메소드로 바꿔보면 다음과 같이 간단하게 바꿀 수 있다. PreparedStatement를 만들 때 사용하는 SQL은 동일하며 바인딩할 파라미터는 순서대로 넣어주면 된다.

~~~java
this.jdbcTemplate.update("insert into users(id, name, password) values(?, ?, ?)",
  user.getId(), user.getName(), user.getPassword());
~~~
JdbcContext를 이용하던 UserDao 메소드를 모두 스프링이 제공하는 JdbcTemplate으로 변경했다. 이쯤에서 테스트를 해도 깔끔하게 성공할 것이다.

### queryForInt()
다음은 아직 템플릿/콜백 방식을 적용하지 않았던 메소드에 JdbcTemplate을 적용해보자.

getCount()는 SQL 쿼리를 실행하고 ResultSet을 통해 결과 값을 가져오는 코드다. 이런 작업 흐름을 가진 코드에서 사용할 수 있는 템플릿은 PreparedStatementCreator 콜백과 ResultSetExtractor 콜백을 파리미터로 받는 query() 메소드다.

PreparedStatementCreator는 update()에서 사용해봤으니 그 용도를 잘 알 것이다. ResultSetExtractor는 PreparedStatement의 쿼리를 실행해서 얻은 resultSet을 전달받는 콜백이다. ResultSetExtractor 콜백은 템플릿이 제공하는 ResultSet을 이용해 원하는 값을 추출해서 템플릿에 전달하면, 템플릿은 나머지 작업을 수행한 뒤에 그 값을 query() 메소드의 리턴 값으로 돌려준다.

콜백이 두 개 등장하는 족므 복잡해 보이는 구조이지만 템플릿/콜백의 동작방식을 잘 생각해보면 어렵지 않게 이해할 수 있다. 첫 번째 PreparedStatementCreator콜백은 템플릿으로부터 Connection을 받고 PreparedStatement를 돌려준다. 두 번째 ResultSetExtractor는 템플릿으로부터 ReusltSet을 받고 거기서 추출한 결과를 돌려준다. 잘 이해가 안 되면 기존의 getCount() 메소드에서 각 콜백에 해당하는 부분이 어떤 것이고, 템플릿 메소드와 어떤 정보를 주고받지를 잘 생각해보자.

아래는 JdbcTemplate을 사용하도록 수정한 getCount() 메소드다.
~~~java
// JdbcTemplate을 이용해 만든 getCount()
public int getCount() {
  return this.jdbcTemplate.query(new PreparedStatementCreator() {
    public PreparedStatement createPreparedStatement(Connection con) throws SQLException {
      return con.prepareStatement("select count(*) from users");
    }
  }, new ResultSetExtractor<Integer>() {
    public Integer extractData(ResultSet rs) throws SQLException, DataAccessException {
      rs.next();
      return rs.getInt(1);
    }
  });
}
~~~
콜백을 만드느라 익명 내부 클래스가 두 번이나 등장을 하지 정신이 없을 수 있지만 꼼꼼히 보자. 원래 getCount() 메소드에 있던 코드 중에서 변하는 부분만 콜백으로 만들어져서 제공된다고 생각하면 이해하기 쉽다. 앞에서 만들었던 lineReadTemplate()과 유사하게 두 번째 콜백에서 리턴하는 값은 결국 템플릿 메소드의 결과로 다시 리턴된다. 원래 클라이언트/템플릿/콜백의 3단계 구조이니, 콜백이 만들어낸 결과는 템플릿을 거쳐야만 클라이언트인 getCount() 메소드로 넘어오는 것이다.

또 한 가지 눈여겨볼 것은 ResultSetExtractor는 제네릭스 타입 파라미터를 갖는다는 점이다. lineReadTemplate()과 LineCallback에 적용해봤던 방법과 동일하다. ResultSet에서 추출할 수 있는 값의 타입은 다양하기 때문에 타입 파라미터를 사용한 것이다. ResultSetExtractor 콜백에 지정한 타입은 제네릭 메소드에 적용돼서 query() 템플릿의 리턴 타입도 함께 바뀐다.

위의 콜백 오브젝트 코드는 재사용하기 좋은 구조다. SQL을 가지고 PreparedStatement를 만드는 첫 번째 콜백은 이미 재사용 방법을 알아봤다. 두 번째 콜백도 간단하다. SQL의 실행 결과가 하나의 정수 값이 되는 경우는 자주 볼 수 있다. 클라이언트에서 콜백의 작업을 위해 특별히 제공할 값도 없어서 단순하다. 손쉽게 ResultSetExtractor 콜백을 템플릿 안으로 옮겨 재활용할 수 있다.

JdbcTempalte은 이런 기능을 가진 콜백을 내장하고 있는 queryForInt() 라는 편리한 메소드를 제공한다. Integer 타입의 결과를 가져올 수 있는 SQL 문장만 전달해주면 된다. 이를 이용하면 위처럼 이중 콜백을 사용하는 제법 복잡해 보이는 메소드를 아래와 같이 한 줄로 바꿀 수 있다.
~~~java
// queryForInt()를 사용하도록 수정한 getCount()
public int getCount() {
  return this.jdbcTemplate.queryForInt("select count(*) from users");
}
~~~
이전에 구현했던 34라인짜리 getCount() 메소드가 이제 단 한 줄로 바뀌었다. 물론 예외처리와 안전한 리소스 반환, DI 된 DataSource를 이용하는 것까지 기능은 모두 동일하다. 템플릿/콜백을 사용하지 않을 이유가 없다. JdbcTemplate은 스프링이 제공하는 클래스이지만 DI 컨테이너를 굳이 필요로 하지 않는다. userDao에서 처럼 직접 JdbcTemplate 오브젝트를 생성하고 필요한 DataSource를 전달해주기만 하면 JdbcTemplate의 모든 기능을 자유롭게 활용할 수 있다.

### queryForObject()
이번엔 get() 메소드에 JdbcTemplate을 적용해보자. get() 메소드는 지금까지 만들었던 것 중에서 가장 복잡하다. 일단 SQL은 바인딩이 필요한 치환자를 갖고 있다. 이것까지는 add()에서 사용했던 방법을 적용하면 될 것 같다. 남은 것은 ResultSet에서 getCount()처럼 단순한 값이 아니라 복잡한 User 오브젝트로 만드는 작업이다. ResultSet의 결과를 User오브젝트를 만들어 프로퍼티에 넣어줘야 한다.

이를 위해, getCount()에 적용했던 ResultSetExtractor 콜백 대신 RowMapper 콜백을 사용하자. ResultSetExtor와 RowMapper 모두 템플릿으로부터 ResultSet을 전달받고, 필요한 정보를 추출해서 리턴하는 방식으로 동작한다. 다른 점은 ResultSetExtractor는 ResultSet을 한 번 전달받아 알아서 추출 작업을 모두 진행하고 최종 결과만 리턴해주면 되는 데 반해, RowMapper는 ResultSet의 로우 하나를 매핑하기 위해 사용되기 때문에 여러 번 호출될 수 있다는 점이다.

기본키 값으로 조회하는 get()메소드 SQL의 실행 결과는 로우가 하나인 ResultSet이다. ResultSet의 철 번째 로우에 RowMapper를 적용하도록 만들면 된다. RowMapper콜백은 철 번째 로우에 담긴 정보를 하나의 User 오브젝트에 매핑하게 해주면 된다.

이번에 사용할 템플릿 메소드는 queryForObject()다. queryForObject와 RowMapper를 적용한 아래의 코드를 살펴보자.

~~~java
// queryForObject()와 RowMapper를 적용한 get()메소드
public User get(String id) {
  return this.jdbcTemplate.queryForObject("select * rom users where id = ?",
  new Object[] {id},
  new RowMapper<User>() {
    public User mapRow(ResultSet rs, int rowNum) throws SQLException {
      User user = new User();
      user.setId(rs.getString("id"));
      user.setName(rs.getString("name"));
      user.setPassword(rs.getString("password"));
      return user;
    }
  }
}
~~~


첫 번째 파라미터는 PreparedStatement를 만들기 위한 SQL이고, 두 번째는 여기에 바인딩할 값들이다. update()에서처럼 가변인자를 사용하면 좋겠지만 뒤에 다른 파라미터가 있기 때문에 이 경우엔 가변인자 대신 Object 타입 배열을 사용해야 한다. 배열 초기화 블록을 사용해서 SQL의 ?에 바인딩할 id 값을 전달한다. queryForObject() 내부에서 이 두 가지 파라미터를 사용하는 PreparedStatement 콜백이 만들어질 것이다.

queryForObject()는 SQL을 실행하면 한 개의 로우만 얻을 것이라고 기대한다. 그리고 ResultSet의 next()를 실행해서 첫 번째 로우로 이동시킨 후에 RowMapper 콜백을 호출한다. 이미 RowMapper가 호출되느느 시점에서 ResultSet은 첫 번째 로우를 가리키고 있으므로 다시 rs.next()를 호출할 필요는 없다. RowMapper에서는 현재 ResultSet이 가리키고 있는 로우의 내용을 User 오브젝트에 그대로 담아서 리턴해주기만 함ㄴ 된다. RowMapper가 리턴한 User 오브젝트는 queryForObject() 메소드의 리턴 값으로 get()메소드에 전달된다.

이렇게만 해도 일단 User 오브젝트를 조회하는 get() 메소드의 기본 기능은 충분히 구현됐다. 하지만 get() 메소드에는 한 가지 더 고려해야할 게 있다. 기존의 get()메소드는 조회 결과가 없을 때 EmptyResultDataAccessException을 던지도록 만들었다. 이 예외상황에 대한 테스트까지 만들어뒀다.

그렇다면 queryForObject()를 이용할 때는 조회 결과가 없는 예외상황을 어떻게 처리해야 할까? 이를 위해 특별히 해줄 것은 없다. 이미 queryForObject()는 SQL을 실행해서 받은 로우의 개수가 하나가 아니라면 예외를 던지도록 만들어져 있다. 이때  던저지는 예외가 바로 EmptyResultDataAccessException이다. 기존의 get() 메소드에서 사용하던 것과 동일한 예외다. 원래 EmptyResultDataAccessException은 JdbcTemplate의 queryForObject() 등에서 사용하려고 만든 것인데, 이를 미리 가져다 썼던 것이다.

따라서 위의 get() 메소드에 별다른 예외처리를 추가하지 않아도, 조회가 실패했을 경우를 테스트하려고 만든 UserDaoTest의 getUserFailure() 테스트는 여전히 성공할 것이다.

### query()
#### 기능 정의와 테스트 작성
RowMapper를 좀 더 사용해보자. 현재 등록되어 있는 모든 사용자 정보를 가져오는 getALL() 메소드를 추가한다. getAll()은 테이블의 모든 로우를 다 가져오면 된다. 그렇다면 어떤 포맷으로 변환하는 것이 좋을까? get() 메소드는 하나의 로우를 User 오브젝트에 담았으니 여러 개라면 User 오브젝트의 컬렉션으로 만든다. List<User> 타입으로 돌려주는 게 가장 나을 것 같다. 리스트에 담는 순서는 어떻게 할까? 순서를 정하지 않고 가져올 수도 있지만 그보다는 기본키인 id 순으로 정렬해서 가져오도록 만들자.

이번에도 테스트를 먼저 만들어보자. 방금 결정한 두 가지 기능을 그대로 코드화하면 테스트가 된다. 테스트를 하려면 검증이 필요하니까 검증이 가능한 예를 가지고 다시 구체적으로 정리해보자. User 타입의 오브젝트인 user1, user2, user3 세 개를 DB에 등록하고 getAll()을 호출하면 List<user> 타입으로 결과를 돌려받아야 한다. 리스트의 크기는 3이어야 하고 user1, user2, user3와 동일한 내용을 가진 오브젝트가 id 순서대로 담겨 있어야 한다. 저장할 때의 User 오브젝트와 getAll()로 가져온 User 오브젝트를 비교할 때는 동일성 비교가 아니라 동등성 비교를 해야 한다는 점에 주의하자.

꼼꼼하게 테스트하기 위해 user1, user2, user3를 하나씩 추가하면서 매번 getAll()을 실행해서 결과를 확인해보자. 불필요하게 테스트를 복잡하게 하는 건 별로 좋은 습관은 아니지만, 성의 없이 결과 한 가지만 검사해보는 것도 위험하다. 최소한 두 가지 이상의 테스트 조건에 대해 기대한 결과를 확인해봐야 한다.

getAll() 에 대한 정리 내용을 코드로 표현해보면 아래와 같이 만들어질 것이다.

~~~java
// getAll()에 대한 테스트
@Test
public void getAll() {
  dao.deleteAll();

  da.add(user1);
  List<User> users1 = dao.getAll();
  assertThat(users1.size(), is(1));
  checkSameUser(user1, users1.get(0));

  dao.add(user2);
  List<User> user2 = dao.getAll();
  assertThat(users2.size(), is(2));
  checkSameUser(user1, users2.get(0));
  checkSameUser(user2, users2.get(1));

  dao.add(user3);
  List<User> users3 = dao.getAll();
  List<User> users3 = dao.getAll();
  assertThat(users3.size(), is(3));
  checkSameUser(user1, users3.get(0));
  checkSameUser(user2, users3.get(1));
  checkSameUser(user3, users3.get(2));
}

private void checkSameUser(User user, User user2) {
  assertThat(user1.getId(), is(user2.getId()));
  assertThat(user1.getName(), is(user2.getName()));
  assertThat(user1.getPassword(), is(user2.getPassword()));
}
~~~

UserDaoTest 안에 픽스처로 준비해둔 user1, user2, user3를 차례로 추가하면서 getAll()이 돌려주는 리스트의 크기와 리스트에 담긴 User 오브젝트의 내용을 픽스처와 비교한다. 이때 Id 순서대로 정렬된다는 점을 주의하자. 그래서 suer3는 가장 마지막에 추가되지만 getALL()의 결과에선 가장 첫 번째여야 한다. User의 값을 비교하는 코드가 반복되기 때문에 별도의 메소드로 분리한다. @Test나 @Before 등의 애노테이션이 붙지 않는 메소드에 테스트 코드에서 반복적으로 나타나는 코드를 담아두고 재사용하는 건 좋은 습관이다. 여러 테스트 클래스에 걸쳐 재사용되는 코드라면 별도의 클래스로 분리하는 것도 고려해볼 수 있다.

#### query() 템플릿을 이용하는 getAll() 구현
이제 이 테스트를 성공시키는 getAll() 메소드를 만들어보자. 이번에는 JdbcTemplate의 query() 메소드를 사용하자. 앞에서 사용한 queryForObject()는 쿼리의 결과가 로우 하나일 때 사용하고, query()는 여러 개의 로우가 결과로 나오는 일반적인 경우에 쓸 수 있다. query()의 리턴 타입은 List<T>다. query()는 제네릭 메소드로 타입은 파라미터로 넘기는 RowMapper<T> 콜백 오브젝트에서 결정된다.

아래는 query()를 이용해 만든 getAll() 메소드다.
~~~java
// getAll() 메소드
public List<User> getAll() {
  return this.jdbcTemplate.query("select * from users order by id",
    new RowMapper<User>() {
      public User mapRow(ResultSet rs, int rowNum) throws IOException {
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));
        return user;
      }
    });
}
~~~

첫 번째 파라미터에는 실행할 SQL 쿼리를 넣는다. 바인딩할 파라미터가 있다면 두 번째 파라미터에 추가할 수도 있다. 파라미터가 없다면 생략할 수 있다. 마지막 파라미터는 RowMapper 콜백이다. query() 템플릿은 SQL을 실행해서 얻은 ResultSet의 모든 로우를 열람하면서 로우마다 RowMapper 콜백을 호출한다. SQL 쿼리를 실행해 DB에서 가져오는 로우의 개수만큼 호출될 것이다. RowMapper는 현재 로우의 내용을 User 타입에서 오브젝트에 매핑해서 돌려준다. 이렇게 만들어진 User 오브젝트는 템플릿이 미리 준비한 List<User> 컬렉션에 추가된다. 모든 로우에 대한 작업을 마치면 모든 로우에 대한 User 오브젝트를 담고 있는 List<User> 오브젝트가 리턴된다.

#### 테스트 보완
성공적인 테스트 결과를 보면 빨리 다음 기능으로 넘어가고 싶겠지만 너무 서두르는 것은 좋지 않다. 항상 꼼꼼하게 빠진 것은 없는지 더 개선할 부분은 없는지 한 번쯤 생각해보자.

get()과 마찬가지로 getAll()에서도 예외적인 조건에 대한 테스트를 빼먹지 말아야 한다. 보통은 getAll()을 테스트하라고 하면 레코드 몇 개를 추가하고서 그 결과만 확인하고 말기 쉽다. 긍정적인 결과만 테스트 하는 것이다. 현명한 개발자가 되려면 그보다 좀 부정적인 자세가 필요하다.

네거티브 테스트라고 불리는, 예외상황에 대한 테스트는 항상 빼먹기 쉽다. get()이라면 Id가 없을 때는 어떻게 되는지, getAll()이라면 결과가 하나도 없는 경우에는 어떻게 되는지를 검증하는 것이 네거티브 테스트다.

품질팀이나 고객이 가끔 하는 불평 중의 하나는 개발자들은 수동 테스트를 할 때 재주 좋게도 실패할 만한 상황은 요리조리 잘 피해간다는 것이다. 그래서 개발자가 잘 동작할 것이라고 자신있게 가져오는 코드를 QA팀이나 고객이 몇 분만 테스트해보면 각종 에러와 오류가 줄줄 발견되기도 한다. 어떻게 하면 자신이 만든 코드가 정상적인 흐름에 따라 동작할지를 잘 알고 있는 개발자와는 달리 전문 테스터는 숫자를 입력해야할 곳에 문자를 넣고, 생일에 음수 값을 넣고, 또는 아무것도 입력하지 않고 폼의 저장버튼을 누르기도 한다. DB에 아무런 데이터가 없는 채로 조회하거나, 엉터리 검색 조건을 넣는 것도 테스트에서 자주 사용하는 방법이다. 문제는 개발자들은 이런 예외적인 상황에 대한 검증을 잘 안 하려는 습관이 있다는 점이다. 그래서 테스트도 정상적인 조건에 대한 검증만 하고 넘어가기 쉽다.

만약 getAll()에서 결과가 없다면 어떻게 해야 할까? 이런 질문은 항상 마지막에 나오는 경향이 있다. 또는 아예 고려조차 안 하기도 한다. 그래서 문제가 발생하는 경우는 주로 이런 예외적인 조건과 결과 때문이다. 그래서 같은 개발자가 만든 조회용 메소드인데도 어떤 메소드는 데이터가 없으면 null을 리턴하고, 어떤 메소드는 빈 리스트 오브젝트를 리턴하고, 어떤 메소드는 예외를 던지고, 어떤 메소드는 NullPointerException 같은 런타임 예외가 발생하면서 뻗어버리기도 하는 것이다. 그래서 미리 예외상황에 대한 일관성 있는 기준을 정해두고 이를 테스트로 만들어 검증해둬야 한다.

스프링의 개발자인 로드 존슨은 테스트를 작성할 때 항상 네거티브 테스트부터 만드는 습관이 있다고 한다. 정상적인 조건의 테스트부터 만들면 테스트가 성공하는 것을 보고 쉽게 만족해서 예외적인 상황은 빼먹고 넘거가기가 쉽기 때문이다. 예외상황에 대한 테스트를 자꾸 빼먹는 개발자라면 의도적으로 예외적인 조건에 대해 먼저 테스트를 만드는 습관을 들이는 것도 좋다.

그렇다면 getAll()의 쿼리를 실행했는데 아무런 데이터가 없다면 어떻게 할 것인가? 정하기 나름이지만, 일단 query()라는 템플릿을 사용했으니 query()가 이런 경우 어떤 결과를 돌려주는지를 알아야 한다. query()는 결과가 없을 경우에 queryForObject()처럼 예외를 던지지는 않는다. 대신 크기가 0인 List<T> 오브젝트를 돌려준다. getAll()은 query()가 돌려주는 결과를 그대로 리턴하도록 만들자. 테스트에는 아래와 같이 검증 코드를 추가한다. getAll()에 대한 테스트 코드인 동시에 getAll()의 기능을 설명해주는 코드이기도 하다.

~~~java
// 데이터가 없는 경우에 대한 검증 코드가 추가도니 getAll() 테스트
public void getAll() {
  dao.deleteAll();

  List<User> user0 = dao.getAll();
  assertThat(users0.size(), is(0));
  ...
}
~~~
테스트는 성공할것이다.

이쯤에서 한 가지 질문을 해볼 수 있다. 이미 JdbcTemplate의 query() 메소드가 예외적인 경우에는 크기가 0인 리스트 오브젝트를 리턴하는 것으로 정해져 있다. 그런데 getAll()에서 query()의 결과에 손댈 것도 아니면서 굳이 ㄱ머증 코드를 추가해야 할까?

물론이다. 테스트 코드를 만드는 것도 좋다. UserDao를 사용하는 쪽의 입장에서 생각해본다면 geAll()이 내부적으로 jdbcTemplate을 사용하는지, 개발자가 직접 만든 JDBC 코드를 사용하는지 알 수 없고 알 필요도 없다. getAll()이라는 메소드가 어떻게 동작하는지에만 관심이 있는 것이다. UserDaoTest 클래스의 테스트는 UserDao의 getAll() 이라는 메소드에 기대하는 동작방식에 대한 검증이 먼저다. 따라서 그 예상되는 결과를 모두 검증하는 게 옳다. 이렇게 해두면 나중에  JdbcTemplate의 query() 대신 다른 방법으로 구현을 바꿔도 동일한 기능을 유지하는 UserDao인지 확인이 가능하다.

또 내부적으로 query()를 사용했다고 하더라도 getAll() 메소드가 다른 결과를 리턴하게 할 수도 있기 때문이다. query()의 결과를 무조건 getAll()에서 리턴해야 할 이유는 없다. query()에서 빈 리스트가 오면 null로 바꿔서 리턴할 수도 있다. 또는 예외를 던지게 할 수도 있다. 그런 면에서 query()의 결과와 상관없이 getAll() 메소드의 예외상황에 대한 테스트는 반드시 필요하다.

getAll() 메소드의 내부 구조를 속속들이 아는 개발자 입장에서도 JdbcTemplate의 query() 메소드에 대한 학습 테스트로서 의미가 있다. 정말 query()는 결과가 없을 때 빈 리스트를 리턴하는지 한 번쯤은 직접 확인해볼 필요도 있기 때문이다.

### 재사용 가능한 콜백의 분리
테스트는 이제 충분한 듯하니 이쯤에서 UserDao 코드를 한 번 살펴보자. userDao 전체가 처음 try/catch/finally를 덕지덕지 붙여가며 만들었을 때의 메소드 한 개 분량밖에는 안된다. 코드의 양이 줄었을 뿐 아니라 각 메소드의 기능을 파악하기도 쉽게 되어있다. 핵심적인 SQL 문장과 파라미터, 그리고 생성되는 결과의 타입정보만 남기고 모든 판에 박힌 로우레벨 중복 코드는 깔끔하게 제거됐기 때문이다. 그래도 아직 몇 가지 할 일이 남았다.

#### DI를 위한 코드 정리
이제 필요 없어진 DataSource 인스턴스 변수는 제거하자. UserDao의 모든 메소드가 JdbcTempalte을 이용하도록 만들었으니 DataSource를 직접 사용할 일은 없다. 단지 JdbcTemplate을 생성하면서 직접 DI 해주기 위해 필요한 DataSource를 전달받아야 하니 수정자 메소드는 남겨둔다. 정리하고 나면 아래와 같이 JdbcTmplate 인스턴스 변수와 DataSource 타입 수정자 메소드만 깜끔하게 남는다. 수정자 메소드에서 이렇게 다른 오브젝트를 생성하는 경우는 종종 있으니 익숙해지자.

~~~java
// 불필요한 DataSource 변수를 제거하고 남은 userDao의 DI코드
public void setDataSource(DataSource dataSource) {
  this.jdbcTemplate = new JdbcTemplate(dataSource);
}
~~~

JdbcTemplate을 직접 스프링 빈으로 등록하는 방식을 사용하고 싶다면 setDataSource를 setJdbcTemplate으로 바꿔주기만 하면 된다.

#### 중복 제거
달므은 중복된 코드가 없나 살펴보자. 웬만한 JDBC의 템플릿성 코드나 방복적인 콜백 코드도 모두 JdbcTemplate의 도움으로 제거했으니 메소드 단위에서 보자면 줄일 만한 것은 없다. 하지만 get()과 getAll()을 보면 사용한 RowMapper의 내용이 똑같다는 사실을 알 수 있다. 사용되는 상황은 다르지만 ResultSet 로우 하나를 User 오브젝트 하나로 변환해주는 동일한 기능을 가진 콜백이다.

겨우 두 번 나왔는데 이것도 중복이라고 생각하고 분리할 필요가 있을까? 만약 두 개가 전부이고 UserDao의 기능이 더 추가되지 않을 것이라면 그냥 넘어가도 문제 될 것은 없다. 하지만 UserDao에 앞으로 추가될 기능을 예상해보면 RowMapperdml 사용이 여기서 끝날 것 같지는 않다. 다양한 조건으로 사용자를 조회하는 검색 기능이 추가될 것이다. 이름으로 검색할 수도 있고, 로그인을 위해 아이디와 비밀번호로 검색할 수도 이싸. 이런 메소드에서 매번 동일한 RowMapper를 사용하게 될 것이다. 또한 User의 필드가 추가되거나 수정되는 경우도 충분히 예상할 수 있다. User 테이블의 필드를 추가하고 수정하면, 맴핑 작업을 해주는 RowMapper 콜백의 코드도 함께 수정해야 한다. 두 개 이상의 RowMapper가 있는데 모두 정확하게 수정해주지 않으면 문제가 발생하다.

따라서 User용 RowMapper 콜백을 메소드에서 분리해 중복을 없애고 재사용되게 만들어야 한다. 먼저 매번 RowMapper 오브젝트를 새로 만들어야 할지 생각해보자. RowMapper 콜백 오즈게트에는 상태정보가 없다. 따라서 하나의 콜백 오브젝트를 멀티스레드에서 동시에 사용해도 문제가 되지 않는다. RowMapper 콜백은 하나만 만들어서 공유하자.

아래와 같이 userMapper라는 이름으로 인스턴스 변수를 만들고 사용할 매핑용 콜백 오브젝트를 초기화하도록 만든다. 익명 내부 클래스는 클래스 안에서라면 어디서든 만들 수 있다.
~~~java
// 재사용 가능하도록 독립시킨 RowMapper

public class UserDao {
  private RowMapper<User> userMapper =
    new RowMapper<User>() {
      public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        return user;
      }
    }
};
~~~

인스턴스 변수에 저장해둔 userMapper 콜백 오브젝트는 아래와 같이 get()과 getAll()에서 사용하면 된다.

~~~java
// userMapper를 사용하도록 수정한 get(), getAll()

public User get(String id) {
  return this.jdbcTemplate.queryForObject("select * from users where id = ?",
    new Object[] {id}, this.userMapper);
}

public List<User> getAll() {
  return this.jdbcTemplate.query("select * from users order by id",
    this.userMapper);
}
~~~

UserDaoTest 테스트를 실행해서 기능을 점검해보자. 문제는 없다.

#### 템플릿/콜백 패턴과 UserDao
아래는 최종적으로 완성된 UserDao 클래스다. 템플릿/콜백 패턴과 DI를 이용해 예외처리와 리솟 관리, 유연한 DataSource 활용 방법까지 제공하면서도 군더더기 하나 없는 깔끔하고 간결한 코드로 정리할 수 있게 됐다.
~~~java
// JdbcTemplate을 적용하나 UserDao 클래스
public class UserDao {
  public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
  }

  private JdbcTemplate jdbcTemplate;

  private RowMapper<User> userMapper =
    new RowMapper<User>() {
      public User mapRow(ResultSet rs, int rowNum) throws SQLException {
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        return user;
      }
    };

  private void add(final User user) {
    this.jdbcTemplate.update("insert into users(id, name, password) vaalue(?, ?, ?)",
      user.getId(), user.getName(), user.getPassword());
  }

  public User get(String id) {
    return this.jdbcTemplate.queryForObject("select * from users where id = ?",
      new Object[] {id}, this.userMapper);
  }

  public void deleteAll() {
    this.jdbcTemplate.update("delete from users");
  }

  public int getCount() {
    return this.jdbcTemplate.queryForInt("select count(*) from users");
  }

  public List<User> getAll() {
    return this.jdbcTemplate.query("select * from users order by id", this.userMapper);
  }
}
~~~

UserDao에는 Uer 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 담겨 있다. User라는 자바오브젝트와 USER 테이블 사이에 어떻게 정보를 주고받을지, DB와 커뮤니케이션하기 위한 SQL 문장이 어떤 것인지에 대한 최적화된 코드를 갖고 있다. 만약 사용할 테이블과 필드정보가 바뀌면 UserDao의 거의 모든 코드가 함께 바뀐다. 따라서 응집도가 높다고 볼 수 있다.

반면에 JDBC API를 사용하는 방식, 예외처리, 리소스의 반납, DB 연결을 어떻게 가져올지에 관한 책임과 관심은 모두 JdbcTemplate에게 있따. 따라서 벼경이 일어난다고 해도 UserDao 코드에는 아무런 영향을 주지 않는다. 그런 면에서 책임이 다른 코드와는 낮은 결합도를 유지하고 있다. 다만 JdbcTemplate이라는 템플릿 클래스를 직접 이용한다는 면에서 특정 템플릿/콜백 구현에 대한 강한 결합을 갖고 있다. JdbcTemplate이 스프링에서 JDBC를 이용해 DAO를 만드는 데 사용되는 사실상 표준 기술이고, JDBC 대신 다른 데이터 엑세스 기술을 사용하지 않는 한 바뀔 리도 없겠지만, 그래도 더 낮은 결합도를 유지하고 싶다면 JdbcTemplate을 독립적인 빈으로 등록하고 JdbcTemplate이 구현하고 있는 JdbcOperations 인터페이스를 통해 DI 받아 사용하도록 만들어도 된다.

JdbcTempalte은 DAO 안에서 직접 만들어 사용하는 게 스프링의 관례이긴 하지만 원한다면 얼마든지 독립된 싱글톤 빈으로 등록하고 DI 받아 인터페이스를 통해 사용할 수 있다.

그런데 UserDao를 여기서 더 개선할 수도 있을까? 일단은 이 정도에서 만족하는 것이 타당할 듯싶지만, 장기적으로 많으 DAO가 만들어지고 UserDao도 더 많은 기능이 추가될 것이라고 생각해보면 두 가지 정도 더 욕심을 내고 싶은 부분이 눈에 띈다.

첫째는 userMapper가 인스턴스 변수로 설정되어 있고, 한 번 만들어지면 변경되지 않는 프로퍼티와 같은 성격을 띠고 있으니 아예  UserDao 빈의 DI용 프로퍼티로 만들어버리면 어떨까? UserMapper를 독립된 빈으로 만들고 XML 설정에 User 테이블의 필드 이름과 User 오브젝트 프로퍼티의 매핑정보를 담을 수도 있을 것이다. 이렇게 UserMapper를 분리할 수 있다면 User의 프로퍼티와 User 테이블의 필드 이름이 바뀌거나 매핑 방식이 바뀌는 경우에 UserDao 코드를 수정하지 않고도 매핑정보를 변경할 수 있다는 장점이 있다.

둘째는 DAO 메소드에서 사용하는 SQL 문장을 userDao 코드가 아니라 외부 리소스에 담고 이를 읽어와 사용하게 하는 것이다. 이렇게 해두면 DB 테이블의 이름이나 필드의 이름을 변경하거나 SQL 쿼리를 최적화해야 할 때도 UserDao 코드에는 손을 댈 필요가 없다. 어떤 개발팀은 정책적으로 모든 SQL 쿼리를 DBA들이 만들어서 제공하고 관리하는 경우가 있다. 이럴 때 SQL이 독립된 파일에 담겨 있다면 편리할 것이다.

이 두 가지 기능 개선도 당장 해보고 싶긴 하지만 일단 다른 스프링의 기술을 먼저 살펴보고 손을 대보기로 하자.

스프링이 지구언하는 DJBC 개발을 위한 기술은 11장에서 좀 더 자세히 설명할 것이다. 스프링에는 JdbcTEmplate외에도 십여 가지의 템플릿/콜백 패턴을 적용한 API가 존재한다. 클래스 이름이 Template으로 끝나거나 인터페이스 이름이 Callback 으로 끝난다면 템플릿/콜백이 적용된 것이라고 보면 된다.

## 정리
3장에서는 예외처리와 안전한 리소스 반환을 보장해주는 DAO 코드를 만들고 이를 객체지향 설계 원리와 디자인 패턴, DI 등을 적용해서 깔끔하고 유연하며 단순한 코드로 만드는 방법을 살펴봤다.

- JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관래햐아한다.
- 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 통해 유연하게 전략을 변경할 수 있도록 구성한다.
- 같은 애플리케이션 안에서 여러 가지 종류의 전략을 다이내믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
- 클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구형하면 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.
- 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 만든다.
- 컨텍스트는 별도의 빈으로 등록해서 DI 받거나 클라이언트 클래스에서 직접 생성해서 사용한다. 클래스 내부에서 컨텍스트를 사용할 떄 컨텍스트가 의존하는 외부의 오브젝트가 있다면 코드를 이용해서 직접 DI 해줄 수 있따.
- 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고, 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다.
- 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활용하는 것이 편리하다.
- 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.
- 스프링은 JDBC 코드 작성을 위해 JdbcTemplate을 기반으로 하는 다양한 템플릿과 콜백을 제공한다.
- 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고, 하나의 콜백을 여러 번 호출할 수도 있다.
- 템플릿/콜백을 설계할 때는 템플리소가 콜백 사이에 주고받는 정보에 관심을 둬야 한다.

템를릿/콜백은 스프링이 객체지향 설계와 프로그래밍에 얼마나 가치를 두고 있는지를 잘 보여주는 예다. 스프링이 제공하는 템플릿/콜백을 잘 사용해야 하는 것은 물론이며 직접 템플릿/콜백을 만들어 활용할 수도 있어야 한다.
