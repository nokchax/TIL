# 테스트
애플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면, 두 번째 전략은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자심감을 주는 테스트 기술이다.

스프링으로 개발을 하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 셈이다. 스프링 개발자라면 테스트 작성 방법과 이를 효과적으로 개발에 활용하는 전략을 알아야 하며, 이를 실전에 적용할 수 있어야 한다.

또한 테스트는 스프링을 학슴하는 데 있어 가장 효과적인 방법의 하나다. 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

이번장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴본다.

## UserDaoTest 다시보기
### 테스트의 유용성
1장에서 만든 UserDao가 기대했던 대로 동작하는지 확인하기 위해 간단한 테스트 코드를 만들었다. main() 메소드를 이용해 UserDao 오브젝트의 add(), get() 메소드를 호출하고, 그 결과를 화면에 출력해서 그 값을 눈으로 확인시켜준다.
이렇게 만든 테스트용 main() 메소드를 반복적으로 실행해가면서 처음 설계한 대로 기능이 동작하는지를 매 단계 확인한 덕분에, 다양한 방법으로 초난감 UserDao 코드의 설계와 코드를 개선했고, 심지어 스프링을 적용해서 동작하게 만들 수도 있었다. 코드의 구조와 설계, 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 초난감 UserDao와 다를 바 없이 DB에 사용자 정보를 등록하고, 가져오는 기능을 잘 수행한다는 걸 테스트를 통해 확인할 수 없었다면, 그 코드를 개선하는 과정 내내 뭔가 꺼림칙하고 불안했을 것이다. UserDao의 클래스를 책임에 따라 이리저리 분리하고, 인터페이스를 도입하고, 오브젝트 팩토리를 통해 생성하도록 만들고, 또 스프링의 DI 방식을 XML 설정파일까지 써서 적용했을 때 그것이 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법에는 어떤 것이 있겠는가? 테스트를 통해 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다. 코드를 들여다보며 머릿속으로 시뮬레이션하는 방법이 있긴 하지만 그것만으로는 100% 확신할 수 없다.
테스트란 결국 내가 예상하고 의도했던 대로 코드가 정홯히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다. 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 코드의 결함을 제거해가는 작업, 일명 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

### UserDaoTest의 특징
~~~Java
public class UserDaoTest {
  public static void main(String[] args) throws SQLException {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);

    User user = new User();
    user.setId("user");
    user.setName("김광현");
    user.setPassword("kh");

    dao.add(user);

    System.out.println(user.getId() + " 등록 성공");

    User user2 = dao.get(user.getId());
    System.out.println(user2.getName());
    System.out.println(user2.getPassword());

    System.out.println(user2.getId() + " 조회 성공");
  }
}
~~~

위의 테스트 코드의 내용을 정리해보면 다음과 같다.
- 손쉽게 실행 가능한 main() 메소드를 이용한다.
- 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.
- 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
- 테스트의 결과를 콘솔에 출력해준다.
- 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메세지를 출력해준다.

이 테스트 방법에서 가장 돋보이는 건, main() 메소드를 이용해 쉽게 테스트 수행을 가능하게 했다는 점과 테스트할 대상인 UserDao를 직접 호출해서 사용한다는 점이다.

#### 웹을 통한 DAO 테스트 방법의 문제점
보통 웹 프로그램에서 사용하는 DAO를 테스트하는 방법은 다음과 같다. DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트용 웹 애플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 폼을 열고, 값을 입력한 뒤 버튼을 눌러 등록해본다.

이를 위해서는 폼의 값을 받아서 파싱한 뒤에 User 오브젝트로 만들고 UserDao를 호출해주는 기능이 이미 만들어져 있어야 한다. 이 기능이 문제가 없다면 다음엔 검색 폼이나 파라미터를 지정할 수 있는 URL을 사용해서 방금 입력한 데이터를 다시 가져올 수 있는지 테스트해본다. 역시 UserDao가 돌려주는 결과를 화면에 춣력해주는 기능이 만들어져 있어야 확인이 가능하다.

이렇게 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다. DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다. 테스트 도중에 에러가 났다면 어디서 어떤 문제가 발생했는지를 찾아내기 위한 수고가 필요하다. 하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문이다.

DB 연결 방법에 문제가 있었을 수도 있고, DAO 코드가 잘못되어 JDBC API를 잘못 호출해서일 수도 있다. 혹은 SQL 문법이 틀렸거나, 파라미터로 넘어온 값을 잘못 바인딩했을 수도 있다. 정작 테스트할 대상인 DAO의 문제가 아니라 서버환경에서 웹 화면을 통해 DAO를 테스트하려고 만든 다른 코드 때문에 에러가 나거나 테스트가 실패할 수도 있다. 혹은 모든 것이 다 성공했지만 최종적으로 결과 메시지를 출력하는 JSP 뷰에 문제가 있어서 오류가 난 것처럼 보일 수도 있다.

사실 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다는 문제가 있다.

그렇다면 테스트를 어떻게 만들면 이런 문제를 피할 수 있고, 효율적으로 테스트를 활용할 수 있을지 생각해보자.

#### 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직 하다. 한번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 원인을 찾기도 힘들어진다. 따라서 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.

작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit test)라고 하는데, 여기서 단위란 그 크기와 범위가 딱 정해진 것은 아니다. 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다. 일반적으로 단위는 작을수록 좋다. 단위를 넘어서는 다른 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.

통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다.

단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다. 이때 확인의 대상과 조건이 간단하고 명확할수록 좋다. 그래서 작은 단위로 제한해서 테스트하는 것이 편리하다.

#### 자동수행 테스트 코드
UserDaoTest의 한 가지 특징은 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 점이다. 또한 UserDaoTest는 자바 클래스의 main() 메소드를 실행하는 가장 간단한 방법만으로 테스트의 전 과정이 자동으로 진행된다.

번거롭게 매번 입력할 필요도 없고, 테스트를 시작하기 위해 서버를 띄우고 브라우저를 열어야 하는 불편함도 없다. 때문에 테스트를 자주 수행해도 부담이 없다. 이러한 이점 때문에 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다. 개발이 완료될 즈음에, 또는 개발을 일단 완료하고 실전에서 운영 중인 상황에서 코드를 수정하려고 한다면 아무리 간단한 수정이라고 하더라도 이게 전체 애플리케이션에 심각한 문제를 일으키지는 않을까 하는 두려움이 생긴다. 그럴때 만들어둔 기능에 대한 테스트가 있다면 수정 후 빠르게 전체 테스트를 수행해서 수정 때문에 다른 기능에 문제가 발생하지는 않는지 재빨리 확인하고, 성공한다면 마음에 확신을 얻을 수 있다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트
처음 만든 초난감 DAO 코드를, 스프링을 이용한 깔끔하고 완성도 높은 객체지향적 코드로 발전시키는 과정의 일등 공신은 바로 테스트였다. 테스트가 없었다면, 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 그다지 미덥지 않을 수도 있다. 수정 중간중간 테스트 코드를 실행해 검증을 했기 때문에 자신을 가지고 조금씩 코드를 개선해나가는 작업을 진행할 수 있었다.

만약 처음부터 스프링을 적용하고 XML로 설정을 만들고 모든 코드를 다 만들고 난 뒤에 이를 검증하려고 했다면, 쏟아지는 에러 메세지에 막막해졌을지도 모른다. 하지만 일단은 단순 무식한 방법으로 정상동작하는 코드를 만들고, 테스트를 만들어 뒀기 때문에 매우 작은 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다.

UserDao의 기능을 추가하려고 할 때도 미리 만들어둔 테스트 코드는 유용하게 쓰일 수 있다. 조금씩 기능을 더 추가해가면서 그에 대한 테스트도 함께 추가하는 식으로 점진적인 개발이 가느해진다. 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수 도 있다.

### UserDaoTest의 문제점
UserDaoTest가 UI까지 동원되는 번거로운 수동 테스트에 비해 장점이 많지만, 만족스럽지 못한 부분도 있다.

##### 수동 확인 작업의 번거로움
테스트를 수행하는 과정과 입력 데이터의 준비를 자동으로 진행하도록 만들었지만, 여전히 사람의 눈으로 확인하는 과정이 필요하다. 입력한 값과 가져온 값이 일치하는지를 테스트 코드는 확인해주지 않는다. 따라서 실수할 가능성이 있다.

##### 실행 작업의 번거로움
아무리 간단히 실행 가능한 main() 메소드라고 하더라도 매번 그것을 싱행하는 것은 제법 번거로운 일이다. DAO가 계속 추가되면서 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면, 테스트를 위해 수백번 실행해야 할 수 도 있다.

따라서 좀더 편리하고 체계적인 테스트 방법이 필요하다.

## UserDaoTest 개선
### 테스트 검증의 자동화
첫 번째 문제점인 테스트 결과의 검증 부분을 코드로 만들어보자. 모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다. 또 테스트의 실패는 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우와, 결과가 기대한 것과 다르게 나오는 경우로 구분해 볼 수 있다. 전자는 테스트 에러, 후자는 테스트 실패라고 하자.

테스트 중에 에러가 발생하는 것은 콘솔에 에러 메시지와 호출 스택 정보가 출력되기 때문에 쉽게 확인이 가능하다. 하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 있다. 따라서 기존의 테스트 코드에서는 get()에서 가져온 ㅌ결과를 사람이 눈으로 확인하도록 단순히 콘솔에 출력하기만 했는데, 이번에는 테스트 코드에서 결과를 직접 확인하고, 기대한 결과와 달라서 실패했을 경우에는 "실패" 라는 메시지를 출력하도록 만들어보자.

~~~Java
// 수정 전 테스트 코드
System.out.println(user2.getName());
System.out.println(user2.getPassword());
System.out.println(user2.getId() + " 조회 성공");
~~~

~~~java
// 수정 후 테스트 코드
if(!user.getName().equals(user2.getName())) {
  System.out.println("테스트 실패 (name)");
} else if(!user.getPassword().equals(user2.getPassword())) {
  System.out.println("테스트 실패 (password)");
} else {
  System.out.println("조회 테스트 성공");
}
~~~

처음 add()에 전달한 User 오브젝트와 get()을 통해 가져오는 User 오브젝트의 값을 비교해서 일치하는지 확인하도록 만들었다. 이렇게 해서 테스트의 수행과 테스트 값 적용, 그리고 결과를 검증하는 것까지 모두 자동화 했다.

거의 모든 과정을 자동화한 테스트가 만들어졌고, 이제는 테스트를 수행하고 출력 메시지가 "테스트 성공" 이라고 나오는지 확인하는 작업만 해주면 된다. 그렇기 때문에 실패 메시지가 나오면 그 원인을 찾아서 코드를 수정하고 다시 테스트를 실행하면 되고, 성공한다면 빠르게 다음 작업으로 넘어갈 수 있다.

xUnit 프레임워크를 만든 켄트 백은 "테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"이라고 했다. 개발 과정에서, 또는 유지보수를 하면서 기존 애플리케이션 코드에 수정을 할 때 마음의 평안을 얻고, 자신이 만지는 코드에 대해 항상 자신감을 가질 수 있으며, 새로 도입한 기술의 적용에 문제가 없는지 확인할 수 있는 가장 좋은 방법은 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두는 것이다.

### 테스트의 효율적인 수행과 결과 관리
앞서서 편하게 테스트를 확인하려고 수정을 했지만, 좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면 단순한 main() 메소드로는 한계가 있다. main() 메소드를 이용한 테스트 작성 방법만으로는 테스트 개수가 많아지면 테스트를 수행하는 일이 점점 부담이 될 것이다.

#### JUnit 테스트로 전환
JUnit 프레임워크를 도입해보자. 프레임 워크에서 동작하는 코든느 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

#### 테스트 메소드 전환
기존에 만들었던 main() 메소드 테스트는 그런 면에서 프레임워크에 적용하기엔 적합하지 않다. 테스트가 main() 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이기 때문이다. 새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다. 첫째는 메소드가 public으로 선언돼야 하는 것이고, 둘째는 메소드에 @Test라는 애노테이션을 붙여주는 것이다.

~~~Java
// JUnit 프레임워크에서 동작할 수 있는 테스트 메소드로 전환
public class UserDatoTest {
  @Test
  public void addAndget() throws SQLException {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);
    ...
  }
}
~~~

main() 대신에 일반 메소드로 만들고 적절한 이름을 붙여준다. 이왕이면 테스트의 의도가 무엇인지 알 수 있는 이름이 좋다. JUnit은 전통적으로 public 메소드만을 테스트 메소드로 허용하고 있다. 마지막으로 @Test 애노테이션을 붙여주면 된다.

#### 검증 코드 전환
테스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 방법을 이용해 전환해보자. 아래의 if문은 assertThat이라는 JUnit이 제공하는 스태틱 메소드를 이용해 변경할 수 있다.
~~~Java
if(!user.getName().eqauls(user2.getName())) {...}

assertThat(user2.getName(), is(user.getName()));
~~~

assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다.

JUnit은 예외가 발생하거나 assertThat() 에서 실패하지 않고 테스트 메소드의 실행이 완료되면 테스트가 성공했다고 인식한다. "테스트 성공" 이라는 메시지를 굳이 출력할 필요가 없다. JUnit이 테스트 실행 결과를 다양한 방법으로 알려주기 때문이다.

~~~Java
// JUnit을 적용한 UserDaoTest

public class UserDaoTest {
  @Test
  public void addAndGet() throws SQLException {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);
    User user = new User();
    user.setId("retrokarr");
    user.setName("김광현");
    user.setPassword("retro");

    dao.add(user);

    User user2 = dao.get(user.getId());

    assertThat(user2.getName(), is(user.getName()));
    assertThat(user2.getPassword(), is(user.getPassword()));
  }
}
~~~

#### JUnit 테스트 실행
스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다.

어디에는 main() 메소드를 하나 추가하고, 그 안에 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 파라미터에는 @Test 테스트 메소드를 가진 클래스의 이름을 넣어준다.

~~~Java
public static void main(String[] args) {
  JUnitCore.main("springbook.user.dao.UserDaoTest");
}
~~~

~~~
JUnit version 4.7
Time: 0.578
OK (1 test)
~~~
실행하면 위와 같은 메시지를 볼 수 있다. 만약 코드에 이상이 있어서 assertThat() 의 검증에서 실패하면 다음과 같은 메시지가 나올 것이다.

~~~
Time: 1.094
There war 1 filure:
1) addAndGet(Springbook.dao.UserDaoTest)
java.lang.AssertionError:
Expected: is "김광현"
     got: null
     ...
     at springbook.dao.UserDaoTest.main(UserDaoTest.java:36)
FAILUSER!!!
Tests run: 1, Failures: 1
~~~
테스트가 실패하면 OK 대신 FAILUSER!!라는 내용이 출력되고, 총 수행한 테스트 중에서 몇 개의 테스트가 실패했는지 보여준다.

## 개발자를 위한 테스팅 프레임워크 JUnit
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다.

### JUnit 테스트 실행 방법
JUnitCore를 이용해 테스트를 실행하고 콘솔에 출력된 메시지를 보고 결과를 확인하는 방법은 가장 간단하긴 하지만 테스트의 수가 많아지면 관리하기가 힘들어진다는 단점이 있다. 가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.

#### IDE
IDE에서는 보통 JUnit 테스트를 지원하는 기능을 제공하고 있다. 테스트의 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수를 확인할 수 있다.

#### 빌드 툴
프로젝트의 빌드를 위해 ANT나 메이븐(Maven) 혹은 그레들과 같은 빌드 툴과 스크립트를 사용한다면, 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다. 테스트 실행 결과는 옵션에 따라 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어진다.

개발자 개인별로는 IDE에서 JUnit 도구를 활용해 테스트를 실행하는게 가장 편리하지만, 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 경우에는 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하는 것도 좋다.

### 테스트 결과의 일관성
JUnit을 적용해서 깔끔한 테스트 코드를 만들었고, 편리하게 실행할 수 있는 툴의 사용도 해보았지만, 좀 더 개선이 필요한 부분이 있다. 지금까지 테스트를 실행하면서 가장 불편했던 일은, 매번 UserDaoTest 테스트를 실행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 하는 점이다. 개발자가 깜빡 잊는다면 테스트 실행 중에 에러가 발생할 것이다.

여기서 생각해볼 문제는 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다는 점이다. 반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점이며, 가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다.

#### deleteAll()의 getCount() 추가
일관성 있는 결과를 보장하는 테스트를 만들기 위해 준비할 게 있는데, 바로 UserDao에 새로운 기능을 추가해주는 일이다.

##### deleteAll
deleteAll() 메소드는 USER 테이블의 모든 레코드를 삭제해주는 간단한 기능을 가지고 있다.

~~~Java
public void deleteAll() throws SQLException {
  Connection c = dataSource.getConnection();

  PreparedStatement ps = c.prepareStatement("delete from users");
  ps.executeUpdate();

  ps.close();
  c.close();
}
~~~

##### getCount()
getCount() 메소드는 USER 테이블의 레코드 개수를 돌려준다.
~~~Java
public int getCount() throws SQLException {
  PreparedStatement ps = c.preparedStatement("select count(*) from users");

  ResultSet rs = ps.executeQuery();
  re.next();
  int count = rs.getInt(1);

  rs.close();
  ps.close();
  c.close();

  return count;
}
~~~

#### deleteAll()과 getCount()의 테스트
새로운 기능을 추가했으니, 추가된 기능에 대한 테스트도 만들어야 한다. 그런데 deleteAll()과 getCount() 메소드의 기능은 add()와 get()처럼 독립적으로 자동 실행되는 테스트를 만들기가 좀 애매하다. 새로 유저를 등록하고 deleteAll()을 실행해야 하기 때문에, 새로운 테스트를 만들기보다는 차라리 기존에 만든 addAndGet() 테스트를 확장하는 방법을 사용하는 편이 더 나을 것 같다. addAndGet() 테스트의 불편함 점은 실행 전에 수동으로 USER 테이블의 내용을 모두 삭제해야한는 점이다. 그래서 deleteAll()을 이용하면 이 불편한 점을 해소할 수 있을것이다.

그런데 deleteAll() 자체도 아직 검증이 안됐는데 무턱대고 다른 테스트에 적용할 수는 없다. 그래서 getCount()를 함께 적용해보자. deleteAll()이 기대한 대로 동작한다면, getCount()로 레코드의 개수를 가져올 경우 0이 나와야 한다. 그러므로 deleteAll()을 실행한 직후에 getCount()의 결과값을 검증하고 코드를 넣어보자.

그런데 여기서 또 getCount()가 잘 동작하는지 어떻게 믿을 수 있을까? getCount() 메소드가 테이블의 레코드 숫자에 상관없이 항상 0을 돌려주는 버그를 갖고 있다면, deleteAll() 기능을 검증하는 데 사용할 수 없다. 검증 안 된 두 개를 붙였는데 우연히 테스트가 통과한다고 안심하는 것은 바람직 하지 못하다.

그래서 getCount()에 대한 검증 작업도 추가해보자. 시나리오는 이렇다. 이미 앞에서 add() 메소드가 정상적으로 DB 테이블에 데이터를 넣는 것을 확인헀으니 add()를 수행하고 나면 레코드의 개수가 0에서 1로 바뀌어야 한다. 그렇다면 add() 메소드를 실행한 뒤에 getCount()의 결과를 한 번 더 확인해보자. deleteAll() 직후에는 0이 나오고 add() 직후에는 1이 나온다면, getCount()의 기능이 바르게 동작한다고 불 수 있다. 그리고 getCount()가 바르게 동작한다는 확신이 있다면, deleteAll() 직후에 항상 0이 나오는 것을 보고 deleteAll()의 기능도 바르게 동작한다고 생각할 수 있다.

~~~Java
//deleteAll()과 getCount()가 추가된 addAndGet() 테스트
public void addAndGet() throws SQLException {
  ...

  dao.deleteAll();
  assertThat(dao.getCount(), is(0));

  User user = new User();
  user.setId("syntaxtree");
  user.setName("김광현");
  user.setPassword("tree");

  dao.add(user);
  assertThat(dao.getCount(), is(1));

  User user2 = dao.get(user.getId());

  assertThat(user2.getName(), is(user.getName()));
  assertThat(user2.getPassword(), is(user.getPassword()));
};
~~~
이렇게 deleteAll()과 getCount()를 기존 addAndGet() 테스트에 추가헀다.

#### 동일한 결과를 보장하는 테스트
테스트를 하기 전에 매번 직접 DB에서 데이터를 삭제해야 했지만, 이제는 그런 번거로운 과정이 필요 없어졌다. 테스트가 어떤 상황에서 반복적으로 실행된다고 하더라도 동일한 결과가 나올 수 있게 된 것이다. 이렇게 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다. DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야한다.

### 포괄적인 테스트
getCount() 메소드를 테스트에 적용하긴 했지만, 이전 테스트가 아니라, 두 개 이상의 레코드를 add() 했을 때도 정상 동작하는 지는 모르는 일이다, 0과 1 두 가지를 해봤으니 나머지도 당연히 잘될 것이라고 생각할 수도 있겠지만 미처 생각하지 못한 문제가 숨어 있을지도 모르니 더 꼼꼼한 테스트를 해보는 것이 좋은 자세다. 테스트를 안 만드는 것도 위험한 일이지만, 성의 없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다. 특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.

#### getCount()테스트
그러니 getCount()에 대한 좀 더 꼼꼼한 테스트를 만들어보자. JUnit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용한다. @Test가 붙어있고 public 접근자가 있으며 리턴 값이 void형이고 파라미터가 없다는 조건을 지키기만 하면 된다.

테스트 시나리오는 이렇다. 먼저 USER 테이블의 데이터를 모두 지우고 getCount()로 레코드 개수가 0임을 확인한다. 그리고 3개의 사용자 정보를 하나씩 추가하면서 매번 getCount()의 결과가 하나씩 증가하는지 확인하는 것이다.

테스트를 만들기 전에 먼저 User 클래스에 한 번에 모든 정보를 넣을 수 있도록 생성자를 추가하자.

~~~Java
public User(String id, String name, String password) {
  this.id = id;
  this.name = name;
  this.password = password;
}
public User() {
}
~~~
~~~Java
@Test
public void count() throws SQLException {
  ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

  UserDao dao = context.getBean("userDao", UserDao.class);
  User user1 = new User("syntax", "김문법", "syntax1");
  User user2 = new User("tree", "김나무", "tree1");
  User user3 = new User("retro", "김복고", "retro1");

  dao.deleteAll();
  assertThat(dao.getCount(), is(0));

  dao.add(user1);
  assertThat(dao.getCount(), is(1));

  dao.add(user2);
  assertThat(dao.getCount(), is(2));

  dao.add(user3);
  assertThat(dao.getCount(), is(3));
}
~~~

주의해야 할 점은 두 개의 테스트가 어떤 순서로 실행될지는 알 수 없다는 것이다. JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.

#### addAndGet() 테스트 보완
이번엔 addAndGet() 테스트를 좀 더 보완해보자. count()에서도 add()에 대한 테스트로 기능에 대한 검증은 춘분히 된 것 같다. 하지만 아직 get()에 대한 충분한 검을 하지 않았으므로 get()메소드에 대한 테스트 기능을 좀 더 보완할 필요가 있다. User를 하나 더 추가해서 두 개의 User를 add()하고, 각 User의 id를 파라미터로 전달해서 get()을 실행하도록 만들어보자.

~~~Java
@Test
public void anddAndGet() throws SQLException {
  ...
  UserDao dao = context.getBean("userDao", UserDao.class);
  User user1 = new User("syntax", "김문법", "syntax1");
  User user2 = new User("tree", "김나무", "tree1");

  dao.deleteAll();
  assertThat(dao.getCount(), is(0));

  dao.add(user1);
  dao.add(user2);
  assertThat(dao.getCount(), is(2));

  User userget1 = dao.get(user1.getId());
  assertThat(userget1.getname(), is(user1.getName()));
  assertThat(userget1.getPassword(), is(user1.getPassword()));

  User userget2 = dao.get(user2.getId());
  assertThat(userget2.getName(), is(user2.getName()));
  assertThat(userget2.getPassword(), is(user2.getPassword()));
}
~~~
이렇게 해서 get() 메소드가 기대한 대로 동작하는지를 좀 더 확신할 수 있게 됐다.

#### get() 예외조건에 대한 테스트
한 가지 더 생각해볼 문제가 있다. get() 메소드에 전달된 id값에 해당하는 사용자 정보가 없다면 어떻게 될까? 이런 경우는 아직 생각해본 적이 없다. 두 가지 방법이 있을 것이다. 하나는 null과 같은 특별한 값을 리턴하는 것이고, 다른 하나는 id에 해당하는 정보를 찾을 수 없다고 예외를 던지는 것인데, 두번째 방법을 사용해보자.

주어진 id에 해당하는 정보가 없다는 의미를 가진 예외 클래스가 하나 필요하다. 스프링이 정의한 데이터 액세스 예외 클래스를 사용해보자. EmptyResultDataAccessException 예외 클래스다.
