# 테스트
애플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면, 두 번째 전략은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자심감을 주는 테스트 기술이다.

스프링으로 개발을 하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 셈이다. 스프링 개발자라면 테스트 작성 방법과 이를 효과적으로 개발에 활용하는 전략을 알아야 하며, 이를 실전에 적용할 수 있어야 한다.

또한 테스트는 스프링을 학슴하는 데 있어 가장 효과적인 방법의 하나다. 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

이번장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴본다.

## UserDaoTest 다시보기
### 테스트의 유용성
1장에서 만든 UserDao가 기대했던 대로 동작하는지 확인하기 위해 간단한 테스트 코드를 만들었다. main() 메소드를 이용해 UserDao 오브젝트의 add(), get() 메소드를 호출하고, 그 결과를 화면에 출력해서 그 값을 눈으로 확인시켜준다.
이렇게 만든 테스트용 main() 메소드를 반복적으로 실행해가면서 처음 설계한 대로 기능이 동작하는지를 매 단계 확인한 덕분에, 다양한 방법으로 초난감 UserDao 코드의 설계와 코드를 개선했고, 심지어 스프링을 적용해서 동작하게 만들 수도 있었다. 코드의 구조와 설계, 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 초난감 UserDao와 다를 바 없이 DB에 사용자 정보를 등록하고, 가져오는 기능을 잘 수행한다는 걸 테스트를 통해 확인할 수 없었다면, 그 코드를 개선하는 과정 내내 뭔가 꺼림칙하고 불안했을 것이다. UserDao의 클래스를 책임에 따라 이리저리 분리하고, 인터페이스를 도입하고, 오브젝트 팩토리를 통해 생성하도록 만들고, 또 스프링의 DI 방식을 XML 설정파일까지 써서 적용했을 때 그것이 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법에는 어떤 것이 있겠는가? 테스트를 통해 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다. 코드를 들여다보며 머릿속으로 시뮬레이션하는 방법이 있긴 하지만 그것만으로는 100% 확신할 수 없다.
테스트란 결국 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다. 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 코드의 결함을 제거해가는 작업, 일명 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

### UserDaoTest의 특징
~~~Java
public class UserDaoTest {
  public static void main(String[] args) throws SQLException {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);

    User user = new User();
    user.setId("user");
    user.setName("김광현");
    user.setPassword("kh");

    dao.add(user);

    System.out.println(user.getId() + " 등록 성공");

    User user2 = dao.get(user.getId());
    System.out.println(user2.getName());
    System.out.println(user2.getPassword());

    System.out.println(user2.getId() + " 조회 성공");
  }
}
~~~

위의 테스트 코드의 내용을 정리해보면 다음과 같다.
- 손쉽게 실행 가능한 main() 메소드를 이용한다.
- 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.
- 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
- 테스트의 결과를 콘솔에 출력해준다.
- 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메세지를 출력해준다.

이 테스트 방법에서 가장 돋보이는 건, main() 메소드를 이용해 쉽게 테스트 수행을 가능하게 했다는 점과 테스트할 대상인 UserDao를 직접 호출해서 사용한다는 점이다.

#### 웹을 통한 DAO 테스트 방법의 문제점
보통 웹 프로그램에서 사용하는 DAO를 테스트하는 방법은 다음과 같다. DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트용 웹 애플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 폼을 열고, 값을 입력한 뒤 버튼을 눌러 등록해본다.

이를 위해서는 폼의 값을 받아서 파싱한 뒤에 User 오브젝트로 만들고 UserDao를 호출해주는 기능이 이미 만들어져 있어야 한다. 이 기능이 문제가 없다면 다음엔 검색 폼이나 파라미터를 지정할 수 있는 URL을 사용해서 방금 입력한 데이터를 다시 가져올 수 있는지 테스트해본다. 역시 UserDao가 돌려주는 결과를 화면에 춣력해주는 기능이 만들어져 있어야 확인이 가능하다.

이렇게 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다. DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다. 테스트 도중에 에러가 났다면 어디서 어떤 문제가 발생했는지를 찾아내기 위한 수고가 필요하다. 하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문이다.

DB 연결 방법에 문제가 있었을 수도 있고, DAO 코드가 잘못되어 JDBC API를 잘못 호출해서일 수도 있다. 혹은 SQL 문법이 틀렸거나, 파라미터로 넘어온 값을 잘못 바인딩했을 수도 있다. 정작 테스트할 대상인 DAO의 문제가 아니라 서버환경에서 웹 화면을 통해 DAO를 테스트하려고 만든 다른 코드 때문에 에러가 나거나 테스트가 실패할 수도 있다. 혹은 모든 것이 다 성공했지만 최종적으로 결과 메시지를 출력하는 JSP 뷰에 문제가 있어서 오류가 난 것처럼 보일 수도 있다.

사실 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다는 문제가 있다.

그렇다면 테스트를 어떻게 만들면 이런 문제를 피할 수 있고, 효율적으로 테스트를 활용할 수 있을지 생각해보자.

#### 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직 하다. 한번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 원인을 찾기도 힘들어진다. 따라서 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.

작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit test)라고 하는데, 여기서 단위란 그 크기와 범위가 딱 정해진 것은 아니다. 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다. 일반적으로 단위는 작을수록 좋다. 단위를 넘어서는 다른 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.

통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다.

단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다. 이때 확인의 대상과 조건이 간단하고 명확할수록 좋다. 그래서 작은 단위로 제한해서 테스트하는 것이 편리하다.

#### 자동수행 테스트 코드
UserDaoTest의 한 가지 특징은 테스트할 데이터가 코드를 통해 제공되고, 테스트 작업 역시 코드를 통해 자동으로 실행한다는 점이다. 또한 UserDaoTest는 자바 클래스의 main() 메소드를 실행하는 가장 간단한 방법만으로 테스트의 전 과정이 자동으로 진행된다.

번거롭게 매번 입력할 필요도 없고, 테스트를 시작하기 위해 서버를 띄우고 브라우저를 열어야 하는 불편함도 없다. 때문에 테스트를 자주 수행해도 부담이 없다. 이러한 이점 때문에 테스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다.

자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 것이다. 개발이 완료될 즈음에, 또는 개발을 일단 완료하고 실전에서 운영 중인 상황에서 코드를 수정하려고 한다면 아무리 간단한 수정이라고 하더라도 이게 전체 애플리케이션에 심각한 문제를 일으키지는 않을까 하는 두려움이 생긴다. 그럴때 만들어둔 기능에 대한 테스트가 있다면 수정 후 빠르게 전체 테스트를 수행해서 수정 때문에 다른 기능에 문제가 발생하지는 않는지 재빨리 확인하고, 성공한다면 마음에 확신을 얻을 수 있다.

#### 지속적인 개선과 점진적인 개발을 위한 테스트
처음 만든 초난감 DAO 코드를, 스프링을 이용한 깔끔하고 완성도 높은 객체지향적 코드로 발전시키는 과정의 일등 공신은 바로 테스트였다. 테스트가 없었다면, 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 그다지 미덥지 않을 수도 있다. 수정 중간중간 테스트 코드를 실행해 검증을 했기 때문에 자신을 가지고 조금씩 코드를 개선해나가는 작업을 진행할 수 있었다.

만약 처음부터 스프링을 적용하고 XML로 설정을 만들고 모든 코드를 다 만들고 난 뒤에 이를 검증하려고 했다면, 쏟아지는 에러 메세지에 막막해졌을지도 모른다. 하지만 일단은 단순 무식한 방법으로 정상동작하는 코드를 만들고, 테스트를 만들어 뒀기 때문에 매우 작은 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다.

UserDao의 기능을 추가하려고 할 때도 미리 만들어둔 테스트 코드는 유용하게 쓰일 수 있다. 조금씩 기능을 더 추가해가면서 그에 대한 테스트도 함께 추가하는 식으로 점진적인 개발이 가능해진다. 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수 도 있다.

### UserDaoTest의 문제점
UserDaoTest가 UI까지 동원되는 번거로운 수동 테스트에 비해 장점이 많지만, 만족스럽지 못한 부분도 있다.

##### 수동 확인 작업의 번거로움
테스트를 수행하는 과정과 입력 데이터의 준비를 자동으로 진행하도록 만들었지만, 여전히 사람의 눈으로 확인하는 과정이 필요하다. 입력한 값과 가져온 값이 일치하는지를 테스트 코드는 확인해주지 않는다. 따라서 실수할 가능성이 있다.

##### 실행 작업의 번거로움
아무리 간단히 실행 가능한 main() 메소드라고 하더라도 매번 그것을 싱행하는 것은 제법 번거로운 일이다. DAO가 계속 추가되면서 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만들어진다면, 테스트를 위해 수백번 실행해야 할 수 도 있다.

따라서 좀더 편리하고 체계적인 테스트 방법이 필요하다.

## UserDaoTest 개선
### 테스트 검증의 자동화
첫 번째 문제점인 테스트 결과의 검증 부분을 코드로 만들어보자. 모든 테스트는 성공과 실패의 두 가지 결과를 가질 수 있다. 또 테스트의 실패는 테스트가 진행되는 동안에 에러가 발생해서 실패하는 경우와, 결과가 기대한 것과 다르게 나오는 경우로 구분해 볼 수 있다. 전자는 테스트 에러, 후자는 테스트 실패라고 하자.

테스트 중에 에러가 발생하는 것은 콘솔에 에러 메시지와 호출 스택 정보가 출력되기 때문에 쉽게 확인이 가능하다. 하지만 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야만 알 수 있다. 따라서 기존의 테스트 코드에서는 get()에서 가져온 결과를 사람이 눈으로 확인하도록 단순히 콘솔에 출력하기만 했는데, 이번에는 테스트 코드에서 결과를 직접 확인하고, 기대한 결과와 달라서 실패했을 경우에는 "실패" 라는 메시지를 출력하도록 만들어보자.

~~~Java
// 수정 전 테스트 코드
System.out.println(user2.getName());
System.out.println(user2.getPassword());
System.out.println(user2.getId() + " 조회 성공");
~~~

~~~java
// 수정 후 테스트 코드
if(!user.getName().equals(user2.getName())) {
  System.out.println("테스트 실패 (name)");
} else if(!user.getPassword().equals(user2.getPassword())) {
  System.out.println("테스트 실패 (password)");
} else {
  System.out.println("조회 테스트 성공");
}
~~~

처음 add()에 전달한 User 오브젝트와 get()을 통해 가져오는 User 오브젝트의 값을 비교해서 일치하는지 확인하도록 만들었다. 이렇게 해서 테스트의 수행과 테스트 값 적용, 그리고 결과를 검증하는 것까지 모두 자동화 했다.

거의 모든 과정을 자동화한 테스트가 만들어졌고, 이제는 테스트를 수행하고 출력 메시지가 "테스트 성공" 이라고 나오는지 확인하는 작업만 해주면 된다. 그렇기 때문에 실패 메시지가 나오면 그 원인을 찾아서 코드를 수정하고 다시 테스트를 실행하면 되고, 성공한다면 빠르게 다음 작업으로 넘어갈 수 있다.

xUnit 프레임워크를 만든 켄트 백은 "테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것"이라고 했다. 개발 과정에서, 또는 유지보수를 하면서 기존 애플리케이션 코드에 수정을 할 때 마음의 평안을 얻고, 자신이 만지는 코드에 대해 항상 자신감을 가질 수 있으며, 새로 도입한 기술의 적용에 문제가 없는지 확인할 수 있는 가장 좋은 방법은 빠르게 실행 가능하고 스스로 테스트 수행과 기대하는 결과에 대한 확인까지 해주는 코드로 된 자동화된 테스트를 만들어두는 것이다.

### 테스트의 효율적인 수행과 결과 관리
앞서서 편하게 테스트를 확인하려고 수정을 했지만, 좀 더 편리하게 테스트를 수행하고 편리하게 결과를 확인하려면 단순한 main() 메소드로는 한계가 있다. main() 메소드를 이용한 테스트 작성 방법만으로는 테스트 개수가 많아지면 테스트를 수행하는 일이 점점 부담이 될 것이다.

#### JUnit 테스트로 전환
JUnit 프레임워크를 도입해보자. 프레임 워크에서 동작하는 코드는 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는 코드를 만들 필요도 없다.

#### 테스트 메소드 전환
기존에 만들었던 main() 메소드 테스트는 그런 면에서 프레임워크에 적용하기엔 적합하지 않다. 테스트가 main() 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이기 때문이다. 새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두 가지를 따라야 한다. 첫째는 메소드가 public으로 선언돼야 하는 것이고, 둘째는 메소드에 @Test라는 애노테이션을 붙여주는 것이다.

~~~Java
// JUnit 프레임워크에서 동작할 수 있는 테스트 메소드로 전환
public class UserDatoTest {
  @Test
  public void addAndget() throws SQLException {
    ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);
    ...
  }
}
~~~

main() 대신에 일반 메소드로 만들고 적절한 이름을 붙여준다. 이왕이면 테스트의 의도가 무엇인지 알 수 있는 이름이 좋다. JUnit은 전통적으로 public 메소드만을 테스트 메소드로 허용하고 있다. 마지막으로 @Test 애노테이션을 붙여주면 된다.

#### 검증 코드 전환
테스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 방법을 이용해 전환해보자. 아래의 if문은 assertThat이라는 JUnit이 제공하는 스태틱 메소드를 이용해 변경할 수 있다.
~~~Java
if(!user.getName().eqauls(user2.getName())) {...}

assertThat(user2.getName(), is(user.getName()));
~~~

assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다.

JUnit은 예외가 발생하거나 assertThat() 에서 실패하지 않고 테스트 메소드의 실행이 완료되면 테스트가 성공했다고 인식한다. "테스트 성공" 이라는 메시지를 굳이 출력할 필요가 없다. JUnit이 테스트 실행 결과를 다양한 방법으로 알려주기 때문이다.

~~~Java
// JUnit을 적용한 UserDaoTest

public class UserDaoTest {
  @Test
  public void addAndGet() throws SQLException {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);
    User user = new User();
    user.setId("retrokarr");
    user.setName("김광현");
    user.setPassword("retro");

    dao.add(user);

    User user2 = dao.get(user.getId());

    assertThat(user2.getName(), is(user.getName()));
    assertThat(user2.getPassword(), is(user.getPassword()));
  }
}
~~~

#### JUnit 테스트 실행
스프링 컨테이너와 마찬가지로 JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다.

어디에는 main() 메소드를 하나 추가하고, 그 안에 JUnitCore 클래스의 main 메소드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 파라미터에는 @Test 테스트 메소드를 가진 클래스의 이름을 넣어준다.

~~~Java
public static void main(String[] args) {
  JUnitCore.main("springbook.user.dao.UserDaoTest");
}
~~~

~~~
JUnit version 4.7
Time: 0.578
OK (1 test)
~~~
실행하면 위와 같은 메시지를 볼 수 있다. 만약 코드에 이상이 있어서 assertThat() 의 검증에서 실패하면 다음과 같은 메시지가 나올 것이다.

~~~
Time: 1.094
There war 1 filure:
1) addAndGet(Springbook.dao.UserDaoTest)
java.lang.AssertionError:
Expected: is "김광현"
     got: null
     ...
     at springbook.dao.UserDaoTest.main(UserDaoTest.java:36)
FAILUSER!!!
Tests run: 1, Failures: 1
~~~
테스트가 실패하면 OK 대신 FAILUSER!!라는 내용이 출력되고, 총 수행한 테스트 중에서 몇 개의 테스트가 실패했는지 보여준다.

## 개발자를 위한 테스팅 프레임워크 JUnit
스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다. 따라서 스프링의 기능을 익히기 위해서라도 JUnit은 꼭 사용할 줄 알아야 한다.

### JUnit 테스트 실행 방법
JUnitCore를 이용해 테스트를 실행하고 콘솔에 출력된 메시지를 보고 결과를 확인하는 방법은 가장 간단하긴 하지만 테스트의 수가 많아지면 관리하기가 힘들어진다는 단점이 있다. 가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.

#### IDE
IDE에서는 보통 JUnit 테스트를 지원하는 기능을 제공하고 있다. 테스트의 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수를 확인할 수 있다.

#### 빌드 툴
프로젝트의 빌드를 위해 ANT나 메이븐(Maven) 혹은 그레들과 같은 빌드 툴과 스크립트를 사용한다면, 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다. 테스트 실행 결과는 옵션에 따라 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어진다.

개발자 개인별로는 IDE에서 JUnit 도구를 활용해 테스트를 실행하는게 가장 편리하지만, 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 경우에는 빌드 스크립트를 이용해 JUnit 테스트를 실행하고 그 결과를 메일 등으로 통보받는 방법을 사용하는 것도 좋다.

### 테스트 결과의 일관성
JUnit을 적용해서 깔끔한 테스트 코드를 만들었고, 편리하게 실행할 수 있는 툴의 사용도 해보았지만, 좀 더 개선이 필요한 부분이 있다. 지금까지 테스트를 실행하면서 가장 불편했던 일은, 매번 UserDaoTest 테스트를 실행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 하는 점이다. 개발자가 깜빡 잊는다면 테스트 실행 중에 에러가 발생할 것이다.

여기서 생각해볼 문제는 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다는 점이다. 반복적으로 테스트를 했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.

UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점이며, 가장 좋은 해결책은 addAndGet() 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다.

#### deleteAll()의 getCount() 추가
일관성 있는 결과를 보장하는 테스트를 만들기 위해 준비할 게 있는데, 바로 UserDao에 새로운 기능을 추가해주는 일이다.

##### deleteAll
deleteAll() 메소드는 USER 테이블의 모든 레코드를 삭제해주는 간단한 기능을 가지고 있다.

~~~Java
public void deleteAll() throws SQLException {
  Connection c = dataSource.getConnection();

  PreparedStatement ps = c.prepareStatement("delete from users");
  ps.executeUpdate();

  ps.close();
  c.close();
}
~~~

##### getCount()
getCount() 메소드는 USER 테이블의 레코드 개수를 돌려준다.
~~~Java
public int getCount() throws SQLException {
  PreparedStatement ps = c.preparedStatement("select count(*) from users");

  ResultSet rs = ps.executeQuery();
  re.next();
  int count = rs.getInt(1);

  rs.close();
  ps.close();
  c.close();

  return count;
}
~~~

#### deleteAll()과 getCount()의 테스트
새로운 기능을 추가했으니, 추가된 기능에 대한 테스트도 만들어야 한다. 그런데 deleteAll()과 getCount() 메소드의 기능은 add()와 get()처럼 독립적으로 자동 실행되는 테스트를 만들기가 좀 애매하다. 새로 유저를 등록하고 deleteAll()을 실행해야 하기 때문에, 새로운 테스트를 만들기보다는 차라리 기존에 만든 addAndGet() 테스트를 확장하는 방법을 사용하는 편이 더 나을 것 같다. addAndGet() 테스트의 불편함 점은 실행 전에 수동으로 USER 테이블의 내용을 모두 삭제해야한는 점이다. 그래서 deleteAll()을 이용하면 이 불편한 점을 해소할 수 있을것이다.

그런데 deleteAll() 자체도 아직 검증이 안됐는데 무턱대고 다른 테스트에 적용할 수는 없다. 그래서 getCount()를 함께 적용해보자. deleteAll()이 기대한 대로 동작한다면, getCount()로 레코드의 개수를 가져올 경우 0이 나와야 한다. 그러므로 deleteAll()을 실행한 직후에 getCount()의 결과값을 검증하고 코드를 넣어보자.

그런데 여기서 또 getCount()가 잘 동작하는지 어떻게 믿을 수 있을까? getCount() 메소드가 테이블의 레코드 숫자에 상관없이 항상 0을 돌려주는 버그를 갖고 있다면, deleteAll() 기능을 검증하는 데 사용할 수 없다. 검증 안 된 두 개를 붙였는데 우연히 테스트가 통과한다고 안심하는 것은 바람직 하지 못하다.

그래서 getCount()에 대한 검증 작업도 추가해보자. 시나리오는 이렇다. 이미 앞에서 add() 메소드가 정상적으로 DB 테이블에 데이터를 넣는 것을 확인헀으니 add()를 수행하고 나면 레코드의 개수가 0에서 1로 바뀌어야 한다. 그렇다면 add() 메소드를 실행한 뒤에 getCount()의 결과를 한 번 더 확인해보자. deleteAll() 직후에는 0이 나오고 add() 직후에는 1이 나온다면, getCount()의 기능이 바르게 동작한다고 불 수 있다. 그리고 getCount()가 바르게 동작한다는 확신이 있다면, deleteAll() 직후에 항상 0이 나오는 것을 보고 deleteAll()의 기능도 바르게 동작한다고 생각할 수 있다.

~~~Java
//deleteAll()과 getCount()가 추가된 addAndGet() 테스트
public void addAndGet() throws SQLException {
  ...

  dao.deleteAll();
  assertThat(dao.getCount(), is(0));

  User user = new User();
  user.setId("syntaxtree");
  user.setName("김광현");
  user.setPassword("tree");

  dao.add(user);
  assertThat(dao.getCount(), is(1));

  User user2 = dao.get(user.getId());

  assertThat(user2.getName(), is(user.getName()));
  assertThat(user2.getPassword(), is(user.getPassword()));
};
~~~
이렇게 deleteAll()과 getCount()를 기존 addAndGet() 테스트에 추가헀다.

#### 동일한 결과를 보장하는 테스트
테스트를 하기 전에 매번 직접 DB에서 데이터를 삭제해야 했지만, 이제는 그런 번거로운 과정이 필요 없어졌다. 테스트가 어떤 상황에서 반복적으로 실행된다고 하더라도 동일한 결과가 나올 수 있게 된 것이다. 이렇게 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다. DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야한다.

### 포괄적인 테스트
getCount() 메소드를 테스트에 적용하긴 했지만, 이전 테스트가 아니라, 두 개 이상의 레코드를 add() 했을 때도 정상 동작하는 지는 모르는 일이다, 0과 1 두 가지를 해봤으니 나머지도 당연히 잘될 것이라고 생각할 수도 있겠지만 미처 생각하지 못한 문제가 숨어 있을지도 모르니 더 꼼꼼한 테스트를 해보는 것이 좋은 자세다. 테스트를 안 만드는 것도 위험한 일이지만, 성의 없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다. 특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.

#### getCount()테스트
그러니 getCount()에 대한 좀 더 꼼꼼한 테스트를 만들어보자. JUnit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어가는 것을 허용한다. @Test가 붙어있고 public 접근자가 있으며 리턴 값이 void형이고 파라미터가 없다는 조건을 지키기만 하면 된다.

테스트 시나리오는 이렇다. 먼저 USER 테이블의 데이터를 모두 지우고 getCount()로 레코드 개수가 0임을 확인한다. 그리고 3개의 사용자 정보를 하나씩 추가하면서 매번 getCount()의 결과가 하나씩 증가하는지 확인하는 것이다.

테스트를 만들기 전에 먼저 User 클래스에 한 번에 모든 정보를 넣을 수 있도록 생성자를 추가하자.

~~~Java
public User(String id, String name, String password) {
  this.id = id;
  this.name = name;
  this.password = password;
}
public User() {
}
~~~
~~~Java
@Test
public void count() throws SQLException {
  ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

  UserDao dao = context.getBean("userDao", UserDao.class);
  User user1 = new User("syntax", "문법", "syntax");
  User user2 = new User("tree", "나무", "tree");
  User user3 = new User("retro", "복고", "retro");

  dao.deleteAll();
  assertThat(dao.getCount(), is(0));

  dao.add(user1);
  assertThat(dao.getCount(), is(1));

  dao.add(user2);
  assertThat(dao.getCount(), is(2));

  dao.add(user3);
  assertThat(dao.getCount(), is(3));
}
~~~

주의해야 할 점은 두 개의 테스트가 어떤 순서로 실행될지는 알 수 없다는 것이다. JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.

#### addAndGet() 테스트 보완
이번엔 addAndGet() 테스트를 좀 더 보완해보자. count()에서도 add()에 대한 테스트로 기능에 대한 검증은 춘분히 된 것 같다. 하지만 아직 get()에 대한 충분한 검을 하지 않았으므로 get()메소드에 대한 테스트 기능을 좀 더 보완할 필요가 있다. User를 하나 더 추가해서 두 개의 User를 add()하고, 각 User의 id를 파라미터로 전달해서 get()을 실행하도록 만들어보자.

~~~Java
@Test
public void anddAndGet() throws SQLException {
  ...
  UserDao dao = context.getBean("userDao", UserDao.class);
  User user1 = new User("syntax", "문법", "syntax");
  User user2 = new User("tree", "나무", "tree");

  dao.deleteAll();
  assertThat(dao.getCount(), is(0));

  dao.add(user1);
  dao.add(user2);
  assertThat(dao.getCount(), is(2));

  User userget1 = dao.get(user1.getId());
  assertThat(userget1.getname(), is(user1.getName()));
  assertThat(userget1.getPassword(), is(user1.getPassword()));

  User userget2 = dao.get(user2.getId());
  assertThat(userget2.getName(), is(user2.getName()));
  assertThat(userget2.getPassword(), is(user2.getPassword()));
}
~~~
이렇게 해서 get() 메소드가 기대한 대로 동작하는지를 좀 더 확신할 수 있게 됐다.

#### get() 예외조건에 대한 테스트
한 가지 더 생각해볼 문제가 있다. get() 메소드에 전달된 id값에 해당하는 사용자 정보가 없다면 어떻게 될까? 이런 경우는 아직 생각해본 적이 없다. 두 가지 방법이 있을 것이다. 하나는 null과 같은 특별한 값을 리턴하는 것이고, 다른 하나는 id에 해당하는 정보를 찾을 수 없다고 예외를 던지는 것인데, 두번째 방법을 사용해보자.

주어진 id에 해당하는 정보가 없다는 의미를 가진 예외 클래스가 하나 필요하다. 스프링이 정의한 데이터 액세스 예외 클래스인 EmptyResultDataAccessException를 사용해 보자

UserDao의 get() 메소드에서 쿼리를 실행해 결과를 가져왔을 때 아무것도 없으면 이 예외를 던지도록 만들면 된다, 코드를 만들기 전에, 이런 경우를 어떻게 테스트 코드로 만들지 생각해보자, 일반적으로는 테스트 중에 예외가 던져지면 테스트 메소드의 실행은 중단되고 테스트는 실패한다. assertThat()을 통한 검증 실패는 아니고 테스트 에러라고 볼 수 있다. 그런데 이번에는 반대로 테스트 진행 중에 특정 예외가 던져지면 테스트가 성공한 것이고, 예외가 던져지지 않고 정상적으로 작업을 마치면 테스트가 실패했다고 판단해야 한다. 즉 assertThat() 메소드로는 검증이 불가능하다.

이런 경우를 위해 JUnit은 예외조건 테스트를 위한 특별한 방법을 제공해준다.

~~~Java
@Test(expected=EmptyResultDataAccessException.class)
public void getUserFailure() throws SQLException {
  ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

  UserDao dao = context.getBean("userDao", UserDao.class);
  dao.deleteAll();
  assertThat(dao.getCount(), is(0));

  dao.get("unknown_id"); //예외가 발생해야 한다.
}
~~~

이 테스트에서 중요한 것은 @Test 애노테이션의 expected 엘리먼트다. expected는 테스트 메소드 실행 중에 발생하리라 기대하는 예외 클래스르르 넣어주면 된다.

expected를 추가해 놓으면 보통의 테스트와는 반대로, 정상적으로 테스트 메소드를 마치면 테스트가 실패하고, expected에서 지정한 예외가 던져지면 테스트가 성공한다.

그런데 이 테스트를 실행시키면 어떻게 될까? rs.next()를 실행할 때 가져올 로우가 없다는 SQLException이 발생할 것이다. 아직 UserDao 코드를 수정하지 않았으니 당연하지만..

#### 테스트를 성공시키기 위한 코드의 수정
이제부터 할 일은 이 테스트가 성공하도록 get() 메소드 코드를 수정하는 것이다. 코드는 다음과 같다

~~~Java
public User get(String id) throws SQLException {
  ...
  ResultSet res = ps.executeQuery();

  User user = null;
  if(rs.next()) {
    user = new User();
    user.setId(rs.getString("id"));
    user.setName(rs.getString("name"));
    user.setPassword(rs.getString("password"));
  }

  rs.close();
  ps.close();
  c.close();

  if(user == null)
    throw new EmptyResultDataAccessException(1);

  return user;
}
~~~

최종적으로 모든 테스트가 성공하면, 새로 추가한 기능도 정상적으로 동작하고 기존의 기능에도 영향을 주지 않았다는 확신을 얻을 수 있다.


#### 포괄적인 테스트
개발자가 테스트를 직접 만들 떄 자주 하는 실수가 하나 있다. 바로 성공하는 테스트만 골라서 만드는 것이다. 조금만 신경을 쓰면 자신이 만든 코드에서 발생할 수 있는 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들 수 있다. 스프링의 창시자인 로드 존슨은 "항상 네거티브 테스트를 먼저 만들라"는 조언을 했다. 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

### 테스트가 이끄는 개발
get() 메소드의 예외 테스트를 만드는 과정을 다시 돌아보면 한 가지 흥미로운 점을 발견할 수 있다. 테스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 UserDao의 코드에 손을 대기 시작했다. 이를 TDD라고 한다.

#### 기능설계를 위한 테스트
우리가 한 작업을 돌이켜보자. 먼저 '존재하지 않는 id로 get() 메소드를 실행하면 특정한 예외가 던져져야 한다'는 식으로 만들어야 할 기능을 결정했다. 그리고 나서 UserDao 코드를 수정하는 대신 getUserFailure() 테스트를 먼저 만들었다. 테스트할 코드도 없는데 어떻게 테스트를 만들 수 있었을까? 답은 추가하고 싶은 기능을 코드로 표현하려고 했기 때문에 가능했다.

||단계|내용|코드|
|:---|:---|:---|:---|
|조건|어떤 조건을 가지고|가져올 사용자 정보가 존재하지 않는 경우에|dao.deleteAll(); assertThat(dao.getCount(), is(0));|
|행위|무엇을 할 때|존재하지 않는 id로 get()을 실행하면|get("unknown_id");|
|결과|어떤 결과가 나온다|특별한 예외가 던져진다|@Test(expected=EmptyResultDataAccessException.class)|

 이렇게 비교해보면 이 테스트 코드는 마치 잘 작성된 하나의 기능정의서처럼 보인다. 이런 식으로 추가하고 싶은 기능을 일반 언어 아니라 테스트 코드로 표현해서, 마치 코드로 된 설계문서처럼 만들어놓은 것이라고 생각해보자. 그리고 나서 실제 기능을 가진 애플리케이 코드를 만들고 나면, 이 테스트를 실행해서 설계한 대로 코드가 동작하는지를 빠르게 검증할 수 있다.

 만약 테스트가 실패하면 이때는 설계한 대로 코드가 만들어지지 않았음을 바로 알수 있다. 그리고 문제가 되는 부분이 무엇인지에 대한 정보도 테스트 결과를 통해 얻을 수 있다. 다시 코드를 수정하고 테스트를 수행해서 테스트가 성공하도록 코드를 다듬어간다. 결국 테스트가 성공한다면, 그 순간 코드 구현과 테스트라는 두 가지 작업이 동시에 끝나는 것이다.

 #### 테스트 주도 개발
 만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발방법을 테스트 주도 개발(TDD, Test Driven Development)라고 한다.

 TDD는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있으며, "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다"는 것이 TDD의 기본 원칙이다. 따라서 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.

 개발자들이 정신없이 개발을 하다 보면 사이사이 테스트를 만들어서 코드를 점검할 타이밍을 놓치는 경우가 많다. 빨리 기능을 완성하고 싶은 욕구 때문일 수 도 있고, 한 번 집중하면 정신없이 빠져드는 습성 때문이기도 하다. 문제는 코드를 만들고 나서 시간이 많이 지나면 테스트를 만들기가 귀찮아진다는 점이다. 또, 작성한 코드가 많기 때문에 무엇을 테스트해야 할 지 막막할 수 도 있다. 결국 테스트 작성은 자꾸 뒷전으로 밀려나거나 점점 더 성의 없는 테스트를 만들게 될지도 모른다.

 TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다. 또한 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다. 사실 코드를 만들고 테스트를 수행할 때까지 걸리는 시간은 0에 가깜다. 이미 테스트를 만들었기 때문에 코드를 작성하면 바로바로 테스트를 실행해볼 수 있기 때문이다. 그 덕분에 코드에 대한 피드백을 매우 빠르게 받을 수 있게 된다. 또, 매번 테스트가 성공하는 것을 보면서 작성한 코드에 대한 확신을 가질 수 있어, 가벼운 마음으로 다음 단계로 넘어갈 수가 있다. 한편으로는 자신감을, 다른 한편으로는 마음의 여유를 주는 방법이다.

 TDD에서는 테스트 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 한 짧게 가져가도록 권장한다.

사실 모든 개발자는 TDD를 몰라도 이미 테스트가 개발을 이끌어가는 방식으로 개발을 하고 있다. 한번 생각해보자, 새로운 기능을 가진 코드를 만들려고 하는 순간, 개발자의 머릿속에서는 '이런 조건하에서 이런 작업을 하면 이런 경과가 나올것이다'라는 식으로 기능을 먼저 정리하게 될 것이다. 그리고 코드를 작성하는 동안에도 코드를 눈으로 훑어보면서, '이런 조건의 값이 들어오면 코드의 흐름과 조건을 따라 이렇게 진행돼서 이런 결과 값이 나오겠다'라는 식으로 시뮬레이션을 계속 하게 된다. 그렇다면 개발자의 머릿속에서는 테스트가 미리 만들어지고 개발 중에 계속 실행된다고 볼 수 도 있지 않을까? 코드를 살펴보다가 이런 경우에는 문제가 발생하겠다는 생각이 들면 코드를 수정할 것이다. 테스트가 실패했으니 테스트가 성공하도록 코드를 수정하는 것과 다를 바 없다.

문제는 이렇게 머릿속에서 진행되는 테스트는 제약이 심하고, 오류가 많고, 나중에 다시 반복하기가 힘들다는 점이다. 그래서 차라리 머릿속에서 복잡하게 진행하던 작업을 실제 코드로 끄집어 내놓으면 이게 바로 TDD가 된다.

TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다. 개발한 코드의 오류는 빨리 발견할수록 좋다. 빨리 발견된 오류는 쉽게 대응이 가능하기 때문이다. 테스트 없이 오랜 시간 동안 코드를 만들고 나서 테스트를 하면, 오류가 발생했을 때 원인을 찾기가 쉽지 않다.

테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트 없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다. 테스트를 먼저 만들어두면 코딩이 끝나자마자 바로 테스트를 실행할 수 있으니 가장 좋은 방법이다.

### 테스트 코드 개선
이쯤 해서 테스트 코드를 리팩토링해보자. 애플리케이션 코드뿐만 아니라 필요하다면 테스트 코드도 언제든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들 필요가 있다.

UserDaoTest 코드를 잘 살펴보면 기계적으로 반복되는 부분이 눈에 띈다. 다음과 같이 스프링의 애플리케이션 컨텍스트를 만드는 부분과 컨텍스트에서 UserDao를 가져오는 부분이다.

~~~Java
ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

User dao = context.getBean("userDao", UserDao.class);
~~~
중복된 코드는 별도의 메소드로 뽑아내는 것이 가장 손쉬운 방법이다. 그런데 이번에는 메소드 추출 리팩토링 방법 말고 JUnit이 제공하는 기능을 활용해보자. JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업이 몇 가지 있다. 그중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소드에 넣게 해주고, 이를 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능이다.

#### @Before
중복됐던 코드를 넣을 setUP()이라는 이름의 메소드를 만들고 테스트 메소드에서 제거한 코드를 넣는다. 그런데 문제는 테스트 메소드에서 필요한 dao 변수가 setUp() 메소드의 로컬 변수로 되어 있다는 점이다. 그래서 이번엔 로컬 변숭니 dao를 테스트 메소드에서 접근할 수 있도록 인스턴스 변수로 변경하자.

~~~Java
public class UserDaoTest {
  private UserDao dao;

  @Before
  public void setUp() {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
    this.dao = context.getBean("userDao", UserDao.class);
  }

  ...
  @Test
  public void addAndGet() throws SQLException {
    ...
  }
  @Test
  public void count() throws SQLException {
    ...
  }
  @Test(expected=EmptyResultDataAccessException.class)
  public void getUserFailure() throws SQLException {
    ...
  }
}

JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.
1. 테스트 클래스에서 @Test가 붙은 public 이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

JUnit은 @Test가 붙은 메소드를 실행하기 전과 후에 각각 @Before와 @Aftrer가 붙은 메소드를 자동으로 실행한다.
꼭 기억해야 할 사항은 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 마든다는 점이다. 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 것일까?
JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 헀다.

테스트 메소드의 일부에서만 공통적으로 사용되는 코드는 @Before, @After대신 일반적인 메소드 추출 방법을 써서 분리하고 테스트 메소드에서 직접 호출해 사용하는 것이 더 낫다.

#### 픽스처
테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처(fixture)라고 한다. 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성하면 편리하다. UserDaoTest에서라면 dao가 대표적인 픽스처이다.

테스트 중에 add() 메소드에 전달하는 User 오브젝트들도 픽스처라고 볼 수 있다. 앞으로 UserDao의 기능이 계속 만들어지고 그에 따라 테스트 메소드도 계속 추가도리 텐데 UserDao에 대한 테스트라면 대부분 User 오브젝트를 사용할 것이다. 따라서 @Before에서 생성하도록 만들어 보자.

~~~Java
//User 픽스처를 적용한 UserDaoTest
public class UserDaoTest {
  private UserDao da;
  private User user1;
  private User user2;
  private User user3;

  @Before
  public void setUp() {
    ...
    this.user1 = new User("syntax", "문법", "syntax1");
    this.user2 = new User("tree`", "나무", "tree1");
    this.user3 = new User("retro", "복고", "retro1");
    ...
  }
}
~~~


### 스프링 테스트 적용
이제 테스트 코드도 어느 정도 깔끔하게 정리를 마쳤다. 아직 한 가지 찜찜한 부분이 있는데, 바로 애플리케이션 컨텍스트 생성 방식이다. @Befoer 메소드가 테스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 세 번 만들어진다.

추후에 빈이 많아지고 복작해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다. 애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다. 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 제법 많은 시간을 필요로 하기 때문이다.

어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다는 점이다. 이런경우는 빈이 할당한 리소스 등을 깜끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다.

테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용하는 것이 원칙이다. 하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다.

다행히도 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의 없다. 또한 빈은 싱글톤으로 만들었기 때문에 상태를 갖지 않는다. 문제는 JUnit이 매번 테스트 클래스의 오브젝트를 새로 만든다는 점이다. JUnit은 테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 @BeforeClass 스태틱 메소드를 지원한다. 이 메소드에서 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용하게 할 수 있다. 하지만 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 더 편리하다.

### 테스트를 위한 애플리케이션 컨텍스트 관리
스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공핟나. 간단한 애노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

#### 스프링 테스트 컨텍스트 프레임워크 적용
먼저 @Before 메소드에서 애플리케이션 컨텍스트를 생성하는 다음 코드를 제거한다.

~~~Java
ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
~~~
그리고 이 ApplicationContext 타입의 인스턴스 변수를 선언하고 @Autowired 애노테이션을 붙여준다. 마지막으로 클래스 레벨에 @RunWith와 @ContextConfiguration 애노테이션을 아래와 같이 추가해준다.

~~~Java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {
  @Autowired
  private ApplicationContext context;
  ...

  @Before
  public void setUP() {
    this.dao = this.contextgetBean("userDao", UserDao.class);
    ...
  }
}
~~~
인스턴스 변수인 context는 어디에서도 초기화해주는 코드가 없는데, setUP() 메소드에서 context를 사용하려고 해도 NullPointerException이 발생하지 않는다. 그 이유는 context변수에 애플리케이션 컨텍스트가 들어 있기 때문이다. @RunWith는 JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 애노테이션이다. SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.

#### 테스트 메소드의 컨텍스트 공유
어떤 일이 일어나고 있는지 확인해보자.
~~~Java
@Before
public void setUP() {
  System.out.println(this.context);
  System.out.println(this);
}
~~~
setUP() 메소드는 @Before가 붙어 있으니 매 테스트 메소드가 실행되기 전에 한 번씩 실행된다. 그런데 this를 콘솔에 출력하면 다음과 같은 결과가 나온다.

~~~Java
org.springframework.context.support.GenericApplicationContext@d3d6f;
springbook.dao.userDaoTest@115d06c
org.springframework.context.support.GenericApplicationContext@d3d6f;
springbook.dao.userDaoTest@116318b
org.springframework.context.support.GenericApplicationContext@d3d6f;
springbook.dao.userDaoTest@15e0c2b
~~~
출력된 context와 this의 오브젝트 값을 살펴보면, context는 세 번 모두 동일하다, 하나의 애플리케이션 컨텍스트가 만들어져 모든 테스트 메소드에서 사용되고 있음을 알 수 있다. 반면에 UserDaoTest의 오브젝트는 매번 주소 값이 다르다. JUnit은 테스트 메소드를 실행할 때마다 새로운 테스트 오브젝트를 만들기 때문이다.

JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해주는 것이다. 일종의 DI라고 도 볼수 있는데, 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 성격이 조금 다르다.

어쨋든 이렇게 해서 하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유함을 확인했다.

#### 테스트 클래스의 컨텍스트 공유
스프링 테스트 컨텍스트 프레임워크의 기능은 하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아니다. 여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.

다음과 같은 경우에 말이다.
~~~Java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class UserDaoTest {...}

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations="/applicationContext.xml")
public class GroupDaoTest {...}
~~~

따라서 수백 개의 테스트 클래스를 만들어도 같은 설정파일을 사용한다고 하면, 하나의 애플리케이션 컨텍스트만 만들어져 사용된다.

#### @Autowired
@Autowired는 스프링의 DI에 사용되는 특별한 애노테이션이다.

@Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다. 일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만, 이 경우에는 메소드가 없어도 주입이 가능하다. 또 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데, 이런 방법을 타입에 의한 자동와이어링이라고 한다.

테스트 코드에서는 applicationContext.xml 파일에 정의된 빈이 아니라, ApplicationContext라는 타입의 변수에 @Autowired를 붙였는데 애플리케이션 컨텍스트가 DI됐다. 어떻게 된 것일까? 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능한 것이다.

@Autowired를 이용해 애플리케이션 컨텍스트가 갖고 있는 빈을 DI 받을 수 있다면 굳이 컨텍스트를 가져와 getBean()을 사용하는 것이 아니라. 아예 UserDao 빈을 직접 DI 받을 수도 있을 것이다. 아래처럼

~~~Java
// UserDao를 직접 DI 받도록 만든 테스트
...
public class UserDaoTest {
  @Autowired
  UserDao user;// UserDao 타입 빈을 직접 DI받는다.
  ...
}
~~~

@Autowired를 지정하기만 하면 어떤 빈이든 다 가져올 수 있다. @Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다. 따라서 클래스 타입은 물론이고, 인터페이스 타입으로 변수를 선언해도된다. 단, @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다. 예를 들어 DataSource 타입의 빈이 두 개 이상 설정되어 있다면 다음과 같은 선언은 문제가 될 수 있다. @Autowired는 타입으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는지 확인한다. 변수 이름으로도 빈을 찾을 수 없는 경우에는 예외가 발생한다.

~~~Java
@Autowired
DataSource dataSource;
~~~

그런데 SimpleDriverDataSource 타입의 변수로 선언하는 방법과 DataSource 타입으로 선언하는 방법 중 어느 것이 나을까? 단순히 DataSource에 정의된 메소드를 테스트에서 사용하고 싶은 경우라면 DataSource 타입으로 받는 게 좋다. 반면 테스트에서 SimpleDriverDataSource라는 타입의 오브젝트 자체에 관심이 있는 경우에는 SimpleDriverDataSource 타입으로 선언해야한다.

하지만 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.

### DI와 테스트
UserDao와 DB 커넥션 생성 클래스 사이에는 DataSource라는 인터페이스를 사용했다. 그런데 "우리는 절대로 DataSource의 구현 클래스를 바꾸지 않을 것이다. 우리는 항상 SimpleDriverDataSource를 사용할 것이다"라고 주장했을때 과연 인터페이스를 사용하지 않아도 될까? 아니다 그래도 인터페이스를 두고 DI를 적용해야 한다. 그 이유를 알아보자.

첫째, 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다. 언젠가 변경이 필요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용의 부담을 줄여줄 수 있다면, 인터페이스를 사용하고 DI를 적용하는 작은 수고를 하지 않을 이유가 없다.

둘째, 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다. 1장에서 만들어봤던 DB 커넥션의 개수를 카운팅하는 부가기능이 그런 예다.

세번째 이유는 테스트 때문이다. 단지 효율적인 테스트를 손쉽게 만들기 위해서도 DI를 적용해야 한다. 테스트를 잘 활용하려면 자동으로 실행 가능하며 빠르게 동작하도록 테스트 코드를 만들어야 한다. 그러기 위해서는 가능한 한 작은 단위의 대상에 국한해서 테스트해야 한다. 테스트할 대상의 범위가 넒어지면 테스트를 작성하기가 어려워진다. DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는 데 중요한 역할을 한다.

### 테스트 코드에 의한 DI
DI는 애플리케이션 컨텍스트 같은 스프링 컨테이너에서만 할 수 있는 작업이 아니다. 이미 오브젝트 팩토리인 DaoFactory를 이용해서 프레임워크의 도움 없이 직접 DI를 적용해보기도 했듯이 말이다. UserDao에는 DI 컨테이너가 의존관계 주입에 사용하도록 수정자 메소드를 만들어뒀다. 이 수정자 메소드는 평범한 자바 메소드이므로 테스트 코드에서는 얼마든지 호출해서 사용할 수 있다. 따라서 테스트 코드 내에서 이를 이용해서 직접 DI해도 된다. UserDao가 사용할 DataSource 오브젝트를 테스트 코드에서 변경할 수 있다.

applicationContext.xml에 정의된 DataSource 빈은 서버의 DB 풀 서비스와 연결해서 운영용 DB 커넥션을 돌려주도록 만들어져 있다고 해보자. 테스트할 때 이 DataSource를 이용해도 될까? 절대 안된다. 이럴땐 테스트 코드에 의한 DI를 이용해서 테스트 중에 DAO가 사용할 DataSource 오브젝트를 바꿔주는 방법을 이용하면 된다.

테스트용 DB에 연결해주는 DataSource를 테스트 내에서 직접 만들어서 수동으로 DI해보자. 구현 클래스는 스프링이 제공하는 가장 빠른 DataSource인 SingleConnectionDataSource를 사용해보자. SingleConnectionDataSource는 DB커넥션을 하나만 만들어두고 계속 사용하기 때문에 매우 빠르다.

~~~Java
// 테스트를 위한 수동 DI를 적용한 UserDaoTest
//DirtiesContext는 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려준다.
@DirtiesContext
public class UserDaoTest {
  @Autowired
  UserDao dao;

  @Before
  public void setUp() {
    ...
    DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql://localhost/testdb", "syntax", "tree", true);
    dao.setDataSource(dataSource); //코드에 의한 수동 DI
    ...
  }
}
~~~
이 방법의 장점은 XML 설정파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다는 것이다. 이 방식은 매우 주의해서 사용해야한다. 스프링 테스트 컨텍스트 프레임워크를 적용했다면 애플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해서 사용한다고 했다. 따라서 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하게 되는 것이다. 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙인데, 위의 테스트 코드는 애플리케이션 컨텍스트에서 가져온 UserDao 빈의 의존관계를 강제로 변경한다. 한 번 변경하면 나머지 모든 테스트를 수행하는 동안 변경된 애플리케이션 컨텍스트가 계속 사용될 것이다.

그래서 UserDaoTest에 @DirtiesContext라는 애노테이션을 추가해줬다.(메소드 레벨에서도 사용 가능) 이 애노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 그러면 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 테스트 메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트가 사용하게 해준다.

#### 테스트를 위한 별도의 DI 설정
테스트 코드에서 빈 오브젝트에 수동으로 DI 하는 방법은 장점보다 단점이 많다. 코드가 많아져 번거롭기도 하며, 애플리케이션 컨텍스트도 매번 새로 만들어야 하는 부담이 있다.

그래서 아예 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어두는 방법을 이용하도록 하자. 새로운 테스트 정용 설정파일을 만들고 테스트에서는 이 설정파일만 사용하도록 하면 된다.

먼저 기존의 applicationContext.xml을 복사해서 test-applicationContext.xml이라고 만들자.
~~~xml
// 테스트 DB 변경 설정
<bean id="dataSource"
  class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
  <property name="driverClass" value="com.mysql.jdbc.Driver" />
  <property name="url" value="jdbc:mysql://localhost/testdb" />
  <property name="username" value="syntax" />
  <property name="password" value="tree" />
</bean>
~~~

그리고 UserDaoTest의 @ContextConfiguration 애노테이션에 있는 locations 엘리먼트의 값을 위의 새로 만든 테스트용 설정파일로 변경해준다.

이제 테스트는 이 설정파일 정보를 이용하는 애플리케이션 컨텍스트를 사용할 수 있게 됐다. 나머지 테스트 코드는 수정하지 않아도 되며, 번거롭게 수동 DI 하는 코드나 @DirtiesContext도 필요어졌다.


### 컨테이너 없는 DI 테스트
DI를 테스트에 이용하는 방법은 아예 스프링 컨테이너를 사용하지 않고 테스트를 만드는 것이다. UserDao나 DataSource 구현 클래스 어디에도 스프링의 API를 직접 사용한다거나 애플리케이션 컨텍스트를 이용하는 코드는 존재하지 않는다. 스프링 DI 컨테이너에 의존하지 않는다는 말이다. 따라서 원한다면 스프링 컨테이너를 이용해서 IoC 방식으로 생성되고 DI 되도록 하는 대신, 테스트 코드에서 직접 오브젝트를 만들고 DI 해서 사용해도 된다.

UserDaoTest는 사실 UserDao 코드가 DAO로서 DB에 정보를 잘 등록하고 잘 가져오는지만 확인하면 된다. 스프링 컨테이너에서 UserDao가 동작함을 확인하는 일은 UserDaoTest의 기본적인 관심사가 아니다.

스프링 컨테이너 없이 테스트 코드의 수동 DI만을 이용해 만들어진 테스트 코드를 아래와 같이 짤 수 있다. @RunWith를 사용해서 스프링 테스트 컨테스트 프레임워크를 적용하지도 않았고, @Autowired를 사용해서 애플리케이션 컨텍스트에서 UserDao를 가져오지도 않는다. 대신 @Before 메소드에서 직접 UserDao의 오브젝트를 생성하고, 테스트용 DataSource 오브젝트를 만들어 직접 DI 해줬다.
~~~java
//애플리케이션 컨텍스트 없는 DI 테스트
public class UserDaoTest {
  UserDao dao; //@Autowired가 없다
  ...

  @Before
  public void setUp() {
    ...
    dao = new UserDao();
    DataSource dataSource = new SingleConnectionDataSource("jdbc:mysql://localhost/testdb", "syntax", "tree", true);
    dao.setDataSource(dataSource); //오브젝트 생성 관계설정 등을 모두 직접 해준다.
  }
}
~~~

테스트를 위한 DataSource를 직접 만드는 번거로움은 있지만 애플리케이션 컨테스트를 아예 사용하지 않는 코드는 더 단순해지고 이해하기 편해졌다.

DI는 객체지향 프로그래밍 스타일이다. 따라서 DI를 위해 컨테이너가 반드시 필요한 것은 아니다. DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.

DI가 적용된 코드는 테스트에서도 다양한 방식으로 활용할 수 있을 만큼 유연하다. 어디에 DI를 적용할지 고민되는 경우, 효과적인 테스트를 만들기 위해서는 어떤 필요가 있을지를 생각해보면 도움이 된다. 두 개의 모듈이 강하게 결합되어 있어 DI가 불가능한 구조로 만든다면 테스트할 때 불편해진다거나. 자동화된 테스트가 아예 불가능하지 않을까 의심해보자. 일반적으로 테스트하기 좋은 코드가 좋은 코드일 가능성이 높다. 그 반대도 마찬가지다.


### DI를 이용한 테스트 방법 선택
그렇다면 DI를 테스트에 이용하는 세 가지 방법 중 어떤 것을 선택해야할까?

항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자. 이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다.

여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우가 있을때는 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다.

테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다. 이때는 컨텍스트에서 DI 빧은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다. 테스트 메소드나 클래스에 @DirtiesContext 애노테이션을 붙이는 것을 잊지 말자.


## 학습 테스트로 배우는 스프링
개발자가 자신이 만든 코드가 아닌 다른 사람이 만든 코드와 기능에 대한 테스트를 작성할 필요가 있을까? 일반적으로 애플리케이션 개발자는 자신이 만들고 있는 코드에 대한 테스트만 작성하면 된다. 하지만 때로는 자신이 만들지 않는 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다. 이런 테스트를 학습 테스트(learning test)라고 한다.

학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히려는 것이다. 따라서 테스트이지만 프레임워크나 기능에 대한 검증이 목적이 아니다. 오히려 자신이 테스트를 만들려고 하는 기술이나 기능에 대한 얼마나 제대로 이해하고 있는지, 그 사용 방법을 바로 알고 있는지를 검증하려는게 목적이다. 또, 테스트 코드를 작성해보면서 빠르고 정확하게 사용법을 익히는 것도 학습 테스트를 작성하는 목적이다.

### 학습 테스트의 장범
##### 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
다양한 조건에 따라 어떻게 기능이 다르게 동작하는지 확인해보려면 수동으로 값을 입력하거나 코드를 계속 수정해가며 예제를 다시 실행해야 한다. 반면에 학습테스트는 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는지 빠르게 확인할 수 있다.

##### 학습 테스트 코드를 개발 중에 참고할 수 있다.
수동으로 예제를 만드는 방법은 코드를 계속 수정해가면서 기능을 확인해보기 때문에 결국 최종 수정한 예제 코드만 남아 있다. 반면에 학습 테스트는 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 만들고 남겨둘 수 있다. 이렇게 테스트로 새로운 기술의 다양한 기능을 사용하는 코드를 만들어두면 실제 개발에서 샘플 코드로 참고할 수 있다.

복잡한 기능이라면 테스트에 관련된 설정파일도 만들어질 것이고, 초기화는 어떻게 하는지 API 호출 방법은 어떤 것인지, 결과는 어떻게 가져와야 하는지에 대한 샘플 코드가 테스트 안에 모두 만들어진다. 이렇게 미리 만들어진 다양한 기능에 대한 테스트 코드가 좋은 참고 자료가 된다.

##### 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
요즘은 모든 제품이 매우 빠르게 업데이트된다. 문제는 이렇게 새로운 버전으로 업그레이드 할 때 API 사용법에 미묘한 변화가 생긴다거나, 기존에는 잘 동작하던 기능에 문제가 발생할 수도 있다는 점이다. 테스트를 만들어 놓았다면 새로운 버전의 프레임워크나 제품을 학습 테스트에만 먼저 적용해본다. 기존에 사용했던 API나 기능에 변화가 있거나 업데이트된 제품에 버그가 있다면, 학습 테스트를 통해 미리 확인할 수가 있다.

##### 테스트 작성에 대한 좋은 훈련이 된다.
테스트를 작성하는 데 아직 충분히 훈련되어 있지 않거나 부담을 갖고 있다면, 먼저 학습 테스트를 작성해보면서 테스트 코드 작성을 연습할 수 있다. 프레임워크의 학습 테스트는 실제로 프레임워크를 사용하는 애플리케이션 코드의 테스트와 비슷하게 만들어진다. 또한 학습 테스트는 한두 가지 간단한 기능에만 초점을 맞추면 되기 때문에 테스트도 대체로 단순하다. 따라서 애플리케이션 개발 중에 작성하는 테스트보다는 한결 작성하기가 수월하고 부담도 적다. 학습 테스트를 테스트 작성의 훈련 기회로 삼는 것도 좋다. 또는 새로운 테스트 방법을 연구하는 데도 도움이 된다.

##### 새로운 기술을 공부하는 과정이 즐거워진다.
책이나 레퍼런스 문서 등을 그저 읽기만 하는 공부는 쉽게 지루해진다. 그에 비해 테스트 코드를 만들면서 하는 학습은 흥미롭고 재미있다.

학습 테스트는 당장 적용할 일부 기능의 사용법을 익히기 위해서만이 아니라 새로운 프레임워크나 기술을 전반적으로 공부하는 과정에서도 유용한다. 스프링 레퍼런스 매뉴얼이나 관련 서적을 가지고 공부하면서 설명이 잘 이해가 안된다거나 자세한 사용 방법이 궁금하다면 직접 학습 테스트로 만들어보는 것도 도움이 된다.

스프링 학습 테스트를 만들 때 참고할 수 있는 가장 좋은 소스는 바로 스프링 자신에 대한 테스트 코드다. 스프링은 꼼꼼하게 테슽트를 만들어가며 개발해온 프레임워크다. 거의 모든 기능에 대해 방대한 양의 테스트가 만들어져 있다. 스프링 배포한의 압축을 풀어보면 프레임워크 소스코드와 함께 테스트 코드도 발견할 수 있을 것이다. 스프링 테스트를 잘 살펴보면 레퍼런스 문서에서는 미처 설명되지 않았던 중요한 정보도 많이 얻을 수 있다. 또, 테스트 작성 방법에 대한 좋은 팁을 얻을 수 있을 것이다.

### 학습 테스트 예제
#### JUnit 테스트 오브젝트 테스트
JUnit은 테스트 메소드를 수행할 때 마다 새로운 오브젝트를 만든다고 했다. JUnit에 대한 학습 테스트를 만들어보자.

테스트 방법은 이렇다. 새로운 테스트 클래스를 만들고 적당한 이름으로 세 개의 테스트 메소드를 추가한다. 테스트 클래스 자신의 타입으로 스태틱 변수를 하나 선언한다. 매 테스트 메소드에서 현재 스태틱 변수에 담기 오브젝트와 자신을 비교해서 같지않다는 사실을 확인한다.

~~~java
// JUnit 테스트 오브젝트 생성에 대한 학습 테스트
public class JUnitTest {
  static JUnitTest testObject;

  @Test
  public void test1() {
    assertThat(this, is(not(sameInstance(testObject))));
    testObject = this;
  }

  @Test
  public void test2() {
    assertThat(this, is(not(sameInstance(testObject))));
    testObject = this;
  }

  @Test
  public void test3() {
    assertThat(this, is(not(sameInstance(testObject)))));
    testObject = this;
  }
}
~~~
assertThat() 에서 사용하는 몇 가지 매처가 추가됐다. not()은 뒤에 나오는 결과를 부정하는 매처다. is()는 equals() 비교를 해서 같으면 성공이지만 is(not())은 반대로 같지 않아야 성공한다. sameInstance()는 실제로 같은 오브젝트인지를 비교한다.

테스트를 돌려보면 성공할 것이다. 테스트 메소드가 실행될 때마다 스태틱 변수인 testObject에 저장해둔 오브젝트와 다른 새로운 테스트 오브젝트가 만들어졌음을 확인할 수 있다. 한 가지 찜찜한 점은 이 방식으로는 직전 테스트에서 만들어진 테스트 오브젝트와만 비교한다는 점이다. 만약 첫 번째와 세 번째 테스트 오브젝트가 같은 경우가 있다면 그것은 검증이 안 된다. 이왕 하는 김에 좀 더 꼼꼼한 테스트를 위해 테스트 방법을 조금 개선해보자.

~~~java
public class JUnitTest {
  static set<JUnitTest> testObjects = new HashSet<JUnitTest>();

  @Test
  public void test1() {
    assertThat(testObjects, not(hasItem(this)));
    testObjects.add(this);
  }

  @Test
  public void test2() {
    assertThat(testObjects, not(hasItem(this)));
    testObjects.add(this);
  }

  @Test
  public void test3() {
    assertThat(testObjects, not(hasItem(this)));
    testObjects.add(this);
  }
}
~~~

먼저 스태틱 변수로 테스트 오브젝트를 저장할 수 있는 컬렉션을 만들어둔다. 테스트마다 현재 테스트 오브젝트가 컬렉션에 이미 등록되어 있는지 확인하고, 없으면 자기 자신을 추가한다. 이 과정을 반복한다. 이 방법을 이용하면 테스트가 어떤 순서로 실행되는지에 상관없이 오브젝트 중복 여부를 확인할 수 있다.

이렇게 만들어진 학습 테스트를 이용하면 JUnit이 매번 새로운 테스트 오브젝트를 만든다는 사실을 분명히 확인할 수 있다. 테스트 메소드 개수를 더 늘려도 동일한 결과가 나올 것이다.

이 학습 테스트는 JUnit의 사용 방법을 익히기 위해 코드를 만든 것은 아니었다. 하지만 JUnit의 특성을 분명히 이해할 수 있게 됐고, 또 테스트를 만든느 방법에 대한 공부도 되니 일석이조다. 테스트를 만드는 동안 세 개의 새로운 매처를 사용해봤고, 오브젝트 중복에 대한 테스트를 만드는 방법도 여러 가지로 적용해볼 수 있었다.

#### 스프링 테스트 컨텍스트 테스트
이번에는 스프링 테스트 컨텍스트 프레임워크에 대한 학습 테스트를 만들어보자. JUnit과 반대로 스프링의 테스트용 애플리케이션 컨텍스트는 테스트 개수에 상관없이 한 개만 만들어진다. 또 이렇게 만들어진 컨텍스트는 모든 테스트에서 공유된다고 했다. 정말 그런지 검증하는 학습 테스트를 만들어보자.

테스트에서 사용할 설정파일이 하나 필요하다. 학습 테스트는 가능하면 독립적으로 만드는 것이 좋으니 새로운 설정파일을 만들어보자.

~~~xml
//JUnit테스트를 위한 빈 설정파일 junit.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframewordk.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/chema/beans
  http://www.springframework.org/schema/beans/spring-beans.xsd">

</beans>
~~~
앞서 만들었던 JUnitTest에 @RunWith와 @ContextConfiguration 애노테이션을 추가하고, 방금 만든 설정파일을 사용하는 테스트 컨텍스트를 적용한다. @Autowired로 주입된 context 변수가 같은 오브젝트인지 확인하는 코드를 추가한다.

~~~java
// 스프링 테스트 컨텍스트에 대한 학습 테스트
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
public class JUnitTest {
  @Autowired
  ApplicationContext context; //테스트 컨텍스트가 매번 주입해주는 애플리케이션 컨텍스트는 항상 같은 오브젝트인지 테스트로 확인해본다.

  static Set<JUnitTest> testObjects = new HashSet<JUnitTest>();
  static ApplicationContext contextObject = null;

  @Test
  public void test1() {
    assertThat(testObjects, not(hasItem(this)));
    testObjects.add(this);

    assertThat(contextObject == null || contextObject == this.context, is(true));
    contextObject = this.context;
  }

  @Test
  public void test2() {
    assertThat(testObjects, not(hasItem(this)));
    testObjects.add(this);

    assertTrue(contextObject == null || contextObject == this.context);
    contextObject = this.context;
  }

  @Test
  public void test3() {
    assertThat(testObjects, not(hasItem(this)));
    testObjects.add(this);

    assertThat(contextObject, either(is(nullValue())).or(is(this.context)));
    contextObject = this.context;
  }
}
~~~
테스트 메소드에서 매번 동일한 애플리케이션 컨텍스트가 context 변수에 주입됐는지 확인해야 한다. 확인 방법은 먼저 context를 저장해둘 스태틱 변수인 contextObject가 null인지 확인한다. null이라면 첫 번째 테스트일 테니까 일단 통과. 그리고 contextObject에 현재 context를 저장해둔다. 다음 부터는 저장된 contextObject가 null이 아닐 테니 현재의 context가 null이 아닐 테니 현재의 context가 같은지 비교할 수 있다. 한 번이라도 다른 오브젝트가 나오는 테스트는 실패한다.

위의 검증 로직을 코드로 만드는 방법을 테스트 메소드마다 다른 방법을 사용했다.

첫 번째 방법은 assertThat()을 이용하는 것이다. 매처와 비교할 대상인 첫 번째 파라미터에 Boolean 타입의 결과가 나오는 조건문을 넣는다. 그리고 그 결과를 is() 매처를 써서 true와 비교하면 된다. 지금까지 사용했던 assertThat()과 is() 를 적절히 사용한 방법이다. is()는 타입만 일치하면 어떤 값이든 검증할 수 있다.

두 번째 방법은 조건문을 받아서 그 결과가 true인지 false인지를 확인하도록 만들어진 assertTrue()라는 검증용 메소드를 assertThat() 대신에 사용한 것이다. 코드가 assertThat() 방식보다는 조금 간결해지는 장점이 있다.

세 번째 방법은 assertThat()을 사용한다. 이번엔 조건문을 넣어서 그 결과를 true와 비교하는 대신 매처의 조합을 이용하는 방법을 사용했다. either()는 뒤에 이어서 나오는 or()와 함께 두 개의 매처의 결과를 OR 조건으로 비교해준다. 두 가지 매처 중에서 하나만 true로 나와도 성공이다. 새롭게 사용한 매처가 있는데 바로 nullValue()다. nullValue()는 이름 그대로 오브젝트가 null인지를 확인해준다.

어떤 기술이든 마찬가지지만 특히 스프링은 문서만 가지고 공부해서는 쉽게 이해하고 익히기 힘들다. 실전에 적용하기 전에 스프링의 기능을 사용한 테스트를 가능한 한 많이 만들어보자.

### 버그 테스트
버그 테스트(bug test)란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다. QA팀의 테스트 중에 기능 오류가 발견됐다고 하자. 이때 무턱대고 코드를 뒤져가면서 수정하려고 하기보다는 먼저 버그 테스트를 만들어보는 편이 유용한다.

버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 돼서 테스트가 실패하는 코드를 만드는 것이다. 그리고 나서 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정한다. 테스트가 성공하면 버그는 해결된 것이다.

버그테스트의 필요성과 장점은 다음과 같다
##### 테스트의 완성도를 높여준다
기존 테스트에서는 미처 검증하지 못했던 부분이 있기 때문에 오류가 발생한 것이다. 이에 대해 테스트를 만들면 불충분했던 테스트를 보완해준다.

##### 버그의 내용을 명확하게 분석하게 해준다
버그가 있을 때 그것을 테스트로 만들어서 실패하게 하려면 어떤 이유 때문에 문제가 생겼는지 명확히 알아야 한다. 따라서 버그를 좀 더 효과적으로 분석할 수 있다.

##### 기술적인 문제를 해결하는 데 도움이 된다
때로는 버그가 있다는 건 알겠지만 그 원인이 무엇인지 정확하게 파악하기 힘들 때가 있다. 이럴 땐 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.

## 정리
2장에서는 다음과 같이 테스트의 필요성과 작성 방법을 살펴봤다.
- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- main() 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠수 있다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용한다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- @Before, @After를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.

스프링을 사용하는 개발자라면 자신이 만든 코드를 테스트로 검증하는 방법을 알고 있어야 하며, 테스트를 개발에 적극적으로 활용할 수 있어야 한다.
