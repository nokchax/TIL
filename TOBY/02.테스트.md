# 테스트
애플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이라면, 두 번째 전략은 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자심감을 주는 테스트 기술이다.

스프링으로 개발을 하면서 테스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반을 포기하는 셈이다. 스프링 개발자라면 테스트 작성 방법과 이를 효과적으로 개발에 활용하는 전략을 알아야 하며, 이를 실전에 적용할 수 있어야 한다.

또한 테스트는 스프링을 학슴하는 데 있어 가장 효과적인 방법의 하나다. 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

이번장에서는 테스트란 무엇이며, 그 가치와 장점, 활용 전략, 스프링과의 관계를 살펴본다.

## UserDaoTest 다시보기
### 테스트의 유용성
1장에서 만든 UserDao가 기대했던 대로 동작하는지 확인하기 위해 간단한 테스트 코드를 만들었다. main() 메소드를 이용해 UserDao 오브젝트의 add(), get() 메소드를 호출하고, 그 결과를 화면에 출력해서 그 값을 눈으로 확인시켜준다.
이렇게 만든 테스트용 main() 메소드를 반복적으로 실행해가면서 처음 설계한 대로 기능이 동작하는지를 매 단계 확인한 덕분에, 다양한 방법으로 초난감 UserDao 코드의 설계와 코드를 개선했고, 심지어 스프링을 적용해서 동작하게 만들 수도 있었다. 코드의 구조와 설계, 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 초난감 UserDao와 다를 바 없이 DB에 사용자 정보를 등록하고, 가져오는 기능을 잘 수행한다는 걸 테스트를 통해 확인할 수 없었다면, 그 코드를 개선하는 과정 내내 뭔가 꺼림칙하고 불안했을 것이다. UserDao의 클래스를 책임에 따라 이리저리 분리하고, 인터페이스를 도입하고, 오브젝트 팩토리를 통해 생성하도록 만들고, 또 스프링의 DI 방식을 XML 설정파일까지 써서 적용했을 때 그것이 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법에는 어떤 것이 있겠는가? 테스트를 통해 직접 기능을 동작시켜서 결과를 확인하는 방법 외에는 없다. 코드를 들여다보며 머릿속으로 시뮬레이션하는 방법이 있긴 하지만 그것만으로는 100% 확신할 수 없다.
테스트란 결국 내가 예상하고 의도했던 대로 코드가 정홯히 동작하는지를 확인해서 만든 코드를 확신할 수 있게 해주는 작업이다. 또한 테스트의 결과가 원하는 대로 나오지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 코드의 결함을 제거해가는 작업, 일명 디버깅을 거치게 되고, 결국 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확신을 얻을 수 있다.

### UserDaoTest의 특징
~~~Java
public class UserDaoTest {
  public static void main(String[] args) throws SQLException {
    ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

    UserDao dao = context.getBean("userDao", UserDao.class);

    User user = new User();
    user.setId("user");
    user.setName("김광현");
    user.setPassword("kh");

    dao.add(user);

    System.out.println(user.getId() + " 등록 성공");

    User user2 = dao.get(user.getId());
    System.out.println(user2.getName());
    System.out.println(user2.getPassword());

    System.out.println(user2.getId() + " 조회 성공");
  }
}
~~~

위의 테스트 코드의 내용을 정리해보면 다음과 같다.
- 손쉽게 실행 가능한 main() 메소드를 이용한다.
- 테스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.
- 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
- 테스트의 결과를 콘솔에 출력해준다.
- 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메세지를 출력해준다.

이 테스트 방법에서 가장 돋보이는 건, main() 메소드를 이용해 쉽게 테스트 수행을 가능하게 했다는 점과 테스트할 대상인 UserDao를 직접 호출해서 사용한다는 점이다.

#### 웹을 통한 DAO 테스트 방법의 문제점
보통 웹 프로그램에서 사용하는 DAO를 테스트하는 방법은 다음과 같다. DAO를 만든 뒤 바로 테스트하지 않고, 서비스 계층, MVC 프레젠테이션 계층까지 포함한 모든 입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트용 웹 애플리케이션을 서버에 배치한 뒤, 웹 화면을 띄워 폼을 열고, 값을 입력한 뒤 버튼을 눌러 등록해본다.

이를 위해서는 폼의 값을 받아서 파싱한 뒤에 User 오브젝트로 만들고 UserDao를 호출해주는 기능이 이미 만들어져 있어야 한다. 이 기능이 문제가 없다면 다음엔 검색 폼이나 파라미터를 지정할 수 있는 URL을 사용해서 방금 입력한 데이터를 다시 가져올 수 있는지 테스트해본다. 역시 UserDao가 돌려주는 결과를 화면에 춣력해주는 기능이 만들어져 있어야 확인이 가능하다.

이렇게 웹 화면을 통해 값을 입력하고, 기능을 수행하고, 결과를 확인하는 방법은 가장 흔히 쓰이는 방법이지만, DAO에 대한 테스트로서는 단점이 너무 많다. DAO뿐만 아니라 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다. 테스트 도중에 에러가 났다면 어디서 어떤 문제가 발생했는지를 찾아내기 위한 수고가 필요하다. 하나의 테스트를 수행하는 데 참여하는 클래스와 코드가 너무 많기 때문이다.

DB 연결 방법에 문제가 있었을 수도 있고, DAO 코드가 잘못되어 JDBC API를 잘못 호출해서일 수도 있다. 혹은 SQL 문법이 틀렸거나, 파라미터로 넘어온 값을 잘못 바인딩했을 수도 있다. 정작 테스트할 대상인 DAO의 문제가 아니라 서버환경에서 웹 화면을 통해 DAO를 테스트하려고 만든 다른 코드 때문에 에러가 나거나 테스트가 실패할 수도 있다. 혹은 모든 것이 다 성공했지만 최종적으로 결과 메시지를 출력하는 JSP 뷰에 문제가 있어서 오류가 난 것처럼 보일 수도 있다.

사실 테스트하고 싶었던 건 UserDao였는데 다른 계층의 코드와 컴포넌트, 심지어 서버의 설정 상태까지 모두 테스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트하는 것은 번거롭고, 오류가 있을 때 빠르고 정확하게 대응하기가 힘들다는 문제가 있다.

그렇다면 테스트를 어떻게 만들면 이런 문제를 피할 수 있고, 효율적으로 테스트를 활용할 수 있을지 생각해보자.

#### 작은 단위의 테스트
테스트하고자 하는 대상이 명확하다면 그 대상에만 집중해서 테스트하는 것이 바람직 하다. 한번에 너무 많은 것을 몰아서 테스트하면 테스트 수행 과정도 복잡해지고, 오류가 발생했을 때 원인을 찾기도 힘들어진다. 따라서 테스트는 가능하면 작은 단위로 쪼개서 집중해서 할 수 있어야 한다.

작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit test)라고 하는데, 여기서 단위란 그 크기와 범위가 딱 정해진 것은 아니다. 충분히 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다. 일반적으로 단위는 작을수록 좋다. 단위를 넘어서는 다른 코드들은 신경 쓰지 않고, 참여하지도 않고 테스트가 동작할 수 있으면 좋다.

통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 보기도 한다.

단위 테스트를 하는 이유는 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지를 개발자 스스로 빨리 확인받기 위해서다. 이때 확인의 대상과 조건이 간단하고 명확할수록 좋다. 그래서 작은 단위로 제한해서 테스트하는 것이 편리하다.

#### 자동수행 테스트 코드
