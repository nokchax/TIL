# Transaction
## 트랜잭션이란
- transaction 이라는 단어는 거래를 뜻하는데, 데이터베이스 등에서 사용되는 쪼갤 수 없는 업무의 단위를 뜻한다.
- 돈을 줬는데 물건을 받지 못하면, 그 거래는 이루어지지 않고 원상 복구되어야 한다. 이와 같이 쪼갤 수 없는 하나의 처리 행위를 원자적 행위 라고 한다.
- 여기서 쪼갠다는 의미는 실제로 쪼갤 수 없다는 뜻 보다는, 쪼개질 경우 시스템에 심각한 오류를 초래할 수 있다는 것이다.

## 트랜잭션 ACID

### ACID
데이터베이스에서 트랜잭션의 무결성을 보장하기 위해 반드시 필요한 4가지 요소(기능)를 말한다.
> 무결성이란? 데이터의 정확성과 일관성을 유지하고, 데이터에 결손과 부정합이 없음을 보증하는 것

### Atomic (원자성)
- 트랜잭션의 처리는 완전히 끝마치지 않은경우, 전혀 이루어지지 않은 것과 같아야 한다.
- 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장한다. 
- 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하고, 이전에 커밋된 상태를 임시영역에 저장함으로써 보장한다.
- 이전 데이터들이 임시로 저장되는 영역을 롤백 세그먼트(rollback segment)라고 한다.

### Consistency (일관성)
- 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다.
- 같은 DB에 같은 트랜잭션은 항상 동일한 결과를 나타내야 한다는 의미한다.
- DB에 기록되는 데이터는 제약조건, 트리거, 케스케이드 등과 이 것들의 조합을 포함하여 정의된 규칙에 따라 유효해야한다.
- 트랜잭션 수행 전,후에 데이터 모델의 모든 제약 조건(기본키, 외래키, 도메인, 도메인 제약조건 등)을 만족하는 것을 통해 보장한다.
- 트리거를 통해 보장.

### Isolation (독립성, 고립성)
- 트랜잭션의 부분적인 상태를 다른 트랜잭션에 제공해서는 안 된다.
- 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 
- 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없음을 의미한다. 
- lock & execute unlock 을 통해 보장한다.
- 데이터를 읽거나 쓸 때는 락을 걸어 다른 트랜잭션이 접근하지 못하도록 고립성을 보장하고
- 수행을 마치면 unlock을 통해 데이터를 다른 트랜잭션이 접근할 수 있도록 허용하는 방식.
- 트랜잭션에서는 데이터를 읽을 때, 여러 트랜잭션이 읽을 수는 있도록 허용하는 shared_lock을 한다. 즉, shared_lock은 데이터 쓰기를 허용하지 않고 오직 읽기만 허용한다.
- 데이터를 쓸 때는 다른 트랜잭션이 읽을 수도 쓸 수도 없도록 하는 exclusive_lock을 사용한다.
- 그리고 읽기, 쓰기 작업이 끝나면 unlock을 통해 다른 트랜잭션이 lock을 할 수 있도록 데이터에 대한 lock을 풀어준다.
- 이러한 lock & unlock 으로 deadlock이 걸릴수 있다.
- 2 Phase Locking protocol 을 통해 데드락을 방지한다.
- 2PL 프로토콜이란 여러 트랜잭션이 공유하고 있는 데이터에 동시에 접근할 수 없도록 하기위한 목적을 가진 프로토콜을 말한다.
- 2가지 단계의 locking이 존재하는데, 한 가지는 growing phase이고 다른 한 가지는 shrinking phase 이다.
- growing phase란 read_lock , write_lock을 의미하고, shrinking phase란 unlock를 의미한다.
- 2PL 프로토콜은 상승 단계와 하강 단계와 섞이면 안된다는 것을 의미.
- 즉, lock과 unlock이 번갈아 수행되지 않고 lock이 쭉 수행된 후에 unlock이 쭉 수행되어야 한다는 것이 이 프로토콜.

### Durability (지속성)
- 성공적인 트랜잭션 수행 후에는 반드시 데이터베이스에 반영 되어야 한다.
- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다.


---

## 격리레벨
한 트랜잭션에서 데이터의 상태를 변경했을 떄, 동시에 실행되는 다른 트랜젝션에 변경된 상태를 공유할지 말지 또, 공유를 한다면 어느정도 수준까지 공유할 지를 설정하는 것.

### Dirty read
commit 을 하지 않더라도 다른 트랜잭션에 영향을 미침

### NonRepeatable read
update, delete 쿼리의 경우 commit 을 한 이후에 다른 트랜잭션에 영향을 미침

### Phantom read
insert 쿼리의 경우 commit 을 한 이후 다른 트랜젝션에 영향을 미침


|Isolation level|Dirty read|NonRepeatable read|Phantom read|
|---|:---:|:---:|:---:|
|Read uncommitted|O|O|O|
|Read committed|X|O|O|
|Repeatable read|X|X|O|
|Serializable|X|X|X|

디폴트는 read committed 이며, MySQL 에서는 Repeatable read 가 디폴트다.

### 정리
#### Read uncommitted
다른 트랜잭션에서 커밋하지 않더라도 그 결과가 반영되어 조회가 가능하다.

#### Read committed
다른 트랜잭션에서 insert, update, delete 한 건에 대해 커밋한 경우에만 조회가 가능하다.

#### Repeatable read
다른 트랜잭션에서 insert 하고 커밋한 경우에만 조회 가능

#### Serializable
다른 트랜잭션에서 무얼하던 조회 할 수 없다. 하나의 트랜잭션이 완료된 이후 다른 트랜잭션이 실행하는 것처럼 지원하며, 높은 비용을 요구한다.
